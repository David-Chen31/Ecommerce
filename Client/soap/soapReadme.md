<div style='display: none'>
@tableofcontents @section README

To view this file in the Firefox web browser, download readmeviewer.html from https://www.genivia.com/files/readmeviewer.html.zip, unzip and copy it to the same directory where this soapReadme.md file is located, then open it in Firefox to view the contents of soapReadme.md.

This markdown file is compatible with Doxygen.
</div>

## Overview {#doc-overview}

This report was generated by soapcpp2 v2.8.135 for interface header file [soap_head.h](soap_head.h) with options -r  -C -L -j -w 

### Tools

The **wsdl2h** command line tool takes a set of WSDL and XSD files to generate a data binding interface header file.  This interface header file is similar to a C/C++ header file and contains declarations of C/C++ types and functions with explanatory comments, directives, and annotations.  Types are declared in this interface header file as serializable.  Functions are declared as Web service operations for the client and server sides.

The **soapcpp2** command line tool takes an interface header file (i.e. a header file) such as [soap_head.h](soap_head.h) to generate the data binding implementation.  This implementation includes XML serializers and source code for the client and server side.  An interface header file for soapcpp2 can be a regular C/C++ header file with type and function declarations (without code), and include annotations to declare XML schema-related properties.

### Files

The following c++ source code files were generated by soapcpp2 for interface header file [soap_head.h](soap_head.h):

- [soapStub.h](soapStub.h) contains an annotated copy of [soap_head.h](soap_head.h) and of the imported files (if any), where most of the information in this report [soapReadme.md](soapReadme.md) is sourced from (this header file also #includes "stdsoap2.h")
- [soapH.h](soapH.h) declares allocation and (de)serialization functions for each C/C++ type, to #include in projects (this header file also #includes "soapStub.h")
- [soapC.cpp](soapC.cpp) defines allocation and (de)serialization functions for each C/C++ type, to compile with a project
- See [Web client proxy class](#doc-client) for the client-side source code files to use

Also compile stdsoap2.cpp (and dom.cpp if XML DOM is used) with a project (or link libgsoapssl++.a) and use the following compile-time options:

- `-DWITH_OPENSSL` to enable HTTPS with OpenSSL
- `-DWITH_GNUTLS` to enable HTTPS with GNUTLS
- `-DWITH_DOM` is required when using the WS-Security plugin
- `-DWITH_GZIP` to enable message compression

See the gSOAP documentation for additional options.

### Contents

This report has the following contents describing the data binding interface types, and the client- and the server-side operations (if any):

- [class, struct and union types](#doc-classes)
- [typedefs](#doc-typedefs)
- [summary of serializable types](#doc-types)
- [schemas and namespaces](#doc-namespaces)
- [Web client proxy class](#doc-client) lists the methods to invoke

[![][1] To top](#)


## Class, Struct and Union Types {#doc-classes}

The table below lists the classes, structs and unions declared in [soap_head.h](soap_head.h) or that are imported:

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th></tr>
<tr><td><code><a href="#ns2__selectProductForUpdate"> ns2__selectProductForUpdate </a></code></td><td> soap_head.h:163 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__selectProductForUpdateResponse"> ns2__selectProductForUpdateResponse </a></code></td><td> soap_head.h:165 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__product"> ns2__product </a></code></td><td> soap_head.h:167 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__addProduct"> ns2__addProduct </a></code></td><td> soap_head.h:169 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__addProductResponse"> ns2__addProductResponse </a></code></td><td> soap_head.h:171 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteProductTypeByName"> ns2__deleteProductTypeByName </a></code></td><td> soap_head.h:173 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteProductTypeByNameResponse"> ns2__deleteProductTypeByNameResponse </a></code></td><td> soap_head.h:175 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderList"> ns2__getOrderList </a></code></td><td> soap_head.h:177 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__order"> ns2__order </a></code></td><td> soap_head.h:179 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderListResponse"> ns2__getOrderListResponse </a></code></td><td> soap_head.h:181 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getShopByNameAndPwd"> ns2__getShopByNameAndPwd </a></code></td><td> soap_head.h:183 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getShopByNameAndPwdResponse"> ns2__getShopByNameAndPwdResponse </a></code></td><td> soap_head.h:185 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__shop"> ns2__shop </a></code></td><td> soap_head.h:187 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateShop"> ns2__updateShop </a></code></td><td> soap_head.h:189 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateShopResponse"> ns2__updateShopResponse </a></code></td><td> soap_head.h:191 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductListByInfo"> ns2__getProductListByInfo </a></code></td><td> soap_head.h:193 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductListByInfoResponse"> ns2__getProductListByInfoResponse </a></code></td><td> soap_head.h:195 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromShop"> ns2__getReadMessageFromShop </a></code></td><td> soap_head.h:197 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__client"> ns2__client </a></code></td><td> soap_head.h:199 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromShopResponse"> ns2__getReadMessageFromShopResponse </a></code></td><td> soap_head.h:201 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__message"> ns2__message </a></code></td><td> soap_head.h:203 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateClient"> ns2__updateClient </a></code></td><td> soap_head.h:205 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateClientResponse"> ns2__updateClientResponse </a></code></td><td> soap_head.h:207 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteProductByInfo"> ns2__deleteProductByInfo </a></code></td><td> soap_head.h:209 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteProductByInfoResponse"> ns2__deleteProductByInfoResponse </a></code></td><td> soap_head.h:211 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteClientByNameAndPwd"> ns2__deleteClientByNameAndPwd </a></code></td><td> soap_head.h:213 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteClientByNameAndPwdResponse"> ns2__deleteClientByNameAndPwdResponse </a></code></td><td> soap_head.h:215 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__InsertShop"> ns2__InsertShop </a></code></td><td> soap_head.h:217 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__InsertShopResponse"> ns2__InsertShopResponse </a></code></td><td> soap_head.h:219 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromShop"> ns2__updateMessageFromShop </a></code></td><td> soap_head.h:221 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromShopResponse"> ns2__updateMessageFromShopResponse </a></code></td><td> soap_head.h:223 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductTypeByProName"> ns2__getProductTypeByProName </a></code></td><td> soap_head.h:225 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductTypeByProNameResponse"> ns2__getProductTypeByProNameResponse </a></code></td><td> soap_head.h:227 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__productType"> ns2__productType </a></code></td><td> soap_head.h:229 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getClientList"> ns2__getClientList </a></code></td><td> soap_head.h:231 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getClientListResponse"> ns2__getClientListResponse </a></code></td><td> soap_head.h:233 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__purchaseProduct"> ns2__purchaseProduct </a></code></td><td> soap_head.h:235 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__purchaseProductResponse"> ns2__purchaseProductResponse </a></code></td><td> soap_head.h:237 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromClient"> ns2__updateMessageFromClient </a></code></td><td> soap_head.h:239 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromClientResponse"> ns2__updateMessageFromClientResponse </a></code></td><td> soap_head.h:241 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromClient"> ns2__getUnreadMessageFromClient </a></code></td><td> soap_head.h:243 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromClientResponse"> ns2__getUnreadMessageFromClientResponse </a></code></td><td> soap_head.h:245 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateProductByInfo"> ns2__updateProductByInfo </a></code></td><td> soap_head.h:247 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateProductByInfoResponse"> ns2__updateProductByInfoResponse </a></code></td><td> soap_head.h:249 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getMessageFromClient"> ns2__getMessageFromClient </a></code></td><td> soap_head.h:251 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getMessageFromClientResponse"> ns2__getMessageFromClientResponse </a></code></td><td> soap_head.h:253 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__addOrder"> ns2__addOrder </a></code></td><td> soap_head.h:255 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__addOrderResponse"> ns2__addOrderResponse </a></code></td><td> soap_head.h:257 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteShopByNameAndPwd"> ns2__deleteShopByNameAndPwd </a></code></td><td> soap_head.h:259 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteShopByNameAndPwdResponse"> ns2__deleteShopByNameAndPwdResponse </a></code></td><td> soap_head.h:261 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductList"> ns2__getProductList </a></code></td><td> soap_head.h:263 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductListResponse"> ns2__getProductListResponse </a></code></td><td> soap_head.h:265 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderListHistory"> ns2__getOrderListHistory </a></code></td><td> soap_head.h:267 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderListHistoryResponse"> ns2__getOrderListHistoryResponse </a></code></td><td> soap_head.h:269 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromClient"> ns2__getReadMessageFromClient </a></code></td><td> soap_head.h:271 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromClientResponse"> ns2__getReadMessageFromClientResponse </a></code></td><td> soap_head.h:273 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateHistory"> ns2__updateHistory </a></code></td><td> soap_head.h:275 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__updateHistoryResponse"> ns2__updateHistoryResponse </a></code></td><td> soap_head.h:277 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__InsertMessage"> ns2__InsertMessage </a></code></td><td> soap_head.h:279 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__InsertMessageResponse"> ns2__InsertMessageResponse </a></code></td><td> soap_head.h:281 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getShopLikeList"> ns2__getShopLikeList </a></code></td><td> soap_head.h:283 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getShopLikeListResponse"> ns2__getShopLikeListResponse </a></code></td><td> soap_head.h:285 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getMessageFromShop"> ns2__getMessageFromShop </a></code></td><td> soap_head.h:287 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getMessageFromShopResponse"> ns2__getMessageFromShopResponse </a></code></td><td> soap_head.h:289 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromShop"> ns2__deleteMessageFromShop </a></code></td><td> soap_head.h:291 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromShopResponse"> ns2__deleteMessageFromShopResponse </a></code></td><td> soap_head.h:293 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderLikeList"> ns2__getOrderLikeList </a></code></td><td> soap_head.h:295 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderLikeListResponse"> ns2__getOrderLikeListResponse </a></code></td><td> soap_head.h:297 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromShop"> ns2__getUnreadMessageFromShop </a></code></td><td> soap_head.h:299 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromShopResponse"> ns2__getUnreadMessageFromShopResponse </a></code></td><td> soap_head.h:301 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getClientLikeList"> ns2__getClientLikeList </a></code></td><td> soap_head.h:303 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getClientLikeListResponse"> ns2__getClientLikeListResponse </a></code></td><td> soap_head.h:305 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getShopList"> ns2__getShopList </a></code></td><td> soap_head.h:307 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getShopListResponse"> ns2__getShopListResponse </a></code></td><td> soap_head.h:309 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderListByInfo"> ns2__getOrderListByInfo </a></code></td><td> soap_head.h:311 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getOrderListByInfoResponse"> ns2__getOrderListByInfoResponse </a></code></td><td> soap_head.h:313 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__addProductType"> ns2__addProductType </a></code></td><td> soap_head.h:315 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__addProductTypeResponse"> ns2__addProductTypeResponse </a></code></td><td> soap_head.h:317 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromClient"> ns2__deleteMessageFromClient </a></code></td><td> soap_head.h:319 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromClientResponse"> ns2__deleteMessageFromClientResponse </a></code></td><td> soap_head.h:321 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductLikeList"> ns2__getProductLikeList </a></code></td><td> soap_head.h:323 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getProductLikeListResponse"> ns2__getProductLikeListResponse </a></code></td><td> soap_head.h:325 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getClientByNameAndPwd"> ns2__getClientByNameAndPwd </a></code></td><td> soap_head.h:327 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__getClientByNameAndPwdResponse"> ns2__getClientByNameAndPwdResponse </a></code></td><td> soap_head.h:329 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteShoppingCart"> ns2__deleteShoppingCart </a></code></td><td> soap_head.h:331 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__deleteShoppingCartResponse"> ns2__deleteShoppingCartResponse </a></code></td><td> soap_head.h:333 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__InsertClient"> ns2__InsertClient </a></code></td><td> soap_head.h:335 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__InsertClientResponse"> ns2__InsertClientResponse </a></code></td><td> soap_head.h:337 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__selectProductForUpdate"> struct __ns1__selectProductForUpdate </a></code></td><td> soap_head.h:2744 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__addProduct"> struct __ns1__addProduct </a></code></td><td> soap_head.h:2811 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteProductTypeByName"> struct __ns1__deleteProductTypeByName </a></code></td><td> soap_head.h:2878 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getOrderList"> struct __ns1__getOrderList </a></code></td><td> soap_head.h:2945 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getShopByNameAndPwd"> struct __ns1__getShopByNameAndPwd </a></code></td><td> soap_head.h:3012 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__updateShop"> struct __ns1__updateShop </a></code></td><td> soap_head.h:3079 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getProductListByInfo"> struct __ns1__getProductListByInfo </a></code></td><td> soap_head.h:3146 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getReadMessageFromShop"> struct __ns1__getReadMessageFromShop </a></code></td><td> soap_head.h:3213 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__updateClient"> struct __ns1__updateClient </a></code></td><td> soap_head.h:3280 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteProductByInfo"> struct __ns1__deleteProductByInfo </a></code></td><td> soap_head.h:3347 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteClientByNameAndPwd"> struct __ns1__deleteClientByNameAndPwd </a></code></td><td> soap_head.h:3414 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__InsertShop"> struct __ns1__InsertShop </a></code></td><td> soap_head.h:3481 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__updateMessageFromShop"> struct __ns1__updateMessageFromShop </a></code></td><td> soap_head.h:3548 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getProductTypeByProName"> struct __ns1__getProductTypeByProName </a></code></td><td> soap_head.h:3615 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getClientList"> struct __ns1__getClientList </a></code></td><td> soap_head.h:3682 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__purchaseProduct"> struct __ns1__purchaseProduct </a></code></td><td> soap_head.h:3749 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__updateMessageFromClient"> struct __ns1__updateMessageFromClient </a></code></td><td> soap_head.h:3816 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getUnreadMessageFromClient"> struct __ns1__getUnreadMessageFromClient </a></code></td><td> soap_head.h:3883 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__updateProductByInfo"> struct __ns1__updateProductByInfo </a></code></td><td> soap_head.h:3950 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getMessageFromClient"> struct __ns1__getMessageFromClient </a></code></td><td> soap_head.h:4017 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__addOrder"> struct __ns1__addOrder </a></code></td><td> soap_head.h:4084 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteShopByNameAndPwd"> struct __ns1__deleteShopByNameAndPwd </a></code></td><td> soap_head.h:4151 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getProductList"> struct __ns1__getProductList </a></code></td><td> soap_head.h:4218 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getOrderListHistory"> struct __ns1__getOrderListHistory </a></code></td><td> soap_head.h:4285 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getReadMessageFromClient"> struct __ns1__getReadMessageFromClient </a></code></td><td> soap_head.h:4352 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__updateHistory"> struct __ns1__updateHistory </a></code></td><td> soap_head.h:4419 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__InsertMessage"> struct __ns1__InsertMessage </a></code></td><td> soap_head.h:4486 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getShopLikeList"> struct __ns1__getShopLikeList </a></code></td><td> soap_head.h:4553 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getMessageFromShop"> struct __ns1__getMessageFromShop </a></code></td><td> soap_head.h:4620 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteMessageFromShop"> struct __ns1__deleteMessageFromShop </a></code></td><td> soap_head.h:4687 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getOrderLikeList"> struct __ns1__getOrderLikeList </a></code></td><td> soap_head.h:4754 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getUnreadMessageFromShop"> struct __ns1__getUnreadMessageFromShop </a></code></td><td> soap_head.h:4821 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getClientLikeList"> struct __ns1__getClientLikeList </a></code></td><td> soap_head.h:4888 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getShopList"> struct __ns1__getShopList </a></code></td><td> soap_head.h:4955 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getOrderListByInfo"> struct __ns1__getOrderListByInfo </a></code></td><td> soap_head.h:5022 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__addProductType"> struct __ns1__addProductType </a></code></td><td> soap_head.h:5089 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteMessageFromClient"> struct __ns1__deleteMessageFromClient </a></code></td><td> soap_head.h:5156 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getProductLikeList"> struct __ns1__getProductLikeList </a></code></td><td> soap_head.h:5223 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__getClientByNameAndPwd"> struct __ns1__getClientByNameAndPwd </a></code></td><td> soap_head.h:5290 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__deleteShoppingCart"> struct __ns1__deleteShoppingCart </a></code></td><td> soap_head.h:5357 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__InsertClient"> struct __ns1__InsertClient </a></code></td><td> soap_head.h:5424 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td> soap_head.h:5649 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td> soap_head.h:5649 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td> soap_head.h:5649 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td> soap_head.h:5649 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td> soap_head.h:5649 </td><td> yes </td></tr>
</table>

<a name="ns2__selectProductForUpdate"></a>

### `ns2__selectProductForUpdate`

This class is declared in [soap_head.h](soap_head.h) at line 163, is serialized as XML schema type *`ns2:selectProductForUpdate`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__selectProductForUpdate {
      public:
        /// Required element 'arg0' of XML schema type 'xsd:int'
        int arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__selectProductForUpdate
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__selectProductForUpdate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__selectProductForUpdate, default initialized and not managed by a soap context
        virtual ns2__selectProductForUpdate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__selectProductForUpdate); }
      public:
        /// Constructor with default initializations
        ns2__selectProductForUpdate() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__selectProductForUpdate() { }
        /// Friend allocator used by soap_new_ns2__selectProductForUpdate(struct soap*, int)
        friend SOAP_FMAC1 ns2__selectProductForUpdate * SOAP_FMAC2 soap_instantiate_ns2__selectProductForUpdate(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int arg0` is a required element *`<arg0>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__selectProductForUpdate` are available:

- `ns2__selectProductForUpdate *soap_new_ns2__selectProductForUpdate(struct soap*)` managed allocation with default initialization
- `ns2__selectProductForUpdate *soap_new_ns2__selectProductForUpdate(struct soap*, int n)` managed allocation of array `ns2__selectProductForUpdate[n]`
- `ns2__selectProductForUpdate *soap_new_req_ns2__selectProductForUpdate(struct soap*, int arg0)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__selectProductForUpdate *soap_new_set_ns2__selectProductForUpdate(struct soap*, int arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__selectProductForUpdate::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__selectProductForUpdate(struct soap*, const ns2__selectProductForUpdate*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__selectProductForUpdate(struct soap*, const char *URL, const ns2__selectProductForUpdate*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__selectProductForUpdate(struct soap*, const char *URL, const ns2__selectProductForUpdate*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__selectProductForUpdate(struct soap*, const char *URL, const ns2__selectProductForUpdate*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__selectProductForUpdate(struct soap*, ns2__selectProductForUpdate*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__selectProductForUpdate(struct soap*, const char *URL, ns2__selectProductForUpdate*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__selectProductForUpdate(struct soap*, ns2__selectProductForUpdate*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__selectProductForUpdateResponse"></a>

### `ns2__selectProductForUpdateResponse`

This class is declared in [soap_head.h](soap_head.h) at line 165, is serialized as XML schema type *`ns2:selectProductForUpdateResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__selectProductForUpdateResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        ns2__product *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__selectProductForUpdateResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__selectProductForUpdateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__selectProductForUpdateResponse, default initialized and not managed by a soap context
        virtual ns2__selectProductForUpdateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__selectProductForUpdateResponse); }
      public:
        /// Constructor with default initializations
        ns2__selectProductForUpdateResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__selectProductForUpdateResponse() { }
        /// Friend allocator used by soap_new_ns2__selectProductForUpdateResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__selectProductForUpdateResponse * SOAP_FMAC2 soap_instantiate_ns2__selectProductForUpdateResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__product *return_` is an optional element *`<return>`* of XML schema type *`ns2:product`*, where the type of this member is a pointer to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__selectProductForUpdateResponse` are available:

- `ns2__selectProductForUpdateResponse *soap_new_ns2__selectProductForUpdateResponse(struct soap*)` managed allocation with default initialization
- `ns2__selectProductForUpdateResponse *soap_new_ns2__selectProductForUpdateResponse(struct soap*, int n)` managed allocation of array `ns2__selectProductForUpdateResponse[n]`
- `ns2__selectProductForUpdateResponse *soap_new_req_ns2__selectProductForUpdateResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__selectProductForUpdateResponse *soap_new_set_ns2__selectProductForUpdateResponse(struct soap*, ns2__product *return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__selectProductForUpdateResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__selectProductForUpdateResponse(struct soap*, const ns2__selectProductForUpdateResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__selectProductForUpdateResponse(struct soap*, const char *URL, const ns2__selectProductForUpdateResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__selectProductForUpdateResponse(struct soap*, const char *URL, const ns2__selectProductForUpdateResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__selectProductForUpdateResponse(struct soap*, const char *URL, const ns2__selectProductForUpdateResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__selectProductForUpdateResponse(struct soap*, ns2__selectProductForUpdateResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__selectProductForUpdateResponse(struct soap*, const char *URL, ns2__selectProductForUpdateResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__selectProductForUpdateResponse(struct soap*, ns2__selectProductForUpdateResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__product"></a>

### `ns2__product`

This class is declared in [soap_head.h](soap_head.h) at line 167, is serialized as XML schema type *`ns2:product`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__product {
      public:
        /// Optional element 'discountEndTime' of XML schema type 'xsd:dateTime'
        time_t *discountEndTime;
        /// Optional element 'discountStartTime' of XML schema type 'xsd:dateTime'
        time_t *discountStartTime;
        /// Optional element 'flashSaleEndTime' of XML schema type 'xsd:dateTime'
        time_t *flashSaleEndTime;
        /// Required element 'flashSalePurchaseLimit' of XML schema type 'xsd:int'
        int flashSalePurchaseLimit;
        /// Optional element 'flashSaleStartTime' of XML schema type 'xsd:dateTime'
        time_t *flashSaleStartTime;
        /// Required element 'productBuyNum' of XML schema type 'xsd:int'
        int productBuyNum;
        /// Required element 'productDiscount' of XML schema type 'xsd:float'
        float productDiscount;
        /// Required element 'productFlashSalePrice' of XML schema type 'xsd:float'
        float productFlashSalePrice;
        /// Required element 'productId' of XML schema type 'xsd:int'
        int productId;
        /// Optional element 'productImage' of XML schema type 'xsd:string'
        std::string *productImage;
        /// Optional element 'productName' of XML schema type 'xsd:string'
        std::string *productName;
        /// Required element 'productNum' of XML schema type 'xsd:int'
        int productNum;
        /// Required element 'productPrice' of XML schema type 'xsd:int'
        int productPrice;
        /// Required element 'productShopId' of XML schema type 'xsd:int'
        int productShopId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__product
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__product; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__product, default initialized and not managed by a soap context
        virtual ns2__product *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__product); }
      public:
        /// Constructor with default initializations
        ns2__product() : discountEndTime(), discountStartTime(), flashSaleEndTime(), flashSalePurchaseLimit(), flashSaleStartTime(), productBuyNum(), productDiscount(), productFlashSalePrice(), productId(), productImage(), productName(), productNum(), productPrice(), productShopId(), soap() { }
        /// Destructor
        virtual ~ns2__product() { }
        /// Friend allocator used by soap_new_ns2__product(struct soap*, int)
        friend SOAP_FMAC1 ns2__product * SOAP_FMAC2 soap_instantiate_ns2__product(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `time_t *discountEndTime` is an optional element *`<discountEndTime>`* of XML schema type *`xsd:dateTime`*
- `time_t *discountStartTime` is an optional element *`<discountStartTime>`* of XML schema type *`xsd:dateTime`*
- `time_t *flashSaleEndTime` is an optional element *`<flashSaleEndTime>`* of XML schema type *`xsd:dateTime`*
- `int flashSalePurchaseLimit` is a required element *`<flashSalePurchaseLimit>`* of XML schema type *`xsd:int`*
- `time_t *flashSaleStartTime` is an optional element *`<flashSaleStartTime>`* of XML schema type *`xsd:dateTime`*
- `int productBuyNum` is a required element *`<productBuyNum>`* of XML schema type *`xsd:int`*
- `float productDiscount` is a required element *`<productDiscount>`* of XML schema type *`xsd:float`*
- `float productFlashSalePrice` is a required element *`<productFlashSalePrice>`* of XML schema type *`xsd:float`*
- `int productId` is a required element *`<productId>`* of XML schema type *`xsd:int`*
- `std::string *productImage` is an optional element *`<productImage>`* of XML schema type *`xsd:string`*
- `std::string *productName` is an optional element *`<productName>`* of XML schema type *`xsd:string`*
- `int productNum` is a required element *`<productNum>`* of XML schema type *`xsd:int`*
- `int productPrice` is a required element *`<productPrice>`* of XML schema type *`xsd:int`*
- `int productShopId` is a required element *`<productShopId>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__product` are available:

- `ns2__product *soap_new_ns2__product(struct soap*)` managed allocation with default initialization
- `ns2__product *soap_new_ns2__product(struct soap*, int n)` managed allocation of array `ns2__product[n]`
- `ns2__product *soap_new_req_ns2__product(struct soap*, int flashSalePurchaseLimit, int productBuyNum, float productDiscount, float productFlashSalePrice, int productId, int productNum, int productPrice, int productShopId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__product *soap_new_set_ns2__product(struct soap*, time_t *discountEndTime, time_t *discountStartTime, time_t *flashSaleEndTime, int flashSalePurchaseLimit, time_t *flashSaleStartTime, int productBuyNum, float productDiscount, float productFlashSalePrice, int productId, std::string *productImage, std::string *productName, int productNum, int productPrice, int productShopId)` managed allocation with public members assigned the values of these parameters
- `void ns2__product::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__product(struct soap*, const ns2__product*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__product(struct soap*, const char *URL, const ns2__product*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__product(struct soap*, const char *URL, const ns2__product*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__product(struct soap*, const char *URL, const ns2__product*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__product(struct soap*, ns2__product*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__product(struct soap*, const char *URL, ns2__product*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__product(struct soap*, ns2__product*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__addProduct"></a>

### `ns2__addProduct`

This class is declared in [soap_head.h](soap_head.h) at line 169, is serialized as XML schema type *`ns2:addProduct`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__addProduct {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProduct
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProduct, default initialized and not managed by a soap context
        virtual ns2__addProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProduct); }
      public:
        /// Constructor with default initializations
        ns2__addProduct() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__addProduct() { }
        /// Friend allocator used by soap_new_ns2__addProduct(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProduct * SOAP_FMAC2 soap_instantiate_ns2__addProduct(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__product *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:product`*, where the type of this member is a pointer to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__addProduct` are available:

- `ns2__addProduct *soap_new_ns2__addProduct(struct soap*)` managed allocation with default initialization
- `ns2__addProduct *soap_new_ns2__addProduct(struct soap*, int n)` managed allocation of array `ns2__addProduct[n]`
- `ns2__addProduct *soap_new_req_ns2__addProduct(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__addProduct *soap_new_set_ns2__addProduct(struct soap*, ns2__product *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__addProduct::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__addProduct(struct soap*, const ns2__addProduct*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__addProduct(struct soap*, const char *URL, const ns2__addProduct*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__addProduct(struct soap*, const char *URL, const ns2__addProduct*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__addProduct(struct soap*, const char *URL, const ns2__addProduct*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__addProduct(struct soap*, ns2__addProduct*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__addProduct(struct soap*, const char *URL, ns2__addProduct*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__addProduct(struct soap*, ns2__addProduct*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__addProductResponse"></a>

### `ns2__addProductResponse`

This class is declared in [soap_head.h](soap_head.h) at line 171, is serialized as XML schema type *`ns2:addProductResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__addProductResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProductResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProductResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProductResponse, default initialized and not managed by a soap context
        virtual ns2__addProductResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProductResponse); }
      public:
        /// Constructor with default initializations
        ns2__addProductResponse() : soap() { }
        /// Destructor
        virtual ~ns2__addProductResponse() { }
        /// Friend allocator used by soap_new_ns2__addProductResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProductResponse * SOAP_FMAC2 soap_instantiate_ns2__addProductResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__addProductResponse` are available:

- `ns2__addProductResponse *soap_new_ns2__addProductResponse(struct soap*)` managed allocation with default initialization
- `ns2__addProductResponse *soap_new_ns2__addProductResponse(struct soap*, int n)` managed allocation of array `ns2__addProductResponse[n]`
- `ns2__addProductResponse *soap_new_req_ns2__addProductResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__addProductResponse *soap_new_set_ns2__addProductResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__addProductResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__addProductResponse(struct soap*, const ns2__addProductResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__addProductResponse(struct soap*, const char *URL, const ns2__addProductResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__addProductResponse(struct soap*, const char *URL, const ns2__addProductResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__addProductResponse(struct soap*, const char *URL, const ns2__addProductResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__addProductResponse(struct soap*, ns2__addProductResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__addProductResponse(struct soap*, const char *URL, ns2__addProductResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__addProductResponse(struct soap*, ns2__addProductResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteProductTypeByName"></a>

### `ns2__deleteProductTypeByName`

This class is declared in [soap_head.h](soap_head.h) at line 173, is serialized as XML schema type *`ns2:deleteProductTypeByName`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteProductTypeByName {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductTypeByName
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductTypeByName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductTypeByName, default initialized and not managed by a soap context
        virtual ns2__deleteProductTypeByName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductTypeByName); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductTypeByName() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__deleteProductTypeByName() { }
        /// Friend allocator used by soap_new_ns2__deleteProductTypeByName(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate_ns2__deleteProductTypeByName(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteProductTypeByName` are available:

- `ns2__deleteProductTypeByName *soap_new_ns2__deleteProductTypeByName(struct soap*)` managed allocation with default initialization
- `ns2__deleteProductTypeByName *soap_new_ns2__deleteProductTypeByName(struct soap*, int n)` managed allocation of array `ns2__deleteProductTypeByName[n]`
- `ns2__deleteProductTypeByName *soap_new_req_ns2__deleteProductTypeByName(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteProductTypeByName *soap_new_set_ns2__deleteProductTypeByName(struct soap*, std::string *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteProductTypeByName::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteProductTypeByName(struct soap*, const ns2__deleteProductTypeByName*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteProductTypeByName(struct soap*, const char *URL, const ns2__deleteProductTypeByName*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteProductTypeByName(struct soap*, const char *URL, const ns2__deleteProductTypeByName*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteProductTypeByName(struct soap*, const char *URL, const ns2__deleteProductTypeByName*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteProductTypeByName(struct soap*, ns2__deleteProductTypeByName*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteProductTypeByName(struct soap*, const char *URL, ns2__deleteProductTypeByName*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteProductTypeByName(struct soap*, ns2__deleteProductTypeByName*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteProductTypeByNameResponse"></a>

### `ns2__deleteProductTypeByNameResponse`

This class is declared in [soap_head.h](soap_head.h) at line 175, is serialized as XML schema type *`ns2:deleteProductTypeByNameResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteProductTypeByNameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductTypeByNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductTypeByNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductTypeByNameResponse, default initialized and not managed by a soap context
        virtual ns2__deleteProductTypeByNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductTypeByNameResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductTypeByNameResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteProductTypeByNameResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteProductTypeByNameResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductTypeByNameResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteProductTypeByNameResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteProductTypeByNameResponse` are available:

- `ns2__deleteProductTypeByNameResponse *soap_new_ns2__deleteProductTypeByNameResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteProductTypeByNameResponse *soap_new_ns2__deleteProductTypeByNameResponse(struct soap*, int n)` managed allocation of array `ns2__deleteProductTypeByNameResponse[n]`
- `ns2__deleteProductTypeByNameResponse *soap_new_req_ns2__deleteProductTypeByNameResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteProductTypeByNameResponse *soap_new_set_ns2__deleteProductTypeByNameResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteProductTypeByNameResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteProductTypeByNameResponse(struct soap*, const ns2__deleteProductTypeByNameResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteProductTypeByNameResponse(struct soap*, const char *URL, const ns2__deleteProductTypeByNameResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteProductTypeByNameResponse(struct soap*, const char *URL, const ns2__deleteProductTypeByNameResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteProductTypeByNameResponse(struct soap*, const char *URL, const ns2__deleteProductTypeByNameResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteProductTypeByNameResponse(struct soap*, ns2__deleteProductTypeByNameResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteProductTypeByNameResponse(struct soap*, const char *URL, ns2__deleteProductTypeByNameResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteProductTypeByNameResponse(struct soap*, ns2__deleteProductTypeByNameResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderList"></a>

### `ns2__getOrderList`

This class is declared in [soap_head.h](soap_head.h) at line 177, is serialized as XML schema type *`ns2:getOrderList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderList {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderList, default initialized and not managed by a soap context
        virtual ns2__getOrderList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderList); }
      public:
        /// Constructor with default initializations
        ns2__getOrderList() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderList() { }
        /// Friend allocator used by soap_new_ns2__getOrderList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderList * SOAP_FMAC2 soap_instantiate_ns2__getOrderList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__order *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderList` are available:

- `ns2__getOrderList *soap_new_ns2__getOrderList(struct soap*)` managed allocation with default initialization
- `ns2__getOrderList *soap_new_ns2__getOrderList(struct soap*, int n)` managed allocation of array `ns2__getOrderList[n]`
- `ns2__getOrderList *soap_new_req_ns2__getOrderList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderList *soap_new_set_ns2__getOrderList(struct soap*, ns2__order *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderList(struct soap*, const ns2__getOrderList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderList(struct soap*, const char *URL, const ns2__getOrderList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderList(struct soap*, const char *URL, const ns2__getOrderList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderList(struct soap*, const char *URL, const ns2__getOrderList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderList(struct soap*, ns2__getOrderList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderList(struct soap*, const char *URL, ns2__getOrderList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderList(struct soap*, ns2__getOrderList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__order"></a>

### `ns2__order`

This class is declared in [soap_head.h](soap_head.h) at line 179, is serialized as XML schema type *`ns2:order`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__order {
      public:
        /// Required element 'orderCheck' of XML schema type 'xsd:int'
        int orderCheck;
        /// Optional element 'orderClient' of XML schema type 'xsd:string'
        std::string *orderClient;
        /// Required element 'orderClientId' of XML schema type 'xsd:int'
        int orderClientId;
        /// Optional element 'orderCost' of XML schema type 'xsd:decimal'
        std::string *orderCost;
        /// Required element 'orderHide' of XML schema type 'xsd:int'
        int orderHide;
        /// Required element 'orderId' of XML schema type 'xsd:int'
        int orderId;
        /// Required element 'orderProductId' of XML schema type 'xsd:int'
        int orderProductId;
        /// Optional element 'orderProductName' of XML schema type 'xsd:string'
        std::string *orderProductName;
        /// Required element 'orderProductNum' of XML schema type 'xsd:int'
        int orderProductNum;
        /// Optional element 'orderProductStyle' of XML schema type 'xsd:string'
        std::string *orderProductStyle;
        /// Required element 'orderRefund' of XML schema type 'xsd:int'
        int orderRefund;
        /// Required element 'orderShip' of XML schema type 'xsd:int'
        int orderShip;
        /// Required element 'orderShopId' of XML schema type 'xsd:int'
        int orderShopId;
        /// Optional element 'orderTime' of XML schema type 'xsd:dateTime'
        time_t *orderTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__order
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__order; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__order, default initialized and not managed by a soap context
        virtual ns2__order *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__order); }
      public:
        /// Constructor with default initializations
        ns2__order() : orderCheck(), orderClient(), orderClientId(), orderCost(), orderHide(), orderId(), orderProductId(), orderProductName(), orderProductNum(), orderProductStyle(), orderRefund(), orderShip(), orderShopId(), orderTime(), soap() { }
        /// Destructor
        virtual ~ns2__order() { }
        /// Friend allocator used by soap_new_ns2__order(struct soap*, int)
        friend SOAP_FMAC1 ns2__order * SOAP_FMAC2 soap_instantiate_ns2__order(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int orderCheck` is a required element *`<orderCheck>`* of XML schema type *`xsd:int`*
- `std::string *orderClient` is an optional element *`<orderClient>`* of XML schema type *`xsd:string`*
- `int orderClientId` is a required element *`<orderClientId>`* of XML schema type *`xsd:int`*
- `std::string *orderCost` is an optional element *`<orderCost>`* of XML schema type *`xsd:decimal`*
- `int orderHide` is a required element *`<orderHide>`* of XML schema type *`xsd:int`*
- `int orderId` is a required element *`<orderId>`* of XML schema type *`xsd:int`*
- `int orderProductId` is a required element *`<orderProductId>`* of XML schema type *`xsd:int`*
- `std::string *orderProductName` is an optional element *`<orderProductName>`* of XML schema type *`xsd:string`*
- `int orderProductNum` is a required element *`<orderProductNum>`* of XML schema type *`xsd:int`*
- `std::string *orderProductStyle` is an optional element *`<orderProductStyle>`* of XML schema type *`xsd:string`*
- `int orderRefund` is a required element *`<orderRefund>`* of XML schema type *`xsd:int`*
- `int orderShip` is a required element *`<orderShip>`* of XML schema type *`xsd:int`*
- `int orderShopId` is a required element *`<orderShopId>`* of XML schema type *`xsd:int`*
- `time_t *orderTime` is an optional element *`<orderTime>`* of XML schema type *`xsd:dateTime`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__order` are available:

- `ns2__order *soap_new_ns2__order(struct soap*)` managed allocation with default initialization
- `ns2__order *soap_new_ns2__order(struct soap*, int n)` managed allocation of array `ns2__order[n]`
- `ns2__order *soap_new_req_ns2__order(struct soap*, int orderCheck, int orderClientId, int orderHide, int orderId, int orderProductId, int orderProductNum, int orderRefund, int orderShip, int orderShopId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__order *soap_new_set_ns2__order(struct soap*, int orderCheck, std::string *orderClient, int orderClientId, std::string *orderCost, int orderHide, int orderId, int orderProductId, std::string *orderProductName, int orderProductNum, std::string *orderProductStyle, int orderRefund, int orderShip, int orderShopId, time_t *orderTime)` managed allocation with public members assigned the values of these parameters
- `void ns2__order::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__order(struct soap*, const ns2__order*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__order(struct soap*, const char *URL, const ns2__order*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__order(struct soap*, const char *URL, const ns2__order*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__order(struct soap*, const char *URL, const ns2__order*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__order(struct soap*, ns2__order*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__order(struct soap*, const char *URL, ns2__order*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__order(struct soap*, ns2__order*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderListResponse"></a>

### `ns2__getOrderListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 181, is serialized as XML schema type *`ns2:getOrderListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__order *> return_` is an optional element *`<return>`* of XML schema type *`ns2:order`*, where the type of this member is a container of pointers to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderListResponse` are available:

- `ns2__getOrderListResponse *soap_new_ns2__getOrderListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getOrderListResponse *soap_new_ns2__getOrderListResponse(struct soap*, int n)` managed allocation of array `ns2__getOrderListResponse[n]`
- `ns2__getOrderListResponse *soap_new_req_ns2__getOrderListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderListResponse *soap_new_set_ns2__getOrderListResponse(struct soap*, const std::vector<ns2__order *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderListResponse(struct soap*, const ns2__getOrderListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderListResponse(struct soap*, const char *URL, const ns2__getOrderListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderListResponse(struct soap*, const char *URL, const ns2__getOrderListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderListResponse(struct soap*, const char *URL, const ns2__getOrderListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderListResponse(struct soap*, ns2__getOrderListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderListResponse(struct soap*, const char *URL, ns2__getOrderListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderListResponse(struct soap*, ns2__getOrderListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getShopByNameAndPwd"></a>

### `ns2__getShopByNameAndPwd`

This class is declared in [soap_head.h](soap_head.h) at line 183, is serialized as XML schema type *`ns2:getShopByNameAndPwd`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getShopByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__getShopByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__getShopByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getShopByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__getShopByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__getShopByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `std::string *arg1` is an optional element *`<arg1>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getShopByNameAndPwd` are available:

- `ns2__getShopByNameAndPwd *soap_new_ns2__getShopByNameAndPwd(struct soap*)` managed allocation with default initialization
- `ns2__getShopByNameAndPwd *soap_new_ns2__getShopByNameAndPwd(struct soap*, int n)` managed allocation of array `ns2__getShopByNameAndPwd[n]`
- `ns2__getShopByNameAndPwd *soap_new_req_ns2__getShopByNameAndPwd(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getShopByNameAndPwd *soap_new_set_ns2__getShopByNameAndPwd(struct soap*, std::string *arg0, std::string *arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__getShopByNameAndPwd::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getShopByNameAndPwd(struct soap*, const ns2__getShopByNameAndPwd*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getShopByNameAndPwd(struct soap*, const char *URL, const ns2__getShopByNameAndPwd*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getShopByNameAndPwd(struct soap*, const char *URL, const ns2__getShopByNameAndPwd*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getShopByNameAndPwd(struct soap*, const char *URL, const ns2__getShopByNameAndPwd*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getShopByNameAndPwd(struct soap*, ns2__getShopByNameAndPwd*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getShopByNameAndPwd(struct soap*, const char *URL, ns2__getShopByNameAndPwd*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getShopByNameAndPwd(struct soap*, ns2__getShopByNameAndPwd*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getShopByNameAndPwdResponse"></a>

### `ns2__getShopByNameAndPwdResponse`

This class is declared in [soap_head.h](soap_head.h) at line 185, is serialized as XML schema type *`ns2:getShopByNameAndPwdResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getShopByNameAndPwdResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:shop'
        ns2__shop *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__getShopByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__getShopByNameAndPwdResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getShopByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__getShopByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__shop *return_` is an optional element *`<return>`* of XML schema type *`ns2:shop`*, where the type of this member is a pointer to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getShopByNameAndPwdResponse` are available:

- `ns2__getShopByNameAndPwdResponse *soap_new_ns2__getShopByNameAndPwdResponse(struct soap*)` managed allocation with default initialization
- `ns2__getShopByNameAndPwdResponse *soap_new_ns2__getShopByNameAndPwdResponse(struct soap*, int n)` managed allocation of array `ns2__getShopByNameAndPwdResponse[n]`
- `ns2__getShopByNameAndPwdResponse *soap_new_req_ns2__getShopByNameAndPwdResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getShopByNameAndPwdResponse *soap_new_set_ns2__getShopByNameAndPwdResponse(struct soap*, ns2__shop *return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getShopByNameAndPwdResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getShopByNameAndPwdResponse(struct soap*, const ns2__getShopByNameAndPwdResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getShopByNameAndPwdResponse(struct soap*, const char *URL, const ns2__getShopByNameAndPwdResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getShopByNameAndPwdResponse(struct soap*, const char *URL, const ns2__getShopByNameAndPwdResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getShopByNameAndPwdResponse(struct soap*, const char *URL, const ns2__getShopByNameAndPwdResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getShopByNameAndPwdResponse(struct soap*, ns2__getShopByNameAndPwdResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getShopByNameAndPwdResponse(struct soap*, const char *URL, ns2__getShopByNameAndPwdResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getShopByNameAndPwdResponse(struct soap*, ns2__getShopByNameAndPwdResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__shop"></a>

### `ns2__shop`

This class is declared in [soap_head.h](soap_head.h) at line 187, is serialized as XML schema type *`ns2:shop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__shop {
      public:
        /// Optional element 'shopEmail' of XML schema type 'xsd:string'
        std::string *shopEmail;
        /// Required element 'shopId' of XML schema type 'xsd:int'
        int shopId;
        /// Optional element 'shopImage' of XML schema type 'xsd:string'
        std::string *shopImage;
        /// Optional element 'shopName' of XML schema type 'xsd:string'
        std::string *shopName;
        /// Optional element 'shopPhone' of XML schema type 'xsd:string'
        std::string *shopPhone;
        /// Optional element 'shopPwd' of XML schema type 'xsd:string'
        std::string *shopPwd;
        /// Optional element 'shopSignTime' of XML schema type 'xsd:dateTime'
        time_t *shopSignTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__shop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__shop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__shop, default initialized and not managed by a soap context
        virtual ns2__shop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__shop); }
      public:
        /// Constructor with default initializations
        ns2__shop() : shopEmail(), shopId(), shopImage(), shopName(), shopPhone(), shopPwd(), shopSignTime(), soap() { }
        /// Destructor
        virtual ~ns2__shop() { }
        /// Friend allocator used by soap_new_ns2__shop(struct soap*, int)
        friend SOAP_FMAC1 ns2__shop * SOAP_FMAC2 soap_instantiate_ns2__shop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *shopEmail` is an optional element *`<shopEmail>`* of XML schema type *`xsd:string`*
- `int shopId` is a required element *`<shopId>`* of XML schema type *`xsd:int`*
- `std::string *shopImage` is an optional element *`<shopImage>`* of XML schema type *`xsd:string`*
- `std::string *shopName` is an optional element *`<shopName>`* of XML schema type *`xsd:string`*
- `std::string *shopPhone` is an optional element *`<shopPhone>`* of XML schema type *`xsd:string`*
- `std::string *shopPwd` is an optional element *`<shopPwd>`* of XML schema type *`xsd:string`*
- `time_t *shopSignTime` is an optional element *`<shopSignTime>`* of XML schema type *`xsd:dateTime`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__shop` are available:

- `ns2__shop *soap_new_ns2__shop(struct soap*)` managed allocation with default initialization
- `ns2__shop *soap_new_ns2__shop(struct soap*, int n)` managed allocation of array `ns2__shop[n]`
- `ns2__shop *soap_new_req_ns2__shop(struct soap*, int shopId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__shop *soap_new_set_ns2__shop(struct soap*, std::string *shopEmail, int shopId, std::string *shopImage, std::string *shopName, std::string *shopPhone, std::string *shopPwd, time_t *shopSignTime)` managed allocation with public members assigned the values of these parameters
- `void ns2__shop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__shop(struct soap*, const ns2__shop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__shop(struct soap*, const char *URL, const ns2__shop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__shop(struct soap*, const char *URL, const ns2__shop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__shop(struct soap*, const char *URL, const ns2__shop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__shop(struct soap*, ns2__shop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__shop(struct soap*, const char *URL, ns2__shop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__shop(struct soap*, ns2__shop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateShop"></a>

### `ns2__updateShop`

This class is declared in [soap_head.h](soap_head.h) at line 189, is serialized as XML schema type *`ns2:updateShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateShop, default initialized and not managed by a soap context
        virtual ns2__updateShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateShop); }
      public:
        /// Constructor with default initializations
        ns2__updateShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateShop() { }
        /// Friend allocator used by soap_new_ns2__updateShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateShop * SOAP_FMAC2 soap_instantiate_ns2__updateShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__shop *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:shop`*, where the type of this member is a pointer to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateShop` are available:

- `ns2__updateShop *soap_new_ns2__updateShop(struct soap*)` managed allocation with default initialization
- `ns2__updateShop *soap_new_ns2__updateShop(struct soap*, int n)` managed allocation of array `ns2__updateShop[n]`
- `ns2__updateShop *soap_new_req_ns2__updateShop(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateShop *soap_new_set_ns2__updateShop(struct soap*, ns2__shop *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateShop(struct soap*, const ns2__updateShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateShop(struct soap*, const char *URL, const ns2__updateShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateShop(struct soap*, const char *URL, const ns2__updateShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateShop(struct soap*, const char *URL, const ns2__updateShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateShop(struct soap*, ns2__updateShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateShop(struct soap*, const char *URL, ns2__updateShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateShop(struct soap*, ns2__updateShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateShopResponse"></a>

### `ns2__updateShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 191, is serialized as XML schema type *`ns2:updateShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateShopResponse, default initialized and not managed by a soap context
        virtual ns2__updateShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateShopResponse() { }
        /// Friend allocator used by soap_new_ns2__updateShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateShopResponse * SOAP_FMAC2 soap_instantiate_ns2__updateShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateShopResponse` are available:

- `ns2__updateShopResponse *soap_new_ns2__updateShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__updateShopResponse *soap_new_ns2__updateShopResponse(struct soap*, int n)` managed allocation of array `ns2__updateShopResponse[n]`
- `ns2__updateShopResponse *soap_new_req_ns2__updateShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateShopResponse *soap_new_set_ns2__updateShopResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateShopResponse(struct soap*, const ns2__updateShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateShopResponse(struct soap*, const char *URL, const ns2__updateShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateShopResponse(struct soap*, const char *URL, const ns2__updateShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateShopResponse(struct soap*, const char *URL, const ns2__updateShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateShopResponse(struct soap*, ns2__updateShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateShopResponse(struct soap*, const char *URL, ns2__updateShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateShopResponse(struct soap*, ns2__updateShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductListByInfo"></a>

### `ns2__getProductListByInfo`

This class is declared in [soap_head.h](soap_head.h) at line 193, is serialized as XML schema type *`ns2:getProductListByInfo`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductListByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductListByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductListByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductListByInfo, default initialized and not managed by a soap context
        virtual ns2__getProductListByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductListByInfo); }
      public:
        /// Constructor with default initializations
        ns2__getProductListByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getProductListByInfo() { }
        /// Friend allocator used by soap_new_ns2__getProductListByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductListByInfo * SOAP_FMAC2 soap_instantiate_ns2__getProductListByInfo(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__product *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:product`*, where the type of this member is a pointer to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductListByInfo` are available:

- `ns2__getProductListByInfo *soap_new_ns2__getProductListByInfo(struct soap*)` managed allocation with default initialization
- `ns2__getProductListByInfo *soap_new_ns2__getProductListByInfo(struct soap*, int n)` managed allocation of array `ns2__getProductListByInfo[n]`
- `ns2__getProductListByInfo *soap_new_req_ns2__getProductListByInfo(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductListByInfo *soap_new_set_ns2__getProductListByInfo(struct soap*, ns2__product *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductListByInfo::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductListByInfo(struct soap*, const ns2__getProductListByInfo*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductListByInfo(struct soap*, const char *URL, const ns2__getProductListByInfo*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductListByInfo(struct soap*, const char *URL, const ns2__getProductListByInfo*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductListByInfo(struct soap*, const char *URL, const ns2__getProductListByInfo*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductListByInfo(struct soap*, ns2__getProductListByInfo*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductListByInfo(struct soap*, const char *URL, ns2__getProductListByInfo*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductListByInfo(struct soap*, ns2__getProductListByInfo*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductListByInfoResponse"></a>

### `ns2__getProductListByInfoResponse`

This class is declared in [soap_head.h](soap_head.h) at line 195, is serialized as XML schema type *`ns2:getProductListByInfoResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductListByInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        std::vector<ns2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductListByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductListByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductListByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__getProductListByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductListByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductListByInfoResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductListByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductListByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductListByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductListByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__product *> return_` is an optional element *`<return>`* of XML schema type *`ns2:product`*, where the type of this member is a container of pointers to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductListByInfoResponse` are available:

- `ns2__getProductListByInfoResponse *soap_new_ns2__getProductListByInfoResponse(struct soap*)` managed allocation with default initialization
- `ns2__getProductListByInfoResponse *soap_new_ns2__getProductListByInfoResponse(struct soap*, int n)` managed allocation of array `ns2__getProductListByInfoResponse[n]`
- `ns2__getProductListByInfoResponse *soap_new_req_ns2__getProductListByInfoResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductListByInfoResponse *soap_new_set_ns2__getProductListByInfoResponse(struct soap*, const std::vector<ns2__product *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductListByInfoResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductListByInfoResponse(struct soap*, const ns2__getProductListByInfoResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductListByInfoResponse(struct soap*, const char *URL, const ns2__getProductListByInfoResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductListByInfoResponse(struct soap*, const char *URL, const ns2__getProductListByInfoResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductListByInfoResponse(struct soap*, const char *URL, const ns2__getProductListByInfoResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductListByInfoResponse(struct soap*, ns2__getProductListByInfoResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductListByInfoResponse(struct soap*, const char *URL, ns2__getProductListByInfoResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductListByInfoResponse(struct soap*, ns2__getProductListByInfoResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getReadMessageFromShop"></a>

### `ns2__getReadMessageFromShop`

This class is declared in [soap_head.h](soap_head.h) at line 197, is serialized as XML schema type *`ns2:getReadMessageFromShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getReadMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__client *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:client`*, where the type of this member is a pointer to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getReadMessageFromShop` are available:

- `ns2__getReadMessageFromShop *soap_new_ns2__getReadMessageFromShop(struct soap*)` managed allocation with default initialization
- `ns2__getReadMessageFromShop *soap_new_ns2__getReadMessageFromShop(struct soap*, int n)` managed allocation of array `ns2__getReadMessageFromShop[n]`
- `ns2__getReadMessageFromShop *soap_new_req_ns2__getReadMessageFromShop(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getReadMessageFromShop *soap_new_set_ns2__getReadMessageFromShop(struct soap*, ns2__client *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getReadMessageFromShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getReadMessageFromShop(struct soap*, const ns2__getReadMessageFromShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getReadMessageFromShop(struct soap*, const char *URL, const ns2__getReadMessageFromShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getReadMessageFromShop(struct soap*, const char *URL, const ns2__getReadMessageFromShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getReadMessageFromShop(struct soap*, const char *URL, const ns2__getReadMessageFromShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getReadMessageFromShop(struct soap*, ns2__getReadMessageFromShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getReadMessageFromShop(struct soap*, const char *URL, ns2__getReadMessageFromShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getReadMessageFromShop(struct soap*, ns2__getReadMessageFromShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__client"></a>

### `ns2__client`

This class is declared in [soap_head.h](soap_head.h) at line 199, is serialized as XML schema type *`ns2:client`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__client {
      public:
        /// Required element 'clientBought' of XML schema type 'xsd:int'
        int clientBought;
        /// Optional element 'clientEmail' of XML schema type 'xsd:string'
        std::string *clientEmail;
        /// Required element 'clientId' of XML schema type 'xsd:int'
        int clientId;
        /// Optional element 'clientImage' of XML schema type 'xsd:string'
        std::string *clientImage;
        /// Optional element 'clientName' of XML schema type 'xsd:string'
        std::string *clientName;
        /// Optional element 'clientPhone' of XML schema type 'xsd:string'
        std::string *clientPhone;
        /// Optional element 'clientPwd' of XML schema type 'xsd:string'
        std::string *clientPwd;
        /// Optional element 'clientSignTime' of XML schema type 'xsd:dateTime'
        time_t *clientSignTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__client
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__client; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__client, default initialized and not managed by a soap context
        virtual ns2__client *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__client); }
      public:
        /// Constructor with default initializations
        ns2__client() : clientBought(), clientEmail(), clientId(), clientImage(), clientName(), clientPhone(), clientPwd(), clientSignTime(), soap() { }
        /// Destructor
        virtual ~ns2__client() { }
        /// Friend allocator used by soap_new_ns2__client(struct soap*, int)
        friend SOAP_FMAC1 ns2__client * SOAP_FMAC2 soap_instantiate_ns2__client(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int clientBought` is a required element *`<clientBought>`* of XML schema type *`xsd:int`*
- `std::string *clientEmail` is an optional element *`<clientEmail>`* of XML schema type *`xsd:string`*
- `int clientId` is a required element *`<clientId>`* of XML schema type *`xsd:int`*
- `std::string *clientImage` is an optional element *`<clientImage>`* of XML schema type *`xsd:string`*
- `std::string *clientName` is an optional element *`<clientName>`* of XML schema type *`xsd:string`*
- `std::string *clientPhone` is an optional element *`<clientPhone>`* of XML schema type *`xsd:string`*
- `std::string *clientPwd` is an optional element *`<clientPwd>`* of XML schema type *`xsd:string`*
- `time_t *clientSignTime` is an optional element *`<clientSignTime>`* of XML schema type *`xsd:dateTime`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__client` are available:

- `ns2__client *soap_new_ns2__client(struct soap*)` managed allocation with default initialization
- `ns2__client *soap_new_ns2__client(struct soap*, int n)` managed allocation of array `ns2__client[n]`
- `ns2__client *soap_new_req_ns2__client(struct soap*, int clientBought, int clientId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__client *soap_new_set_ns2__client(struct soap*, int clientBought, std::string *clientEmail, int clientId, std::string *clientImage, std::string *clientName, std::string *clientPhone, std::string *clientPwd, time_t *clientSignTime)` managed allocation with public members assigned the values of these parameters
- `void ns2__client::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__client(struct soap*, const ns2__client*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__client(struct soap*, const char *URL, const ns2__client*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__client(struct soap*, const char *URL, const ns2__client*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__client(struct soap*, const char *URL, const ns2__client*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__client(struct soap*, ns2__client*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__client(struct soap*, const char *URL, ns2__client*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__client(struct soap*, ns2__client*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getReadMessageFromShopResponse"></a>

### `ns2__getReadMessageFromShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 201, is serialized as XML schema type *`ns2:getReadMessageFromShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getReadMessageFromShopResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromShopResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__message *> return_` is an optional element *`<return>`* of XML schema type *`ns2:message`*, where the type of this member is a container of pointers to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getReadMessageFromShopResponse` are available:

- `ns2__getReadMessageFromShopResponse *soap_new_ns2__getReadMessageFromShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__getReadMessageFromShopResponse *soap_new_ns2__getReadMessageFromShopResponse(struct soap*, int n)` managed allocation of array `ns2__getReadMessageFromShopResponse[n]`
- `ns2__getReadMessageFromShopResponse *soap_new_req_ns2__getReadMessageFromShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getReadMessageFromShopResponse *soap_new_set_ns2__getReadMessageFromShopResponse(struct soap*, const std::vector<ns2__message *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getReadMessageFromShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getReadMessageFromShopResponse(struct soap*, const ns2__getReadMessageFromShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getReadMessageFromShopResponse(struct soap*, const char *URL, const ns2__getReadMessageFromShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getReadMessageFromShopResponse(struct soap*, const char *URL, const ns2__getReadMessageFromShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getReadMessageFromShopResponse(struct soap*, const char *URL, const ns2__getReadMessageFromShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getReadMessageFromShopResponse(struct soap*, ns2__getReadMessageFromShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getReadMessageFromShopResponse(struct soap*, const char *URL, ns2__getReadMessageFromShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getReadMessageFromShopResponse(struct soap*, ns2__getReadMessageFromShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__message"></a>

### `ns2__message`

This class is declared in [soap_head.h](soap_head.h) at line 203, is serialized as XML schema type *`ns2:message`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__message {
      public:
        /// Required element 'msgClientId' of XML schema type 'xsd:int'
        int msgClientId;
        /// Optional element 'msgClientName' of XML schema type 'xsd:string'
        std::string *msgClientName;
        /// Optional element 'msgContent' of XML schema type 'xsd:string'
        std::string *msgContent;
        /// Required element 'msgFrom' of XML schema type 'xsd:int'
        int msgFrom;
        /// Required element 'msgId' of XML schema type 'xsd:int'
        int msgId;
        /// Required element 'msgShopId' of XML schema type 'xsd:int'
        int msgShopId;
        /// Optional element 'msgShopName' of XML schema type 'xsd:string'
        std::string *msgShopName;
        /// Optional element 'msgTime' of XML schema type 'xsd:dateTime'
        time_t *msgTime;
        /// Required element 'readStatus' of XML schema type 'xsd:int'
        int readStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__message
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__message, default initialized and not managed by a soap context
        virtual ns2__message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__message); }
      public:
        /// Constructor with default initializations
        ns2__message() : msgClientId(), msgClientName(), msgContent(), msgFrom(), msgId(), msgShopId(), msgShopName(), msgTime(), readStatus(), soap() { }
        /// Destructor
        virtual ~ns2__message() { }
        /// Friend allocator used by soap_new_ns2__message(struct soap*, int)
        friend SOAP_FMAC1 ns2__message * SOAP_FMAC2 soap_instantiate_ns2__message(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int msgClientId` is a required element *`<msgClientId>`* of XML schema type *`xsd:int`*
- `std::string *msgClientName` is an optional element *`<msgClientName>`* of XML schema type *`xsd:string`*
- `std::string *msgContent` is an optional element *`<msgContent>`* of XML schema type *`xsd:string`*
- `int msgFrom` is a required element *`<msgFrom>`* of XML schema type *`xsd:int`*
- `int msgId` is a required element *`<msgId>`* of XML schema type *`xsd:int`*
- `int msgShopId` is a required element *`<msgShopId>`* of XML schema type *`xsd:int`*
- `std::string *msgShopName` is an optional element *`<msgShopName>`* of XML schema type *`xsd:string`*
- `time_t *msgTime` is an optional element *`<msgTime>`* of XML schema type *`xsd:dateTime`*
- `int readStatus` is a required element *`<readStatus>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__message` are available:

- `ns2__message *soap_new_ns2__message(struct soap*)` managed allocation with default initialization
- `ns2__message *soap_new_ns2__message(struct soap*, int n)` managed allocation of array `ns2__message[n]`
- `ns2__message *soap_new_req_ns2__message(struct soap*, int msgClientId, int msgFrom, int msgId, int msgShopId, int readStatus)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__message *soap_new_set_ns2__message(struct soap*, int msgClientId, std::string *msgClientName, std::string *msgContent, int msgFrom, int msgId, int msgShopId, std::string *msgShopName, time_t *msgTime, int readStatus)` managed allocation with public members assigned the values of these parameters
- `void ns2__message::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__message(struct soap*, const ns2__message*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__message(struct soap*, const char *URL, const ns2__message*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__message(struct soap*, const char *URL, const ns2__message*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__message(struct soap*, const char *URL, const ns2__message*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__message(struct soap*, ns2__message*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__message(struct soap*, const char *URL, ns2__message*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__message(struct soap*, ns2__message*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateClient"></a>

### `ns2__updateClient`

This class is declared in [soap_head.h](soap_head.h) at line 205, is serialized as XML schema type *`ns2:updateClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateClient, default initialized and not managed by a soap context
        virtual ns2__updateClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateClient); }
      public:
        /// Constructor with default initializations
        ns2__updateClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateClient() { }
        /// Friend allocator used by soap_new_ns2__updateClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateClient * SOAP_FMAC2 soap_instantiate_ns2__updateClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__client *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:client`*, where the type of this member is a pointer to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateClient` are available:

- `ns2__updateClient *soap_new_ns2__updateClient(struct soap*)` managed allocation with default initialization
- `ns2__updateClient *soap_new_ns2__updateClient(struct soap*, int n)` managed allocation of array `ns2__updateClient[n]`
- `ns2__updateClient *soap_new_req_ns2__updateClient(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateClient *soap_new_set_ns2__updateClient(struct soap*, ns2__client *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateClient(struct soap*, const ns2__updateClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateClient(struct soap*, const char *URL, const ns2__updateClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateClient(struct soap*, const char *URL, const ns2__updateClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateClient(struct soap*, const char *URL, const ns2__updateClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateClient(struct soap*, ns2__updateClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateClient(struct soap*, const char *URL, ns2__updateClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateClient(struct soap*, ns2__updateClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateClientResponse"></a>

### `ns2__updateClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 207, is serialized as XML schema type *`ns2:updateClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateClientResponse, default initialized and not managed by a soap context
        virtual ns2__updateClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateClientResponse() { }
        /// Friend allocator used by soap_new_ns2__updateClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateClientResponse * SOAP_FMAC2 soap_instantiate_ns2__updateClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateClientResponse` are available:

- `ns2__updateClientResponse *soap_new_ns2__updateClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__updateClientResponse *soap_new_ns2__updateClientResponse(struct soap*, int n)` managed allocation of array `ns2__updateClientResponse[n]`
- `ns2__updateClientResponse *soap_new_req_ns2__updateClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateClientResponse *soap_new_set_ns2__updateClientResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateClientResponse(struct soap*, const ns2__updateClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateClientResponse(struct soap*, const char *URL, const ns2__updateClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateClientResponse(struct soap*, const char *URL, const ns2__updateClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateClientResponse(struct soap*, const char *URL, const ns2__updateClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateClientResponse(struct soap*, ns2__updateClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateClientResponse(struct soap*, const char *URL, ns2__updateClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateClientResponse(struct soap*, ns2__updateClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteProductByInfo"></a>

### `ns2__deleteProductByInfo`

This class is declared in [soap_head.h](soap_head.h) at line 209, is serialized as XML schema type *`ns2:deleteProductByInfo`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteProductByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductByInfo, default initialized and not managed by a soap context
        virtual ns2__deleteProductByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductByInfo); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__deleteProductByInfo() { }
        /// Friend allocator used by soap_new_ns2__deleteProductByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductByInfo * SOAP_FMAC2 soap_instantiate_ns2__deleteProductByInfo(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__product *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:product`*, where the type of this member is a pointer to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteProductByInfo` are available:

- `ns2__deleteProductByInfo *soap_new_ns2__deleteProductByInfo(struct soap*)` managed allocation with default initialization
- `ns2__deleteProductByInfo *soap_new_ns2__deleteProductByInfo(struct soap*, int n)` managed allocation of array `ns2__deleteProductByInfo[n]`
- `ns2__deleteProductByInfo *soap_new_req_ns2__deleteProductByInfo(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteProductByInfo *soap_new_set_ns2__deleteProductByInfo(struct soap*, ns2__product *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteProductByInfo::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteProductByInfo(struct soap*, const ns2__deleteProductByInfo*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteProductByInfo(struct soap*, const char *URL, const ns2__deleteProductByInfo*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteProductByInfo(struct soap*, const char *URL, const ns2__deleteProductByInfo*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteProductByInfo(struct soap*, const char *URL, const ns2__deleteProductByInfo*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteProductByInfo(struct soap*, ns2__deleteProductByInfo*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteProductByInfo(struct soap*, const char *URL, ns2__deleteProductByInfo*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteProductByInfo(struct soap*, ns2__deleteProductByInfo*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteProductByInfoResponse"></a>

### `ns2__deleteProductByInfoResponse`

This class is declared in [soap_head.h](soap_head.h) at line 211, is serialized as XML schema type *`ns2:deleteProductByInfoResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteProductByInfoResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__deleteProductByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductByInfoResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteProductByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteProductByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteProductByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteProductByInfoResponse` are available:

- `ns2__deleteProductByInfoResponse *soap_new_ns2__deleteProductByInfoResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteProductByInfoResponse *soap_new_ns2__deleteProductByInfoResponse(struct soap*, int n)` managed allocation of array `ns2__deleteProductByInfoResponse[n]`
- `ns2__deleteProductByInfoResponse *soap_new_req_ns2__deleteProductByInfoResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteProductByInfoResponse *soap_new_set_ns2__deleteProductByInfoResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteProductByInfoResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteProductByInfoResponse(struct soap*, const ns2__deleteProductByInfoResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteProductByInfoResponse(struct soap*, const char *URL, const ns2__deleteProductByInfoResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteProductByInfoResponse(struct soap*, const char *URL, const ns2__deleteProductByInfoResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteProductByInfoResponse(struct soap*, const char *URL, const ns2__deleteProductByInfoResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteProductByInfoResponse(struct soap*, ns2__deleteProductByInfoResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteProductByInfoResponse(struct soap*, const char *URL, ns2__deleteProductByInfoResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteProductByInfoResponse(struct soap*, ns2__deleteProductByInfoResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteClientByNameAndPwd"></a>

### `ns2__deleteClientByNameAndPwd`

This class is declared in [soap_head.h](soap_head.h) at line 213, is serialized as XML schema type *`ns2:deleteClientByNameAndPwd`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteClientByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteClientByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteClientByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteClientByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__deleteClientByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteClientByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__deleteClientByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteClientByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__deleteClientByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__deleteClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `std::string *arg1` is an optional element *`<arg1>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteClientByNameAndPwd` are available:

- `ns2__deleteClientByNameAndPwd *soap_new_ns2__deleteClientByNameAndPwd(struct soap*)` managed allocation with default initialization
- `ns2__deleteClientByNameAndPwd *soap_new_ns2__deleteClientByNameAndPwd(struct soap*, int n)` managed allocation of array `ns2__deleteClientByNameAndPwd[n]`
- `ns2__deleteClientByNameAndPwd *soap_new_req_ns2__deleteClientByNameAndPwd(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteClientByNameAndPwd *soap_new_set_ns2__deleteClientByNameAndPwd(struct soap*, std::string *arg0, std::string *arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteClientByNameAndPwd::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteClientByNameAndPwd(struct soap*, const ns2__deleteClientByNameAndPwd*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteClientByNameAndPwd(struct soap*, const char *URL, const ns2__deleteClientByNameAndPwd*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteClientByNameAndPwd(struct soap*, const char *URL, const ns2__deleteClientByNameAndPwd*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteClientByNameAndPwd(struct soap*, const char *URL, const ns2__deleteClientByNameAndPwd*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteClientByNameAndPwd(struct soap*, ns2__deleteClientByNameAndPwd*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteClientByNameAndPwd(struct soap*, const char *URL, ns2__deleteClientByNameAndPwd*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteClientByNameAndPwd(struct soap*, ns2__deleteClientByNameAndPwd*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteClientByNameAndPwdResponse"></a>

### `ns2__deleteClientByNameAndPwdResponse`

This class is declared in [soap_head.h](soap_head.h) at line 215, is serialized as XML schema type *`ns2:deleteClientByNameAndPwdResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteClientByNameAndPwdResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteClientByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__deleteClientByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteClientByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteClientByNameAndPwdResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteClientByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteClientByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteClientByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteClientByNameAndPwdResponse` are available:

- `ns2__deleteClientByNameAndPwdResponse *soap_new_ns2__deleteClientByNameAndPwdResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteClientByNameAndPwdResponse *soap_new_ns2__deleteClientByNameAndPwdResponse(struct soap*, int n)` managed allocation of array `ns2__deleteClientByNameAndPwdResponse[n]`
- `ns2__deleteClientByNameAndPwdResponse *soap_new_req_ns2__deleteClientByNameAndPwdResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteClientByNameAndPwdResponse *soap_new_set_ns2__deleteClientByNameAndPwdResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteClientByNameAndPwdResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteClientByNameAndPwdResponse(struct soap*, const ns2__deleteClientByNameAndPwdResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteClientByNameAndPwdResponse(struct soap*, const char *URL, const ns2__deleteClientByNameAndPwdResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteClientByNameAndPwdResponse(struct soap*, const char *URL, const ns2__deleteClientByNameAndPwdResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteClientByNameAndPwdResponse(struct soap*, const char *URL, const ns2__deleteClientByNameAndPwdResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteClientByNameAndPwdResponse(struct soap*, ns2__deleteClientByNameAndPwdResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteClientByNameAndPwdResponse(struct soap*, const char *URL, ns2__deleteClientByNameAndPwdResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteClientByNameAndPwdResponse(struct soap*, ns2__deleteClientByNameAndPwdResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__InsertShop"></a>

### `ns2__InsertShop`

This class is declared in [soap_head.h](soap_head.h) at line 217, is serialized as XML schema type *`ns2:InsertShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__InsertShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertShop, default initialized and not managed by a soap context
        virtual ns2__InsertShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertShop); }
      public:
        /// Constructor with default initializations
        ns2__InsertShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__InsertShop() { }
        /// Friend allocator used by soap_new_ns2__InsertShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertShop * SOAP_FMAC2 soap_instantiate_ns2__InsertShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__shop *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:shop`*, where the type of this member is a pointer to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__InsertShop` are available:

- `ns2__InsertShop *soap_new_ns2__InsertShop(struct soap*)` managed allocation with default initialization
- `ns2__InsertShop *soap_new_ns2__InsertShop(struct soap*, int n)` managed allocation of array `ns2__InsertShop[n]`
- `ns2__InsertShop *soap_new_req_ns2__InsertShop(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__InsertShop *soap_new_set_ns2__InsertShop(struct soap*, ns2__shop *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__InsertShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__InsertShop(struct soap*, const ns2__InsertShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__InsertShop(struct soap*, const char *URL, const ns2__InsertShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__InsertShop(struct soap*, const char *URL, const ns2__InsertShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__InsertShop(struct soap*, const char *URL, const ns2__InsertShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__InsertShop(struct soap*, ns2__InsertShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__InsertShop(struct soap*, const char *URL, ns2__InsertShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__InsertShop(struct soap*, ns2__InsertShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__InsertShopResponse"></a>

### `ns2__InsertShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 219, is serialized as XML schema type *`ns2:InsertShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__InsertShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertShopResponse, default initialized and not managed by a soap context
        virtual ns2__InsertShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__InsertShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__InsertShopResponse() { }
        /// Friend allocator used by soap_new_ns2__InsertShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertShopResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__InsertShopResponse` are available:

- `ns2__InsertShopResponse *soap_new_ns2__InsertShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__InsertShopResponse *soap_new_ns2__InsertShopResponse(struct soap*, int n)` managed allocation of array `ns2__InsertShopResponse[n]`
- `ns2__InsertShopResponse *soap_new_req_ns2__InsertShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__InsertShopResponse *soap_new_set_ns2__InsertShopResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__InsertShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__InsertShopResponse(struct soap*, const ns2__InsertShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__InsertShopResponse(struct soap*, const char *URL, const ns2__InsertShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__InsertShopResponse(struct soap*, const char *URL, const ns2__InsertShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__InsertShopResponse(struct soap*, const char *URL, const ns2__InsertShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__InsertShopResponse(struct soap*, ns2__InsertShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__InsertShopResponse(struct soap*, const char *URL, ns2__InsertShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__InsertShopResponse(struct soap*, ns2__InsertShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateMessageFromShop"></a>

### `ns2__updateMessageFromShop`

This class is declared in [soap_head.h](soap_head.h) at line 221, is serialized as XML schema type *`ns2:updateMessageFromShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromShop() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__message *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:message`*, where the type of this member is a pointer to <code><a href="#ns2__message"> ns2__message </a></code>
- `int arg1` is a required element *`<arg1>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateMessageFromShop` are available:

- `ns2__updateMessageFromShop *soap_new_ns2__updateMessageFromShop(struct soap*)` managed allocation with default initialization
- `ns2__updateMessageFromShop *soap_new_ns2__updateMessageFromShop(struct soap*, int n)` managed allocation of array `ns2__updateMessageFromShop[n]`
- `ns2__updateMessageFromShop *soap_new_req_ns2__updateMessageFromShop(struct soap*, int arg1)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateMessageFromShop *soap_new_set_ns2__updateMessageFromShop(struct soap*, ns2__message *arg0, int arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateMessageFromShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateMessageFromShop(struct soap*, const ns2__updateMessageFromShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateMessageFromShop(struct soap*, const char *URL, const ns2__updateMessageFromShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateMessageFromShop(struct soap*, const char *URL, const ns2__updateMessageFromShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateMessageFromShop(struct soap*, const char *URL, const ns2__updateMessageFromShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateMessageFromShop(struct soap*, ns2__updateMessageFromShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateMessageFromShop(struct soap*, const char *URL, ns2__updateMessageFromShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateMessageFromShop(struct soap*, ns2__updateMessageFromShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateMessageFromShopResponse"></a>

### `ns2__updateMessageFromShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 223, is serialized as XML schema type *`ns2:updateMessageFromShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateMessageFromShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateMessageFromShopResponse` are available:

- `ns2__updateMessageFromShopResponse *soap_new_ns2__updateMessageFromShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__updateMessageFromShopResponse *soap_new_ns2__updateMessageFromShopResponse(struct soap*, int n)` managed allocation of array `ns2__updateMessageFromShopResponse[n]`
- `ns2__updateMessageFromShopResponse *soap_new_req_ns2__updateMessageFromShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateMessageFromShopResponse *soap_new_set_ns2__updateMessageFromShopResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateMessageFromShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateMessageFromShopResponse(struct soap*, const ns2__updateMessageFromShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateMessageFromShopResponse(struct soap*, const char *URL, const ns2__updateMessageFromShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateMessageFromShopResponse(struct soap*, const char *URL, const ns2__updateMessageFromShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateMessageFromShopResponse(struct soap*, const char *URL, const ns2__updateMessageFromShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateMessageFromShopResponse(struct soap*, ns2__updateMessageFromShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateMessageFromShopResponse(struct soap*, const char *URL, ns2__updateMessageFromShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateMessageFromShopResponse(struct soap*, ns2__updateMessageFromShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductTypeByProName"></a>

### `ns2__getProductTypeByProName`

This class is declared in [soap_head.h](soap_head.h) at line 225, is serialized as XML schema type *`ns2:getProductTypeByProName`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductTypeByProName {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductTypeByProName
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductTypeByProName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductTypeByProName, default initialized and not managed by a soap context
        virtual ns2__getProductTypeByProName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductTypeByProName); }
      public:
        /// Constructor with default initializations
        ns2__getProductTypeByProName() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getProductTypeByProName() { }
        /// Friend allocator used by soap_new_ns2__getProductTypeByProName(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductTypeByProName * SOAP_FMAC2 soap_instantiate_ns2__getProductTypeByProName(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductTypeByProName` are available:

- `ns2__getProductTypeByProName *soap_new_ns2__getProductTypeByProName(struct soap*)` managed allocation with default initialization
- `ns2__getProductTypeByProName *soap_new_ns2__getProductTypeByProName(struct soap*, int n)` managed allocation of array `ns2__getProductTypeByProName[n]`
- `ns2__getProductTypeByProName *soap_new_req_ns2__getProductTypeByProName(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductTypeByProName *soap_new_set_ns2__getProductTypeByProName(struct soap*, std::string *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductTypeByProName::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductTypeByProName(struct soap*, const ns2__getProductTypeByProName*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductTypeByProName(struct soap*, const char *URL, const ns2__getProductTypeByProName*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductTypeByProName(struct soap*, const char *URL, const ns2__getProductTypeByProName*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductTypeByProName(struct soap*, const char *URL, const ns2__getProductTypeByProName*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductTypeByProName(struct soap*, ns2__getProductTypeByProName*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductTypeByProName(struct soap*, const char *URL, ns2__getProductTypeByProName*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductTypeByProName(struct soap*, ns2__getProductTypeByProName*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductTypeByProNameResponse"></a>

### `ns2__getProductTypeByProNameResponse`

This class is declared in [soap_head.h](soap_head.h) at line 227, is serialized as XML schema type *`ns2:getProductTypeByProNameResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductTypeByProNameResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:productType'
        std::vector<ns2__productType *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductTypeByProNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductTypeByProNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductTypeByProNameResponse, default initialized and not managed by a soap context
        virtual ns2__getProductTypeByProNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductTypeByProNameResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductTypeByProNameResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductTypeByProNameResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductTypeByProNameResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductTypeByProNameResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductTypeByProNameResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__productType *> return_` is an optional element *`<return>`* of XML schema type *`ns2:productType`*, where the type of this member is a container of pointers to <code><a href="#ns2__productType"> ns2__productType </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductTypeByProNameResponse` are available:

- `ns2__getProductTypeByProNameResponse *soap_new_ns2__getProductTypeByProNameResponse(struct soap*)` managed allocation with default initialization
- `ns2__getProductTypeByProNameResponse *soap_new_ns2__getProductTypeByProNameResponse(struct soap*, int n)` managed allocation of array `ns2__getProductTypeByProNameResponse[n]`
- `ns2__getProductTypeByProNameResponse *soap_new_req_ns2__getProductTypeByProNameResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductTypeByProNameResponse *soap_new_set_ns2__getProductTypeByProNameResponse(struct soap*, const std::vector<ns2__productType *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductTypeByProNameResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductTypeByProNameResponse(struct soap*, const ns2__getProductTypeByProNameResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductTypeByProNameResponse(struct soap*, const char *URL, const ns2__getProductTypeByProNameResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductTypeByProNameResponse(struct soap*, const char *URL, const ns2__getProductTypeByProNameResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductTypeByProNameResponse(struct soap*, const char *URL, const ns2__getProductTypeByProNameResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductTypeByProNameResponse(struct soap*, ns2__getProductTypeByProNameResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductTypeByProNameResponse(struct soap*, const char *URL, ns2__getProductTypeByProNameResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductTypeByProNameResponse(struct soap*, ns2__getProductTypeByProNameResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__productType"></a>

### `ns2__productType`

This class is declared in [soap_head.h](soap_head.h) at line 229, is serialized as XML schema type *`ns2:productType`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__productType {
      public:
        /// Required element 'typeId' of XML schema type 'xsd:int'
        int typeId;
        /// Optional element 'typeName' of XML schema type 'xsd:string'
        std::string *typeName;
        /// Optional element 'typeProduct' of XML schema type 'xsd:string'
        std::string *typeProduct;
        /// Required element 'typeProductId' of XML schema type 'xsd:int'
        int typeProductId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__productType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__productType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__productType, default initialized and not managed by a soap context
        virtual ns2__productType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__productType); }
      public:
        /// Constructor with default initializations
        ns2__productType() : typeId(), typeName(), typeProduct(), typeProductId(), soap() { }
        /// Destructor
        virtual ~ns2__productType() { }
        /// Friend allocator used by soap_new_ns2__productType(struct soap*, int)
        friend SOAP_FMAC1 ns2__productType * SOAP_FMAC2 soap_instantiate_ns2__productType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int typeId` is a required element *`<typeId>`* of XML schema type *`xsd:int`*
- `std::string *typeName` is an optional element *`<typeName>`* of XML schema type *`xsd:string`*
- `std::string *typeProduct` is an optional element *`<typeProduct>`* of XML schema type *`xsd:string`*
- `int typeProductId` is a required element *`<typeProductId>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__productType` are available:

- `ns2__productType *soap_new_ns2__productType(struct soap*)` managed allocation with default initialization
- `ns2__productType *soap_new_ns2__productType(struct soap*, int n)` managed allocation of array `ns2__productType[n]`
- `ns2__productType *soap_new_req_ns2__productType(struct soap*, int typeId, int typeProductId)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__productType *soap_new_set_ns2__productType(struct soap*, int typeId, std::string *typeName, std::string *typeProduct, int typeProductId)` managed allocation with public members assigned the values of these parameters
- `void ns2__productType::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__productType(struct soap*, const ns2__productType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__productType(struct soap*, const char *URL, const ns2__productType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__productType(struct soap*, const char *URL, const ns2__productType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__productType(struct soap*, const char *URL, const ns2__productType*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__productType(struct soap*, ns2__productType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__productType(struct soap*, const char *URL, ns2__productType*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__productType(struct soap*, ns2__productType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getClientList"></a>

### `ns2__getClientList`

This class is declared in [soap_head.h](soap_head.h) at line 231, is serialized as XML schema type *`ns2:getClientList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getClientList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientList, default initialized and not managed by a soap context
        virtual ns2__getClientList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientList); }
      public:
        /// Constructor with default initializations
        ns2__getClientList() : soap() { }
        /// Destructor
        virtual ~ns2__getClientList() { }
        /// Friend allocator used by soap_new_ns2__getClientList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientList * SOAP_FMAC2 soap_instantiate_ns2__getClientList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__getClientList` are available:

- `ns2__getClientList *soap_new_ns2__getClientList(struct soap*)` managed allocation with default initialization
- `ns2__getClientList *soap_new_ns2__getClientList(struct soap*, int n)` managed allocation of array `ns2__getClientList[n]`
- `ns2__getClientList *soap_new_req_ns2__getClientList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getClientList *soap_new_set_ns2__getClientList(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__getClientList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getClientList(struct soap*, const ns2__getClientList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getClientList(struct soap*, const char *URL, const ns2__getClientList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getClientList(struct soap*, const char *URL, const ns2__getClientList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getClientList(struct soap*, const char *URL, const ns2__getClientList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getClientList(struct soap*, ns2__getClientList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getClientList(struct soap*, const char *URL, ns2__getClientList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getClientList(struct soap*, ns2__getClientList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getClientListResponse"></a>

### `ns2__getClientListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 233, is serialized as XML schema type *`ns2:getClientListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getClientListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:client'
        std::vector<ns2__client *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientListResponse, default initialized and not managed by a soap context
        virtual ns2__getClientListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getClientListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getClientListResponse() { }
        /// Friend allocator used by soap_new_ns2__getClientListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientListResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__client *> return_` is an optional element *`<return>`* of XML schema type *`ns2:client`*, where the type of this member is a container of pointers to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getClientListResponse` are available:

- `ns2__getClientListResponse *soap_new_ns2__getClientListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getClientListResponse *soap_new_ns2__getClientListResponse(struct soap*, int n)` managed allocation of array `ns2__getClientListResponse[n]`
- `ns2__getClientListResponse *soap_new_req_ns2__getClientListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getClientListResponse *soap_new_set_ns2__getClientListResponse(struct soap*, const std::vector<ns2__client *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getClientListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getClientListResponse(struct soap*, const ns2__getClientListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getClientListResponse(struct soap*, const char *URL, const ns2__getClientListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getClientListResponse(struct soap*, const char *URL, const ns2__getClientListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getClientListResponse(struct soap*, const char *URL, const ns2__getClientListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getClientListResponse(struct soap*, ns2__getClientListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getClientListResponse(struct soap*, const char *URL, ns2__getClientListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getClientListResponse(struct soap*, ns2__getClientListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__purchaseProduct"></a>

### `ns2__purchaseProduct`

This class is declared in [soap_head.h](soap_head.h) at line 235, is serialized as XML schema type *`ns2:purchaseProduct`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__purchaseProduct {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__purchaseProduct
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__purchaseProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__purchaseProduct, default initialized and not managed by a soap context
        virtual ns2__purchaseProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__purchaseProduct); }
      public:
        /// Constructor with default initializations
        ns2__purchaseProduct() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__purchaseProduct() { }
        /// Friend allocator used by soap_new_ns2__purchaseProduct(struct soap*, int)
        friend SOAP_FMAC1 ns2__purchaseProduct * SOAP_FMAC2 soap_instantiate_ns2__purchaseProduct(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__order *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__purchaseProduct` are available:

- `ns2__purchaseProduct *soap_new_ns2__purchaseProduct(struct soap*)` managed allocation with default initialization
- `ns2__purchaseProduct *soap_new_ns2__purchaseProduct(struct soap*, int n)` managed allocation of array `ns2__purchaseProduct[n]`
- `ns2__purchaseProduct *soap_new_req_ns2__purchaseProduct(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__purchaseProduct *soap_new_set_ns2__purchaseProduct(struct soap*, ns2__order *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__purchaseProduct::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__purchaseProduct(struct soap*, const ns2__purchaseProduct*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__purchaseProduct(struct soap*, const char *URL, const ns2__purchaseProduct*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__purchaseProduct(struct soap*, const char *URL, const ns2__purchaseProduct*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__purchaseProduct(struct soap*, const char *URL, const ns2__purchaseProduct*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__purchaseProduct(struct soap*, ns2__purchaseProduct*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__purchaseProduct(struct soap*, const char *URL, ns2__purchaseProduct*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__purchaseProduct(struct soap*, ns2__purchaseProduct*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__purchaseProductResponse"></a>

### `ns2__purchaseProductResponse`

This class is declared in [soap_head.h](soap_head.h) at line 237, is serialized as XML schema type *`ns2:purchaseProductResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__purchaseProductResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__purchaseProductResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__purchaseProductResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__purchaseProductResponse, default initialized and not managed by a soap context
        virtual ns2__purchaseProductResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__purchaseProductResponse); }
      public:
        /// Constructor with default initializations
        ns2__purchaseProductResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__purchaseProductResponse() { }
        /// Friend allocator used by soap_new_ns2__purchaseProductResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__purchaseProductResponse * SOAP_FMAC2 soap_instantiate_ns2__purchaseProductResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *return_` is an optional element *`<return>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__purchaseProductResponse` are available:

- `ns2__purchaseProductResponse *soap_new_ns2__purchaseProductResponse(struct soap*)` managed allocation with default initialization
- `ns2__purchaseProductResponse *soap_new_ns2__purchaseProductResponse(struct soap*, int n)` managed allocation of array `ns2__purchaseProductResponse[n]`
- `ns2__purchaseProductResponse *soap_new_req_ns2__purchaseProductResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__purchaseProductResponse *soap_new_set_ns2__purchaseProductResponse(struct soap*, std::string *return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__purchaseProductResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__purchaseProductResponse(struct soap*, const ns2__purchaseProductResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__purchaseProductResponse(struct soap*, const char *URL, const ns2__purchaseProductResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__purchaseProductResponse(struct soap*, const char *URL, const ns2__purchaseProductResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__purchaseProductResponse(struct soap*, const char *URL, const ns2__purchaseProductResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__purchaseProductResponse(struct soap*, ns2__purchaseProductResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__purchaseProductResponse(struct soap*, const char *URL, ns2__purchaseProductResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__purchaseProductResponse(struct soap*, ns2__purchaseProductResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateMessageFromClient"></a>

### `ns2__updateMessageFromClient`

This class is declared in [soap_head.h](soap_head.h) at line 239, is serialized as XML schema type *`ns2:updateMessageFromClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromClient() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__message *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:message`*, where the type of this member is a pointer to <code><a href="#ns2__message"> ns2__message </a></code>
- `int arg1` is a required element *`<arg1>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateMessageFromClient` are available:

- `ns2__updateMessageFromClient *soap_new_ns2__updateMessageFromClient(struct soap*)` managed allocation with default initialization
- `ns2__updateMessageFromClient *soap_new_ns2__updateMessageFromClient(struct soap*, int n)` managed allocation of array `ns2__updateMessageFromClient[n]`
- `ns2__updateMessageFromClient *soap_new_req_ns2__updateMessageFromClient(struct soap*, int arg1)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateMessageFromClient *soap_new_set_ns2__updateMessageFromClient(struct soap*, ns2__message *arg0, int arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateMessageFromClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateMessageFromClient(struct soap*, const ns2__updateMessageFromClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateMessageFromClient(struct soap*, const char *URL, const ns2__updateMessageFromClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateMessageFromClient(struct soap*, const char *URL, const ns2__updateMessageFromClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateMessageFromClient(struct soap*, const char *URL, const ns2__updateMessageFromClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateMessageFromClient(struct soap*, ns2__updateMessageFromClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateMessageFromClient(struct soap*, const char *URL, ns2__updateMessageFromClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateMessageFromClient(struct soap*, ns2__updateMessageFromClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateMessageFromClientResponse"></a>

### `ns2__updateMessageFromClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 241, is serialized as XML schema type *`ns2:updateMessageFromClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateMessageFromClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateMessageFromClientResponse` are available:

- `ns2__updateMessageFromClientResponse *soap_new_ns2__updateMessageFromClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__updateMessageFromClientResponse *soap_new_ns2__updateMessageFromClientResponse(struct soap*, int n)` managed allocation of array `ns2__updateMessageFromClientResponse[n]`
- `ns2__updateMessageFromClientResponse *soap_new_req_ns2__updateMessageFromClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateMessageFromClientResponse *soap_new_set_ns2__updateMessageFromClientResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateMessageFromClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateMessageFromClientResponse(struct soap*, const ns2__updateMessageFromClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateMessageFromClientResponse(struct soap*, const char *URL, const ns2__updateMessageFromClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateMessageFromClientResponse(struct soap*, const char *URL, const ns2__updateMessageFromClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateMessageFromClientResponse(struct soap*, const char *URL, const ns2__updateMessageFromClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateMessageFromClientResponse(struct soap*, ns2__updateMessageFromClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateMessageFromClientResponse(struct soap*, const char *URL, ns2__updateMessageFromClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateMessageFromClientResponse(struct soap*, ns2__updateMessageFromClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getUnreadMessageFromClient"></a>

### `ns2__getUnreadMessageFromClient`

This class is declared in [soap_head.h](soap_head.h) at line 243, is serialized as XML schema type *`ns2:getUnreadMessageFromClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getUnreadMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__shop *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:shop`*, where the type of this member is a pointer to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getUnreadMessageFromClient` are available:

- `ns2__getUnreadMessageFromClient *soap_new_ns2__getUnreadMessageFromClient(struct soap*)` managed allocation with default initialization
- `ns2__getUnreadMessageFromClient *soap_new_ns2__getUnreadMessageFromClient(struct soap*, int n)` managed allocation of array `ns2__getUnreadMessageFromClient[n]`
- `ns2__getUnreadMessageFromClient *soap_new_req_ns2__getUnreadMessageFromClient(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getUnreadMessageFromClient *soap_new_set_ns2__getUnreadMessageFromClient(struct soap*, ns2__shop *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getUnreadMessageFromClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getUnreadMessageFromClient(struct soap*, const ns2__getUnreadMessageFromClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getUnreadMessageFromClient(struct soap*, const char *URL, const ns2__getUnreadMessageFromClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getUnreadMessageFromClient(struct soap*, const char *URL, const ns2__getUnreadMessageFromClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getUnreadMessageFromClient(struct soap*, const char *URL, const ns2__getUnreadMessageFromClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getUnreadMessageFromClient(struct soap*, ns2__getUnreadMessageFromClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getUnreadMessageFromClient(struct soap*, const char *URL, ns2__getUnreadMessageFromClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getUnreadMessageFromClient(struct soap*, ns2__getUnreadMessageFromClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getUnreadMessageFromClientResponse"></a>

### `ns2__getUnreadMessageFromClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 245, is serialized as XML schema type *`ns2:getUnreadMessageFromClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getUnreadMessageFromClientResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromClientResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__message *> return_` is an optional element *`<return>`* of XML schema type *`ns2:message`*, where the type of this member is a container of pointers to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getUnreadMessageFromClientResponse` are available:

- `ns2__getUnreadMessageFromClientResponse *soap_new_ns2__getUnreadMessageFromClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__getUnreadMessageFromClientResponse *soap_new_ns2__getUnreadMessageFromClientResponse(struct soap*, int n)` managed allocation of array `ns2__getUnreadMessageFromClientResponse[n]`
- `ns2__getUnreadMessageFromClientResponse *soap_new_req_ns2__getUnreadMessageFromClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getUnreadMessageFromClientResponse *soap_new_set_ns2__getUnreadMessageFromClientResponse(struct soap*, const std::vector<ns2__message *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getUnreadMessageFromClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getUnreadMessageFromClientResponse(struct soap*, const ns2__getUnreadMessageFromClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getUnreadMessageFromClientResponse(struct soap*, const char *URL, const ns2__getUnreadMessageFromClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getUnreadMessageFromClientResponse(struct soap*, const char *URL, const ns2__getUnreadMessageFromClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getUnreadMessageFromClientResponse(struct soap*, const char *URL, const ns2__getUnreadMessageFromClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getUnreadMessageFromClientResponse(struct soap*, ns2__getUnreadMessageFromClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getUnreadMessageFromClientResponse(struct soap*, const char *URL, ns2__getUnreadMessageFromClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getUnreadMessageFromClientResponse(struct soap*, ns2__getUnreadMessageFromClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateProductByInfo"></a>

### `ns2__updateProductByInfo`

This class is declared in [soap_head.h](soap_head.h) at line 247, is serialized as XML schema type *`ns2:updateProductByInfo`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateProductByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateProductByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateProductByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateProductByInfo, default initialized and not managed by a soap context
        virtual ns2__updateProductByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateProductByInfo); }
      public:
        /// Constructor with default initializations
        ns2__updateProductByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateProductByInfo() { }
        /// Friend allocator used by soap_new_ns2__updateProductByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateProductByInfo * SOAP_FMAC2 soap_instantiate_ns2__updateProductByInfo(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__product *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:product`*, where the type of this member is a pointer to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateProductByInfo` are available:

- `ns2__updateProductByInfo *soap_new_ns2__updateProductByInfo(struct soap*)` managed allocation with default initialization
- `ns2__updateProductByInfo *soap_new_ns2__updateProductByInfo(struct soap*, int n)` managed allocation of array `ns2__updateProductByInfo[n]`
- `ns2__updateProductByInfo *soap_new_req_ns2__updateProductByInfo(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateProductByInfo *soap_new_set_ns2__updateProductByInfo(struct soap*, ns2__product *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateProductByInfo::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateProductByInfo(struct soap*, const ns2__updateProductByInfo*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateProductByInfo(struct soap*, const char *URL, const ns2__updateProductByInfo*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateProductByInfo(struct soap*, const char *URL, const ns2__updateProductByInfo*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateProductByInfo(struct soap*, const char *URL, const ns2__updateProductByInfo*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateProductByInfo(struct soap*, ns2__updateProductByInfo*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateProductByInfo(struct soap*, const char *URL, ns2__updateProductByInfo*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateProductByInfo(struct soap*, ns2__updateProductByInfo*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateProductByInfoResponse"></a>

### `ns2__updateProductByInfoResponse`

This class is declared in [soap_head.h](soap_head.h) at line 249, is serialized as XML schema type *`ns2:updateProductByInfoResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateProductByInfoResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateProductByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateProductByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateProductByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__updateProductByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateProductByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateProductByInfoResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateProductByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__updateProductByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateProductByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__updateProductByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateProductByInfoResponse` are available:

- `ns2__updateProductByInfoResponse *soap_new_ns2__updateProductByInfoResponse(struct soap*)` managed allocation with default initialization
- `ns2__updateProductByInfoResponse *soap_new_ns2__updateProductByInfoResponse(struct soap*, int n)` managed allocation of array `ns2__updateProductByInfoResponse[n]`
- `ns2__updateProductByInfoResponse *soap_new_req_ns2__updateProductByInfoResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateProductByInfoResponse *soap_new_set_ns2__updateProductByInfoResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateProductByInfoResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateProductByInfoResponse(struct soap*, const ns2__updateProductByInfoResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateProductByInfoResponse(struct soap*, const char *URL, const ns2__updateProductByInfoResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateProductByInfoResponse(struct soap*, const char *URL, const ns2__updateProductByInfoResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateProductByInfoResponse(struct soap*, const char *URL, const ns2__updateProductByInfoResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateProductByInfoResponse(struct soap*, ns2__updateProductByInfoResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateProductByInfoResponse(struct soap*, const char *URL, ns2__updateProductByInfoResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateProductByInfoResponse(struct soap*, ns2__updateProductByInfoResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getMessageFromClient"></a>

### `ns2__getMessageFromClient`

This class is declared in [soap_head.h](soap_head.h) at line 251, is serialized as XML schema type *`ns2:getMessageFromClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__getMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__shop *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:shop`*, where the type of this member is a pointer to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getMessageFromClient` are available:

- `ns2__getMessageFromClient *soap_new_ns2__getMessageFromClient(struct soap*)` managed allocation with default initialization
- `ns2__getMessageFromClient *soap_new_ns2__getMessageFromClient(struct soap*, int n)` managed allocation of array `ns2__getMessageFromClient[n]`
- `ns2__getMessageFromClient *soap_new_req_ns2__getMessageFromClient(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getMessageFromClient *soap_new_set_ns2__getMessageFromClient(struct soap*, ns2__shop *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getMessageFromClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getMessageFromClient(struct soap*, const ns2__getMessageFromClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getMessageFromClient(struct soap*, const char *URL, const ns2__getMessageFromClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getMessageFromClient(struct soap*, const char *URL, const ns2__getMessageFromClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getMessageFromClient(struct soap*, const char *URL, const ns2__getMessageFromClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getMessageFromClient(struct soap*, ns2__getMessageFromClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getMessageFromClient(struct soap*, const char *URL, ns2__getMessageFromClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getMessageFromClient(struct soap*, ns2__getMessageFromClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getMessageFromClientResponse"></a>

### `ns2__getMessageFromClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 253, is serialized as XML schema type *`ns2:getMessageFromClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getMessageFromClientResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__getMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromClientResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__message *> return_` is an optional element *`<return>`* of XML schema type *`ns2:message`*, where the type of this member is a container of pointers to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getMessageFromClientResponse` are available:

- `ns2__getMessageFromClientResponse *soap_new_ns2__getMessageFromClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__getMessageFromClientResponse *soap_new_ns2__getMessageFromClientResponse(struct soap*, int n)` managed allocation of array `ns2__getMessageFromClientResponse[n]`
- `ns2__getMessageFromClientResponse *soap_new_req_ns2__getMessageFromClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getMessageFromClientResponse *soap_new_set_ns2__getMessageFromClientResponse(struct soap*, const std::vector<ns2__message *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getMessageFromClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getMessageFromClientResponse(struct soap*, const ns2__getMessageFromClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getMessageFromClientResponse(struct soap*, const char *URL, const ns2__getMessageFromClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getMessageFromClientResponse(struct soap*, const char *URL, const ns2__getMessageFromClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getMessageFromClientResponse(struct soap*, const char *URL, const ns2__getMessageFromClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getMessageFromClientResponse(struct soap*, ns2__getMessageFromClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getMessageFromClientResponse(struct soap*, const char *URL, ns2__getMessageFromClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getMessageFromClientResponse(struct soap*, ns2__getMessageFromClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__addOrder"></a>

### `ns2__addOrder`

This class is declared in [soap_head.h](soap_head.h) at line 255, is serialized as XML schema type *`ns2:addOrder`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__addOrder {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addOrder
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addOrder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addOrder, default initialized and not managed by a soap context
        virtual ns2__addOrder *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addOrder); }
      public:
        /// Constructor with default initializations
        ns2__addOrder() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__addOrder() { }
        /// Friend allocator used by soap_new_ns2__addOrder(struct soap*, int)
        friend SOAP_FMAC1 ns2__addOrder * SOAP_FMAC2 soap_instantiate_ns2__addOrder(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__order *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__addOrder` are available:

- `ns2__addOrder *soap_new_ns2__addOrder(struct soap*)` managed allocation with default initialization
- `ns2__addOrder *soap_new_ns2__addOrder(struct soap*, int n)` managed allocation of array `ns2__addOrder[n]`
- `ns2__addOrder *soap_new_req_ns2__addOrder(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__addOrder *soap_new_set_ns2__addOrder(struct soap*, ns2__order *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__addOrder::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__addOrder(struct soap*, const ns2__addOrder*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__addOrder(struct soap*, const char *URL, const ns2__addOrder*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__addOrder(struct soap*, const char *URL, const ns2__addOrder*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__addOrder(struct soap*, const char *URL, const ns2__addOrder*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__addOrder(struct soap*, ns2__addOrder*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__addOrder(struct soap*, const char *URL, ns2__addOrder*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__addOrder(struct soap*, ns2__addOrder*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__addOrderResponse"></a>

### `ns2__addOrderResponse`

This class is declared in [soap_head.h](soap_head.h) at line 257, is serialized as XML schema type *`ns2:addOrderResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__addOrderResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addOrderResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addOrderResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addOrderResponse, default initialized and not managed by a soap context
        virtual ns2__addOrderResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addOrderResponse); }
      public:
        /// Constructor with default initializations
        ns2__addOrderResponse() : soap() { }
        /// Destructor
        virtual ~ns2__addOrderResponse() { }
        /// Friend allocator used by soap_new_ns2__addOrderResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__addOrderResponse * SOAP_FMAC2 soap_instantiate_ns2__addOrderResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__addOrderResponse` are available:

- `ns2__addOrderResponse *soap_new_ns2__addOrderResponse(struct soap*)` managed allocation with default initialization
- `ns2__addOrderResponse *soap_new_ns2__addOrderResponse(struct soap*, int n)` managed allocation of array `ns2__addOrderResponse[n]`
- `ns2__addOrderResponse *soap_new_req_ns2__addOrderResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__addOrderResponse *soap_new_set_ns2__addOrderResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__addOrderResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__addOrderResponse(struct soap*, const ns2__addOrderResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__addOrderResponse(struct soap*, const char *URL, const ns2__addOrderResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__addOrderResponse(struct soap*, const char *URL, const ns2__addOrderResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__addOrderResponse(struct soap*, const char *URL, const ns2__addOrderResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__addOrderResponse(struct soap*, ns2__addOrderResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__addOrderResponse(struct soap*, const char *URL, ns2__addOrderResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__addOrderResponse(struct soap*, ns2__addOrderResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteShopByNameAndPwd"></a>

### `ns2__deleteShopByNameAndPwd`

This class is declared in [soap_head.h](soap_head.h) at line 259, is serialized as XML schema type *`ns2:deleteShopByNameAndPwd`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteShopByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShopByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShopByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShopByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__deleteShopByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShopByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__deleteShopByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteShopByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__deleteShopByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShopByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__deleteShopByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `std::string *arg1` is an optional element *`<arg1>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteShopByNameAndPwd` are available:

- `ns2__deleteShopByNameAndPwd *soap_new_ns2__deleteShopByNameAndPwd(struct soap*)` managed allocation with default initialization
- `ns2__deleteShopByNameAndPwd *soap_new_ns2__deleteShopByNameAndPwd(struct soap*, int n)` managed allocation of array `ns2__deleteShopByNameAndPwd[n]`
- `ns2__deleteShopByNameAndPwd *soap_new_req_ns2__deleteShopByNameAndPwd(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteShopByNameAndPwd *soap_new_set_ns2__deleteShopByNameAndPwd(struct soap*, std::string *arg0, std::string *arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteShopByNameAndPwd::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteShopByNameAndPwd(struct soap*, const ns2__deleteShopByNameAndPwd*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteShopByNameAndPwd(struct soap*, const char *URL, const ns2__deleteShopByNameAndPwd*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteShopByNameAndPwd(struct soap*, const char *URL, const ns2__deleteShopByNameAndPwd*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteShopByNameAndPwd(struct soap*, const char *URL, const ns2__deleteShopByNameAndPwd*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteShopByNameAndPwd(struct soap*, ns2__deleteShopByNameAndPwd*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteShopByNameAndPwd(struct soap*, const char *URL, ns2__deleteShopByNameAndPwd*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteShopByNameAndPwd(struct soap*, ns2__deleteShopByNameAndPwd*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteShopByNameAndPwdResponse"></a>

### `ns2__deleteShopByNameAndPwdResponse`

This class is declared in [soap_head.h](soap_head.h) at line 261, is serialized as XML schema type *`ns2:deleteShopByNameAndPwdResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteShopByNameAndPwdResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShopByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__deleteShopByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShopByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteShopByNameAndPwdResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteShopByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteShopByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShopByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteShopByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteShopByNameAndPwdResponse` are available:

- `ns2__deleteShopByNameAndPwdResponse *soap_new_ns2__deleteShopByNameAndPwdResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteShopByNameAndPwdResponse *soap_new_ns2__deleteShopByNameAndPwdResponse(struct soap*, int n)` managed allocation of array `ns2__deleteShopByNameAndPwdResponse[n]`
- `ns2__deleteShopByNameAndPwdResponse *soap_new_req_ns2__deleteShopByNameAndPwdResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteShopByNameAndPwdResponse *soap_new_set_ns2__deleteShopByNameAndPwdResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteShopByNameAndPwdResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteShopByNameAndPwdResponse(struct soap*, const ns2__deleteShopByNameAndPwdResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteShopByNameAndPwdResponse(struct soap*, const char *URL, const ns2__deleteShopByNameAndPwdResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteShopByNameAndPwdResponse(struct soap*, const char *URL, const ns2__deleteShopByNameAndPwdResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteShopByNameAndPwdResponse(struct soap*, const char *URL, const ns2__deleteShopByNameAndPwdResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteShopByNameAndPwdResponse(struct soap*, ns2__deleteShopByNameAndPwdResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteShopByNameAndPwdResponse(struct soap*, const char *URL, ns2__deleteShopByNameAndPwdResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteShopByNameAndPwdResponse(struct soap*, ns2__deleteShopByNameAndPwdResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductList"></a>

### `ns2__getProductList`

This class is declared in [soap_head.h](soap_head.h) at line 263, is serialized as XML schema type *`ns2:getProductList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductList {
      public:
        /// Required element 'arg0' of XML schema type 'xsd:int'
        int arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductList, default initialized and not managed by a soap context
        virtual ns2__getProductList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductList); }
      public:
        /// Constructor with default initializations
        ns2__getProductList() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getProductList() { }
        /// Friend allocator used by soap_new_ns2__getProductList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductList * SOAP_FMAC2 soap_instantiate_ns2__getProductList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `int arg0` is a required element *`<arg0>`* of XML schema type *`xsd:int`*
- `int arg1` is a required element *`<arg1>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductList` are available:

- `ns2__getProductList *soap_new_ns2__getProductList(struct soap*)` managed allocation with default initialization
- `ns2__getProductList *soap_new_ns2__getProductList(struct soap*, int n)` managed allocation of array `ns2__getProductList[n]`
- `ns2__getProductList *soap_new_req_ns2__getProductList(struct soap*, int arg0, int arg1)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductList *soap_new_set_ns2__getProductList(struct soap*, int arg0, int arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductList(struct soap*, const ns2__getProductList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductList(struct soap*, const char *URL, const ns2__getProductList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductList(struct soap*, const char *URL, const ns2__getProductList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductList(struct soap*, const char *URL, const ns2__getProductList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductList(struct soap*, ns2__getProductList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductList(struct soap*, const char *URL, ns2__getProductList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductList(struct soap*, ns2__getProductList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductListResponse"></a>

### `ns2__getProductListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 265, is serialized as XML schema type *`ns2:getProductListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        std::vector<ns2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductListResponse, default initialized and not managed by a soap context
        virtual ns2__getProductListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductListResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductListResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__product *> return_` is an optional element *`<return>`* of XML schema type *`ns2:product`*, where the type of this member is a container of pointers to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductListResponse` are available:

- `ns2__getProductListResponse *soap_new_ns2__getProductListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getProductListResponse *soap_new_ns2__getProductListResponse(struct soap*, int n)` managed allocation of array `ns2__getProductListResponse[n]`
- `ns2__getProductListResponse *soap_new_req_ns2__getProductListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductListResponse *soap_new_set_ns2__getProductListResponse(struct soap*, const std::vector<ns2__product *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductListResponse(struct soap*, const ns2__getProductListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductListResponse(struct soap*, const char *URL, const ns2__getProductListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductListResponse(struct soap*, const char *URL, const ns2__getProductListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductListResponse(struct soap*, const char *URL, const ns2__getProductListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductListResponse(struct soap*, ns2__getProductListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductListResponse(struct soap*, const char *URL, ns2__getProductListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductListResponse(struct soap*, ns2__getProductListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderListHistory"></a>

### `ns2__getOrderListHistory`

This class is declared in [soap_head.h](soap_head.h) at line 267, is serialized as XML schema type *`ns2:getOrderListHistory`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderListHistory {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListHistory
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListHistory, default initialized and not managed by a soap context
        virtual ns2__getOrderListHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListHistory); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListHistory() : soap() { }
        /// Destructor
        virtual ~ns2__getOrderListHistory() { }
        /// Friend allocator used by soap_new_ns2__getOrderListHistory(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListHistory * SOAP_FMAC2 soap_instantiate_ns2__getOrderListHistory(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderListHistory` are available:

- `ns2__getOrderListHistory *soap_new_ns2__getOrderListHistory(struct soap*)` managed allocation with default initialization
- `ns2__getOrderListHistory *soap_new_ns2__getOrderListHistory(struct soap*, int n)` managed allocation of array `ns2__getOrderListHistory[n]`
- `ns2__getOrderListHistory *soap_new_req_ns2__getOrderListHistory(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderListHistory *soap_new_set_ns2__getOrderListHistory(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderListHistory::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderListHistory(struct soap*, const ns2__getOrderListHistory*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderListHistory(struct soap*, const char *URL, const ns2__getOrderListHistory*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderListHistory(struct soap*, const char *URL, const ns2__getOrderListHistory*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderListHistory(struct soap*, const char *URL, const ns2__getOrderListHistory*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderListHistory(struct soap*, ns2__getOrderListHistory*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderListHistory(struct soap*, const char *URL, ns2__getOrderListHistory*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderListHistory(struct soap*, ns2__getOrderListHistory*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderListHistoryResponse"></a>

### `ns2__getOrderListHistoryResponse`

This class is declared in [soap_head.h](soap_head.h) at line 269, is serialized as XML schema type *`ns2:getOrderListHistoryResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderListHistoryResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListHistoryResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderListHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListHistoryResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListHistoryResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListHistoryResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderListHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListHistoryResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__order *> return_` is an optional element *`<return>`* of XML schema type *`ns2:order`*, where the type of this member is a container of pointers to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderListHistoryResponse` are available:

- `ns2__getOrderListHistoryResponse *soap_new_ns2__getOrderListHistoryResponse(struct soap*)` managed allocation with default initialization
- `ns2__getOrderListHistoryResponse *soap_new_ns2__getOrderListHistoryResponse(struct soap*, int n)` managed allocation of array `ns2__getOrderListHistoryResponse[n]`
- `ns2__getOrderListHistoryResponse *soap_new_req_ns2__getOrderListHistoryResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderListHistoryResponse *soap_new_set_ns2__getOrderListHistoryResponse(struct soap*, const std::vector<ns2__order *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderListHistoryResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderListHistoryResponse(struct soap*, const ns2__getOrderListHistoryResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderListHistoryResponse(struct soap*, const char *URL, const ns2__getOrderListHistoryResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderListHistoryResponse(struct soap*, const char *URL, const ns2__getOrderListHistoryResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderListHistoryResponse(struct soap*, const char *URL, const ns2__getOrderListHistoryResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderListHistoryResponse(struct soap*, ns2__getOrderListHistoryResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderListHistoryResponse(struct soap*, const char *URL, ns2__getOrderListHistoryResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderListHistoryResponse(struct soap*, ns2__getOrderListHistoryResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getReadMessageFromClient"></a>

### `ns2__getReadMessageFromClient`

This class is declared in [soap_head.h](soap_head.h) at line 271, is serialized as XML schema type *`ns2:getReadMessageFromClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getReadMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__shop *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:shop`*, where the type of this member is a pointer to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getReadMessageFromClient` are available:

- `ns2__getReadMessageFromClient *soap_new_ns2__getReadMessageFromClient(struct soap*)` managed allocation with default initialization
- `ns2__getReadMessageFromClient *soap_new_ns2__getReadMessageFromClient(struct soap*, int n)` managed allocation of array `ns2__getReadMessageFromClient[n]`
- `ns2__getReadMessageFromClient *soap_new_req_ns2__getReadMessageFromClient(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getReadMessageFromClient *soap_new_set_ns2__getReadMessageFromClient(struct soap*, ns2__shop *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getReadMessageFromClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getReadMessageFromClient(struct soap*, const ns2__getReadMessageFromClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getReadMessageFromClient(struct soap*, const char *URL, const ns2__getReadMessageFromClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getReadMessageFromClient(struct soap*, const char *URL, const ns2__getReadMessageFromClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getReadMessageFromClient(struct soap*, const char *URL, const ns2__getReadMessageFromClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getReadMessageFromClient(struct soap*, ns2__getReadMessageFromClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getReadMessageFromClient(struct soap*, const char *URL, ns2__getReadMessageFromClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getReadMessageFromClient(struct soap*, ns2__getReadMessageFromClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getReadMessageFromClientResponse"></a>

### `ns2__getReadMessageFromClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 273, is serialized as XML schema type *`ns2:getReadMessageFromClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getReadMessageFromClientResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromClientResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__message *> return_` is an optional element *`<return>`* of XML schema type *`ns2:message`*, where the type of this member is a container of pointers to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getReadMessageFromClientResponse` are available:

- `ns2__getReadMessageFromClientResponse *soap_new_ns2__getReadMessageFromClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__getReadMessageFromClientResponse *soap_new_ns2__getReadMessageFromClientResponse(struct soap*, int n)` managed allocation of array `ns2__getReadMessageFromClientResponse[n]`
- `ns2__getReadMessageFromClientResponse *soap_new_req_ns2__getReadMessageFromClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getReadMessageFromClientResponse *soap_new_set_ns2__getReadMessageFromClientResponse(struct soap*, const std::vector<ns2__message *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getReadMessageFromClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getReadMessageFromClientResponse(struct soap*, const ns2__getReadMessageFromClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getReadMessageFromClientResponse(struct soap*, const char *URL, const ns2__getReadMessageFromClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getReadMessageFromClientResponse(struct soap*, const char *URL, const ns2__getReadMessageFromClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getReadMessageFromClientResponse(struct soap*, const char *URL, const ns2__getReadMessageFromClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getReadMessageFromClientResponse(struct soap*, ns2__getReadMessageFromClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getReadMessageFromClientResponse(struct soap*, const char *URL, ns2__getReadMessageFromClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getReadMessageFromClientResponse(struct soap*, ns2__getReadMessageFromClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateHistory"></a>

### `ns2__updateHistory`

This class is declared in [soap_head.h](soap_head.h) at line 275, is serialized as XML schema type *`ns2:updateHistory`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateHistory {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateHistory
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateHistory, default initialized and not managed by a soap context
        virtual ns2__updateHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateHistory); }
      public:
        /// Constructor with default initializations
        ns2__updateHistory() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateHistory() { }
        /// Friend allocator used by soap_new_ns2__updateHistory(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateHistory * SOAP_FMAC2 soap_instantiate_ns2__updateHistory(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__order *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateHistory` are available:

- `ns2__updateHistory *soap_new_ns2__updateHistory(struct soap*)` managed allocation with default initialization
- `ns2__updateHistory *soap_new_ns2__updateHistory(struct soap*, int n)` managed allocation of array `ns2__updateHistory[n]`
- `ns2__updateHistory *soap_new_req_ns2__updateHistory(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateHistory *soap_new_set_ns2__updateHistory(struct soap*, ns2__order *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateHistory::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateHistory(struct soap*, const ns2__updateHistory*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateHistory(struct soap*, const char *URL, const ns2__updateHistory*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateHistory(struct soap*, const char *URL, const ns2__updateHistory*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateHistory(struct soap*, const char *URL, const ns2__updateHistory*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateHistory(struct soap*, ns2__updateHistory*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateHistory(struct soap*, const char *URL, ns2__updateHistory*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateHistory(struct soap*, ns2__updateHistory*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__updateHistoryResponse"></a>

### `ns2__updateHistoryResponse`

This class is declared in [soap_head.h](soap_head.h) at line 277, is serialized as XML schema type *`ns2:updateHistoryResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__updateHistoryResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateHistoryResponse, default initialized and not managed by a soap context
        virtual ns2__updateHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateHistoryResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateHistoryResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateHistoryResponse() { }
        /// Friend allocator used by soap_new_ns2__updateHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateHistoryResponse * SOAP_FMAC2 soap_instantiate_ns2__updateHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__updateHistoryResponse` are available:

- `ns2__updateHistoryResponse *soap_new_ns2__updateHistoryResponse(struct soap*)` managed allocation with default initialization
- `ns2__updateHistoryResponse *soap_new_ns2__updateHistoryResponse(struct soap*, int n)` managed allocation of array `ns2__updateHistoryResponse[n]`
- `ns2__updateHistoryResponse *soap_new_req_ns2__updateHistoryResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__updateHistoryResponse *soap_new_set_ns2__updateHistoryResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__updateHistoryResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__updateHistoryResponse(struct soap*, const ns2__updateHistoryResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__updateHistoryResponse(struct soap*, const char *URL, const ns2__updateHistoryResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__updateHistoryResponse(struct soap*, const char *URL, const ns2__updateHistoryResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__updateHistoryResponse(struct soap*, const char *URL, const ns2__updateHistoryResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__updateHistoryResponse(struct soap*, ns2__updateHistoryResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__updateHistoryResponse(struct soap*, const char *URL, ns2__updateHistoryResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__updateHistoryResponse(struct soap*, ns2__updateHistoryResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__InsertMessage"></a>

### `ns2__InsertMessage`

This class is declared in [soap_head.h](soap_head.h) at line 279, is serialized as XML schema type *`ns2:InsertMessage`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__InsertMessage {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertMessage
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertMessage, default initialized and not managed by a soap context
        virtual ns2__InsertMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertMessage); }
      public:
        /// Constructor with default initializations
        ns2__InsertMessage() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__InsertMessage() { }
        /// Friend allocator used by soap_new_ns2__InsertMessage(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertMessage * SOAP_FMAC2 soap_instantiate_ns2__InsertMessage(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__message *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:message`*, where the type of this member is a pointer to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__InsertMessage` are available:

- `ns2__InsertMessage *soap_new_ns2__InsertMessage(struct soap*)` managed allocation with default initialization
- `ns2__InsertMessage *soap_new_ns2__InsertMessage(struct soap*, int n)` managed allocation of array `ns2__InsertMessage[n]`
- `ns2__InsertMessage *soap_new_req_ns2__InsertMessage(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__InsertMessage *soap_new_set_ns2__InsertMessage(struct soap*, ns2__message *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__InsertMessage::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__InsertMessage(struct soap*, const ns2__InsertMessage*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__InsertMessage(struct soap*, const char *URL, const ns2__InsertMessage*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__InsertMessage(struct soap*, const char *URL, const ns2__InsertMessage*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__InsertMessage(struct soap*, const char *URL, const ns2__InsertMessage*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__InsertMessage(struct soap*, ns2__InsertMessage*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__InsertMessage(struct soap*, const char *URL, ns2__InsertMessage*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__InsertMessage(struct soap*, ns2__InsertMessage*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__InsertMessageResponse"></a>

### `ns2__InsertMessageResponse`

This class is declared in [soap_head.h](soap_head.h) at line 281, is serialized as XML schema type *`ns2:InsertMessageResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__InsertMessageResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertMessageResponse, default initialized and not managed by a soap context
        virtual ns2__InsertMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertMessageResponse); }
      public:
        /// Constructor with default initializations
        ns2__InsertMessageResponse() : soap() { }
        /// Destructor
        virtual ~ns2__InsertMessageResponse() { }
        /// Friend allocator used by soap_new_ns2__InsertMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertMessageResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertMessageResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__InsertMessageResponse` are available:

- `ns2__InsertMessageResponse *soap_new_ns2__InsertMessageResponse(struct soap*)` managed allocation with default initialization
- `ns2__InsertMessageResponse *soap_new_ns2__InsertMessageResponse(struct soap*, int n)` managed allocation of array `ns2__InsertMessageResponse[n]`
- `ns2__InsertMessageResponse *soap_new_req_ns2__InsertMessageResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__InsertMessageResponse *soap_new_set_ns2__InsertMessageResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__InsertMessageResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__InsertMessageResponse(struct soap*, const ns2__InsertMessageResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__InsertMessageResponse(struct soap*, const char *URL, const ns2__InsertMessageResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__InsertMessageResponse(struct soap*, const char *URL, const ns2__InsertMessageResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__InsertMessageResponse(struct soap*, const char *URL, const ns2__InsertMessageResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__InsertMessageResponse(struct soap*, ns2__InsertMessageResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__InsertMessageResponse(struct soap*, const char *URL, ns2__InsertMessageResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__InsertMessageResponse(struct soap*, ns2__InsertMessageResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getShopLikeList"></a>

### `ns2__getShopLikeList`

This class is declared in [soap_head.h](soap_head.h) at line 283, is serialized as XML schema type *`ns2:getShopLikeList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getShopLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopLikeList, default initialized and not managed by a soap context
        virtual ns2__getShopLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getShopLikeList() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getShopLikeList() { }
        /// Friend allocator used by soap_new_ns2__getShopLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopLikeList * SOAP_FMAC2 soap_instantiate_ns2__getShopLikeList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getShopLikeList` are available:

- `ns2__getShopLikeList *soap_new_ns2__getShopLikeList(struct soap*)` managed allocation with default initialization
- `ns2__getShopLikeList *soap_new_ns2__getShopLikeList(struct soap*, int n)` managed allocation of array `ns2__getShopLikeList[n]`
- `ns2__getShopLikeList *soap_new_req_ns2__getShopLikeList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getShopLikeList *soap_new_set_ns2__getShopLikeList(struct soap*, std::string *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getShopLikeList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getShopLikeList(struct soap*, const ns2__getShopLikeList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getShopLikeList(struct soap*, const char *URL, const ns2__getShopLikeList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getShopLikeList(struct soap*, const char *URL, const ns2__getShopLikeList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getShopLikeList(struct soap*, const char *URL, const ns2__getShopLikeList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getShopLikeList(struct soap*, ns2__getShopLikeList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getShopLikeList(struct soap*, const char *URL, ns2__getShopLikeList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getShopLikeList(struct soap*, ns2__getShopLikeList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getShopLikeListResponse"></a>

### `ns2__getShopLikeListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 285, is serialized as XML schema type *`ns2:getShopLikeListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getShopLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:shop'
        std::vector<ns2__shop *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getShopLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getShopLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getShopLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getShopLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__shop *> return_` is an optional element *`<return>`* of XML schema type *`ns2:shop`*, where the type of this member is a container of pointers to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getShopLikeListResponse` are available:

- `ns2__getShopLikeListResponse *soap_new_ns2__getShopLikeListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getShopLikeListResponse *soap_new_ns2__getShopLikeListResponse(struct soap*, int n)` managed allocation of array `ns2__getShopLikeListResponse[n]`
- `ns2__getShopLikeListResponse *soap_new_req_ns2__getShopLikeListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getShopLikeListResponse *soap_new_set_ns2__getShopLikeListResponse(struct soap*, const std::vector<ns2__shop *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getShopLikeListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getShopLikeListResponse(struct soap*, const ns2__getShopLikeListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getShopLikeListResponse(struct soap*, const char *URL, const ns2__getShopLikeListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getShopLikeListResponse(struct soap*, const char *URL, const ns2__getShopLikeListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getShopLikeListResponse(struct soap*, const char *URL, const ns2__getShopLikeListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getShopLikeListResponse(struct soap*, ns2__getShopLikeListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getShopLikeListResponse(struct soap*, const char *URL, ns2__getShopLikeListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getShopLikeListResponse(struct soap*, ns2__getShopLikeListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getMessageFromShop"></a>

### `ns2__getMessageFromShop`

This class is declared in [soap_head.h](soap_head.h) at line 287, is serialized as XML schema type *`ns2:getMessageFromShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__getMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__client *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:client`*, where the type of this member is a pointer to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getMessageFromShop` are available:

- `ns2__getMessageFromShop *soap_new_ns2__getMessageFromShop(struct soap*)` managed allocation with default initialization
- `ns2__getMessageFromShop *soap_new_ns2__getMessageFromShop(struct soap*, int n)` managed allocation of array `ns2__getMessageFromShop[n]`
- `ns2__getMessageFromShop *soap_new_req_ns2__getMessageFromShop(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getMessageFromShop *soap_new_set_ns2__getMessageFromShop(struct soap*, ns2__client *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getMessageFromShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getMessageFromShop(struct soap*, const ns2__getMessageFromShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getMessageFromShop(struct soap*, const char *URL, const ns2__getMessageFromShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getMessageFromShop(struct soap*, const char *URL, const ns2__getMessageFromShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getMessageFromShop(struct soap*, const char *URL, const ns2__getMessageFromShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getMessageFromShop(struct soap*, ns2__getMessageFromShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getMessageFromShop(struct soap*, const char *URL, ns2__getMessageFromShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getMessageFromShop(struct soap*, ns2__getMessageFromShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getMessageFromShopResponse"></a>

### `ns2__getMessageFromShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 289, is serialized as XML schema type *`ns2:getMessageFromShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getMessageFromShopResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__getMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromShopResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__message *> return_` is an optional element *`<return>`* of XML schema type *`ns2:message`*, where the type of this member is a container of pointers to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getMessageFromShopResponse` are available:

- `ns2__getMessageFromShopResponse *soap_new_ns2__getMessageFromShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__getMessageFromShopResponse *soap_new_ns2__getMessageFromShopResponse(struct soap*, int n)` managed allocation of array `ns2__getMessageFromShopResponse[n]`
- `ns2__getMessageFromShopResponse *soap_new_req_ns2__getMessageFromShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getMessageFromShopResponse *soap_new_set_ns2__getMessageFromShopResponse(struct soap*, const std::vector<ns2__message *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getMessageFromShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getMessageFromShopResponse(struct soap*, const ns2__getMessageFromShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getMessageFromShopResponse(struct soap*, const char *URL, const ns2__getMessageFromShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getMessageFromShopResponse(struct soap*, const char *URL, const ns2__getMessageFromShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getMessageFromShopResponse(struct soap*, const char *URL, const ns2__getMessageFromShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getMessageFromShopResponse(struct soap*, ns2__getMessageFromShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getMessageFromShopResponse(struct soap*, const char *URL, ns2__getMessageFromShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getMessageFromShopResponse(struct soap*, ns2__getMessageFromShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteMessageFromShop"></a>

### `ns2__deleteMessageFromShop`

This class is declared in [soap_head.h](soap_head.h) at line 291, is serialized as XML schema type *`ns2:deleteMessageFromShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromShop() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__message *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:message`*, where the type of this member is a pointer to <code><a href="#ns2__message"> ns2__message </a></code>
- `int arg1` is a required element *`<arg1>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteMessageFromShop` are available:

- `ns2__deleteMessageFromShop *soap_new_ns2__deleteMessageFromShop(struct soap*)` managed allocation with default initialization
- `ns2__deleteMessageFromShop *soap_new_ns2__deleteMessageFromShop(struct soap*, int n)` managed allocation of array `ns2__deleteMessageFromShop[n]`
- `ns2__deleteMessageFromShop *soap_new_req_ns2__deleteMessageFromShop(struct soap*, int arg1)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteMessageFromShop *soap_new_set_ns2__deleteMessageFromShop(struct soap*, ns2__message *arg0, int arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteMessageFromShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteMessageFromShop(struct soap*, const ns2__deleteMessageFromShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteMessageFromShop(struct soap*, const char *URL, const ns2__deleteMessageFromShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteMessageFromShop(struct soap*, const char *URL, const ns2__deleteMessageFromShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteMessageFromShop(struct soap*, const char *URL, const ns2__deleteMessageFromShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteMessageFromShop(struct soap*, ns2__deleteMessageFromShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteMessageFromShop(struct soap*, const char *URL, ns2__deleteMessageFromShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteMessageFromShop(struct soap*, ns2__deleteMessageFromShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteMessageFromShopResponse"></a>

### `ns2__deleteMessageFromShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 293, is serialized as XML schema type *`ns2:deleteMessageFromShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteMessageFromShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteMessageFromShopResponse` are available:

- `ns2__deleteMessageFromShopResponse *soap_new_ns2__deleteMessageFromShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteMessageFromShopResponse *soap_new_ns2__deleteMessageFromShopResponse(struct soap*, int n)` managed allocation of array `ns2__deleteMessageFromShopResponse[n]`
- `ns2__deleteMessageFromShopResponse *soap_new_req_ns2__deleteMessageFromShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteMessageFromShopResponse *soap_new_set_ns2__deleteMessageFromShopResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteMessageFromShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteMessageFromShopResponse(struct soap*, const ns2__deleteMessageFromShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteMessageFromShopResponse(struct soap*, const char *URL, const ns2__deleteMessageFromShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteMessageFromShopResponse(struct soap*, const char *URL, const ns2__deleteMessageFromShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteMessageFromShopResponse(struct soap*, const char *URL, const ns2__deleteMessageFromShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteMessageFromShopResponse(struct soap*, ns2__deleteMessageFromShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteMessageFromShopResponse(struct soap*, const char *URL, ns2__deleteMessageFromShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteMessageFromShopResponse(struct soap*, ns2__deleteMessageFromShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderLikeList"></a>

### `ns2__getOrderLikeList`

This class is declared in [soap_head.h](soap_head.h) at line 295, is serialized as XML schema type *`ns2:getOrderLikeList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns2:order'
        ns2__order *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderLikeList, default initialized and not managed by a soap context
        virtual ns2__getOrderLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getOrderLikeList() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderLikeList() { }
        /// Friend allocator used by soap_new_ns2__getOrderLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderLikeList * SOAP_FMAC2 soap_instantiate_ns2__getOrderLikeList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `ns2__order *arg1` is an optional element *`<arg1>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderLikeList` are available:

- `ns2__getOrderLikeList *soap_new_ns2__getOrderLikeList(struct soap*)` managed allocation with default initialization
- `ns2__getOrderLikeList *soap_new_ns2__getOrderLikeList(struct soap*, int n)` managed allocation of array `ns2__getOrderLikeList[n]`
- `ns2__getOrderLikeList *soap_new_req_ns2__getOrderLikeList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderLikeList *soap_new_set_ns2__getOrderLikeList(struct soap*, std::string *arg0, ns2__order *arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderLikeList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderLikeList(struct soap*, const ns2__getOrderLikeList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderLikeList(struct soap*, const char *URL, const ns2__getOrderLikeList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderLikeList(struct soap*, const char *URL, const ns2__getOrderLikeList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderLikeList(struct soap*, const char *URL, const ns2__getOrderLikeList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderLikeList(struct soap*, ns2__getOrderLikeList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderLikeList(struct soap*, const char *URL, ns2__getOrderLikeList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderLikeList(struct soap*, ns2__getOrderLikeList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderLikeListResponse"></a>

### `ns2__getOrderLikeListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 297, is serialized as XML schema type *`ns2:getOrderLikeListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__order *> return_` is an optional element *`<return>`* of XML schema type *`ns2:order`*, where the type of this member is a container of pointers to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderLikeListResponse` are available:

- `ns2__getOrderLikeListResponse *soap_new_ns2__getOrderLikeListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getOrderLikeListResponse *soap_new_ns2__getOrderLikeListResponse(struct soap*, int n)` managed allocation of array `ns2__getOrderLikeListResponse[n]`
- `ns2__getOrderLikeListResponse *soap_new_req_ns2__getOrderLikeListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderLikeListResponse *soap_new_set_ns2__getOrderLikeListResponse(struct soap*, const std::vector<ns2__order *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderLikeListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderLikeListResponse(struct soap*, const ns2__getOrderLikeListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderLikeListResponse(struct soap*, const char *URL, const ns2__getOrderLikeListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderLikeListResponse(struct soap*, const char *URL, const ns2__getOrderLikeListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderLikeListResponse(struct soap*, const char *URL, const ns2__getOrderLikeListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderLikeListResponse(struct soap*, ns2__getOrderLikeListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderLikeListResponse(struct soap*, const char *URL, ns2__getOrderLikeListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderLikeListResponse(struct soap*, ns2__getOrderLikeListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getUnreadMessageFromShop"></a>

### `ns2__getUnreadMessageFromShop`

This class is declared in [soap_head.h](soap_head.h) at line 299, is serialized as XML schema type *`ns2:getUnreadMessageFromShop`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getUnreadMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__client *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:client`*, where the type of this member is a pointer to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getUnreadMessageFromShop` are available:

- `ns2__getUnreadMessageFromShop *soap_new_ns2__getUnreadMessageFromShop(struct soap*)` managed allocation with default initialization
- `ns2__getUnreadMessageFromShop *soap_new_ns2__getUnreadMessageFromShop(struct soap*, int n)` managed allocation of array `ns2__getUnreadMessageFromShop[n]`
- `ns2__getUnreadMessageFromShop *soap_new_req_ns2__getUnreadMessageFromShop(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getUnreadMessageFromShop *soap_new_set_ns2__getUnreadMessageFromShop(struct soap*, ns2__client *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getUnreadMessageFromShop::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getUnreadMessageFromShop(struct soap*, const ns2__getUnreadMessageFromShop*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getUnreadMessageFromShop(struct soap*, const char *URL, const ns2__getUnreadMessageFromShop*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getUnreadMessageFromShop(struct soap*, const char *URL, const ns2__getUnreadMessageFromShop*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getUnreadMessageFromShop(struct soap*, const char *URL, const ns2__getUnreadMessageFromShop*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getUnreadMessageFromShop(struct soap*, ns2__getUnreadMessageFromShop*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getUnreadMessageFromShop(struct soap*, const char *URL, ns2__getUnreadMessageFromShop*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getUnreadMessageFromShop(struct soap*, ns2__getUnreadMessageFromShop*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getUnreadMessageFromShopResponse"></a>

### `ns2__getUnreadMessageFromShopResponse`

This class is declared in [soap_head.h](soap_head.h) at line 301, is serialized as XML schema type *`ns2:getUnreadMessageFromShopResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getUnreadMessageFromShopResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromShopResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__message *> return_` is an optional element *`<return>`* of XML schema type *`ns2:message`*, where the type of this member is a container of pointers to <code><a href="#ns2__message"> ns2__message </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getUnreadMessageFromShopResponse` are available:

- `ns2__getUnreadMessageFromShopResponse *soap_new_ns2__getUnreadMessageFromShopResponse(struct soap*)` managed allocation with default initialization
- `ns2__getUnreadMessageFromShopResponse *soap_new_ns2__getUnreadMessageFromShopResponse(struct soap*, int n)` managed allocation of array `ns2__getUnreadMessageFromShopResponse[n]`
- `ns2__getUnreadMessageFromShopResponse *soap_new_req_ns2__getUnreadMessageFromShopResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getUnreadMessageFromShopResponse *soap_new_set_ns2__getUnreadMessageFromShopResponse(struct soap*, const std::vector<ns2__message *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getUnreadMessageFromShopResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getUnreadMessageFromShopResponse(struct soap*, const ns2__getUnreadMessageFromShopResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getUnreadMessageFromShopResponse(struct soap*, const char *URL, const ns2__getUnreadMessageFromShopResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getUnreadMessageFromShopResponse(struct soap*, const char *URL, const ns2__getUnreadMessageFromShopResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getUnreadMessageFromShopResponse(struct soap*, const char *URL, const ns2__getUnreadMessageFromShopResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getUnreadMessageFromShopResponse(struct soap*, ns2__getUnreadMessageFromShopResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getUnreadMessageFromShopResponse(struct soap*, const char *URL, ns2__getUnreadMessageFromShopResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getUnreadMessageFromShopResponse(struct soap*, ns2__getUnreadMessageFromShopResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getClientLikeList"></a>

### `ns2__getClientLikeList`

This class is declared in [soap_head.h](soap_head.h) at line 303, is serialized as XML schema type *`ns2:getClientLikeList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getClientLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientLikeList, default initialized and not managed by a soap context
        virtual ns2__getClientLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getClientLikeList() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getClientLikeList() { }
        /// Friend allocator used by soap_new_ns2__getClientLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientLikeList * SOAP_FMAC2 soap_instantiate_ns2__getClientLikeList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getClientLikeList` are available:

- `ns2__getClientLikeList *soap_new_ns2__getClientLikeList(struct soap*)` managed allocation with default initialization
- `ns2__getClientLikeList *soap_new_ns2__getClientLikeList(struct soap*, int n)` managed allocation of array `ns2__getClientLikeList[n]`
- `ns2__getClientLikeList *soap_new_req_ns2__getClientLikeList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getClientLikeList *soap_new_set_ns2__getClientLikeList(struct soap*, std::string *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getClientLikeList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getClientLikeList(struct soap*, const ns2__getClientLikeList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getClientLikeList(struct soap*, const char *URL, const ns2__getClientLikeList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getClientLikeList(struct soap*, const char *URL, const ns2__getClientLikeList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getClientLikeList(struct soap*, const char *URL, const ns2__getClientLikeList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getClientLikeList(struct soap*, ns2__getClientLikeList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getClientLikeList(struct soap*, const char *URL, ns2__getClientLikeList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getClientLikeList(struct soap*, ns2__getClientLikeList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getClientLikeListResponse"></a>

### `ns2__getClientLikeListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 305, is serialized as XML schema type *`ns2:getClientLikeListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getClientLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:client'
        std::vector<ns2__client *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getClientLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getClientLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getClientLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getClientLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__client *> return_` is an optional element *`<return>`* of XML schema type *`ns2:client`*, where the type of this member is a container of pointers to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getClientLikeListResponse` are available:

- `ns2__getClientLikeListResponse *soap_new_ns2__getClientLikeListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getClientLikeListResponse *soap_new_ns2__getClientLikeListResponse(struct soap*, int n)` managed allocation of array `ns2__getClientLikeListResponse[n]`
- `ns2__getClientLikeListResponse *soap_new_req_ns2__getClientLikeListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getClientLikeListResponse *soap_new_set_ns2__getClientLikeListResponse(struct soap*, const std::vector<ns2__client *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getClientLikeListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getClientLikeListResponse(struct soap*, const ns2__getClientLikeListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getClientLikeListResponse(struct soap*, const char *URL, const ns2__getClientLikeListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getClientLikeListResponse(struct soap*, const char *URL, const ns2__getClientLikeListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getClientLikeListResponse(struct soap*, const char *URL, const ns2__getClientLikeListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getClientLikeListResponse(struct soap*, ns2__getClientLikeListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getClientLikeListResponse(struct soap*, const char *URL, ns2__getClientLikeListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getClientLikeListResponse(struct soap*, ns2__getClientLikeListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getShopList"></a>

### `ns2__getShopList`

This class is declared in [soap_head.h](soap_head.h) at line 307, is serialized as XML schema type *`ns2:getShopList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getShopList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopList, default initialized and not managed by a soap context
        virtual ns2__getShopList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopList); }
      public:
        /// Constructor with default initializations
        ns2__getShopList() : soap() { }
        /// Destructor
        virtual ~ns2__getShopList() { }
        /// Friend allocator used by soap_new_ns2__getShopList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopList * SOAP_FMAC2 soap_instantiate_ns2__getShopList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__getShopList` are available:

- `ns2__getShopList *soap_new_ns2__getShopList(struct soap*)` managed allocation with default initialization
- `ns2__getShopList *soap_new_ns2__getShopList(struct soap*, int n)` managed allocation of array `ns2__getShopList[n]`
- `ns2__getShopList *soap_new_req_ns2__getShopList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getShopList *soap_new_set_ns2__getShopList(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__getShopList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getShopList(struct soap*, const ns2__getShopList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getShopList(struct soap*, const char *URL, const ns2__getShopList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getShopList(struct soap*, const char *URL, const ns2__getShopList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getShopList(struct soap*, const char *URL, const ns2__getShopList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getShopList(struct soap*, ns2__getShopList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getShopList(struct soap*, const char *URL, ns2__getShopList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getShopList(struct soap*, ns2__getShopList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getShopListResponse"></a>

### `ns2__getShopListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 309, is serialized as XML schema type *`ns2:getShopListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getShopListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:shop'
        std::vector<ns2__shop *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopListResponse, default initialized and not managed by a soap context
        virtual ns2__getShopListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getShopListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getShopListResponse() { }
        /// Friend allocator used by soap_new_ns2__getShopListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopListResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__shop *> return_` is an optional element *`<return>`* of XML schema type *`ns2:shop`*, where the type of this member is a container of pointers to <code><a href="#ns2__shop"> ns2__shop </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getShopListResponse` are available:

- `ns2__getShopListResponse *soap_new_ns2__getShopListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getShopListResponse *soap_new_ns2__getShopListResponse(struct soap*, int n)` managed allocation of array `ns2__getShopListResponse[n]`
- `ns2__getShopListResponse *soap_new_req_ns2__getShopListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getShopListResponse *soap_new_set_ns2__getShopListResponse(struct soap*, const std::vector<ns2__shop *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getShopListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getShopListResponse(struct soap*, const ns2__getShopListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getShopListResponse(struct soap*, const char *URL, const ns2__getShopListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getShopListResponse(struct soap*, const char *URL, const ns2__getShopListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getShopListResponse(struct soap*, const char *URL, const ns2__getShopListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getShopListResponse(struct soap*, ns2__getShopListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getShopListResponse(struct soap*, const char *URL, ns2__getShopListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getShopListResponse(struct soap*, ns2__getShopListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderListByInfo"></a>

### `ns2__getOrderListByInfo`

This class is declared in [soap_head.h](soap_head.h) at line 311, is serialized as XML schema type *`ns2:getOrderListByInfo`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderListByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListByInfo, default initialized and not managed by a soap context
        virtual ns2__getOrderListByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListByInfo); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListByInfo() { }
        /// Friend allocator used by soap_new_ns2__getOrderListByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListByInfo * SOAP_FMAC2 soap_instantiate_ns2__getOrderListByInfo(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__order *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderListByInfo` are available:

- `ns2__getOrderListByInfo *soap_new_ns2__getOrderListByInfo(struct soap*)` managed allocation with default initialization
- `ns2__getOrderListByInfo *soap_new_ns2__getOrderListByInfo(struct soap*, int n)` managed allocation of array `ns2__getOrderListByInfo[n]`
- `ns2__getOrderListByInfo *soap_new_req_ns2__getOrderListByInfo(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderListByInfo *soap_new_set_ns2__getOrderListByInfo(struct soap*, ns2__order *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderListByInfo::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderListByInfo(struct soap*, const ns2__getOrderListByInfo*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderListByInfo(struct soap*, const char *URL, const ns2__getOrderListByInfo*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderListByInfo(struct soap*, const char *URL, const ns2__getOrderListByInfo*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderListByInfo(struct soap*, const char *URL, const ns2__getOrderListByInfo*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderListByInfo(struct soap*, ns2__getOrderListByInfo*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderListByInfo(struct soap*, const char *URL, ns2__getOrderListByInfo*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderListByInfo(struct soap*, ns2__getOrderListByInfo*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getOrderListByInfoResponse"></a>

### `ns2__getOrderListByInfoResponse`

This class is declared in [soap_head.h](soap_head.h) at line 313, is serialized as XML schema type *`ns2:getOrderListByInfoResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getOrderListByInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderListByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListByInfoResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderListByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__order *> return_` is an optional element *`<return>`* of XML schema type *`ns2:order`*, where the type of this member is a container of pointers to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getOrderListByInfoResponse` are available:

- `ns2__getOrderListByInfoResponse *soap_new_ns2__getOrderListByInfoResponse(struct soap*)` managed allocation with default initialization
- `ns2__getOrderListByInfoResponse *soap_new_ns2__getOrderListByInfoResponse(struct soap*, int n)` managed allocation of array `ns2__getOrderListByInfoResponse[n]`
- `ns2__getOrderListByInfoResponse *soap_new_req_ns2__getOrderListByInfoResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getOrderListByInfoResponse *soap_new_set_ns2__getOrderListByInfoResponse(struct soap*, const std::vector<ns2__order *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getOrderListByInfoResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getOrderListByInfoResponse(struct soap*, const ns2__getOrderListByInfoResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getOrderListByInfoResponse(struct soap*, const char *URL, const ns2__getOrderListByInfoResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getOrderListByInfoResponse(struct soap*, const char *URL, const ns2__getOrderListByInfoResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getOrderListByInfoResponse(struct soap*, const char *URL, const ns2__getOrderListByInfoResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getOrderListByInfoResponse(struct soap*, ns2__getOrderListByInfoResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getOrderListByInfoResponse(struct soap*, const char *URL, ns2__getOrderListByInfoResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getOrderListByInfoResponse(struct soap*, ns2__getOrderListByInfoResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__addProductType"></a>

### `ns2__addProductType`

This class is declared in [soap_head.h](soap_head.h) at line 315, is serialized as XML schema type *`ns2:addProductType`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__addProductType {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:productType'
        ns2__productType *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProductType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProductType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProductType, default initialized and not managed by a soap context
        virtual ns2__addProductType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProductType); }
      public:
        /// Constructor with default initializations
        ns2__addProductType() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__addProductType() { }
        /// Friend allocator used by soap_new_ns2__addProductType(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProductType * SOAP_FMAC2 soap_instantiate_ns2__addProductType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__productType *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:productType`*, where the type of this member is a pointer to <code><a href="#ns2__productType"> ns2__productType </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__addProductType` are available:

- `ns2__addProductType *soap_new_ns2__addProductType(struct soap*)` managed allocation with default initialization
- `ns2__addProductType *soap_new_ns2__addProductType(struct soap*, int n)` managed allocation of array `ns2__addProductType[n]`
- `ns2__addProductType *soap_new_req_ns2__addProductType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__addProductType *soap_new_set_ns2__addProductType(struct soap*, ns2__productType *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__addProductType::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__addProductType(struct soap*, const ns2__addProductType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__addProductType(struct soap*, const char *URL, const ns2__addProductType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__addProductType(struct soap*, const char *URL, const ns2__addProductType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__addProductType(struct soap*, const char *URL, const ns2__addProductType*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__addProductType(struct soap*, ns2__addProductType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__addProductType(struct soap*, const char *URL, ns2__addProductType*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__addProductType(struct soap*, ns2__addProductType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__addProductTypeResponse"></a>

### `ns2__addProductTypeResponse`

This class is declared in [soap_head.h](soap_head.h) at line 317, is serialized as XML schema type *`ns2:addProductTypeResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__addProductTypeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProductTypeResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProductTypeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProductTypeResponse, default initialized and not managed by a soap context
        virtual ns2__addProductTypeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProductTypeResponse); }
      public:
        /// Constructor with default initializations
        ns2__addProductTypeResponse() : soap() { }
        /// Destructor
        virtual ~ns2__addProductTypeResponse() { }
        /// Friend allocator used by soap_new_ns2__addProductTypeResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProductTypeResponse * SOAP_FMAC2 soap_instantiate_ns2__addProductTypeResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__addProductTypeResponse` are available:

- `ns2__addProductTypeResponse *soap_new_ns2__addProductTypeResponse(struct soap*)` managed allocation with default initialization
- `ns2__addProductTypeResponse *soap_new_ns2__addProductTypeResponse(struct soap*, int n)` managed allocation of array `ns2__addProductTypeResponse[n]`
- `ns2__addProductTypeResponse *soap_new_req_ns2__addProductTypeResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__addProductTypeResponse *soap_new_set_ns2__addProductTypeResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__addProductTypeResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__addProductTypeResponse(struct soap*, const ns2__addProductTypeResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__addProductTypeResponse(struct soap*, const char *URL, const ns2__addProductTypeResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__addProductTypeResponse(struct soap*, const char *URL, const ns2__addProductTypeResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__addProductTypeResponse(struct soap*, const char *URL, const ns2__addProductTypeResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__addProductTypeResponse(struct soap*, ns2__addProductTypeResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__addProductTypeResponse(struct soap*, const char *URL, ns2__addProductTypeResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__addProductTypeResponse(struct soap*, ns2__addProductTypeResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteMessageFromClient"></a>

### `ns2__deleteMessageFromClient`

This class is declared in [soap_head.h](soap_head.h) at line 319, is serialized as XML schema type *`ns2:deleteMessageFromClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromClient() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__message *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:message`*, where the type of this member is a pointer to <code><a href="#ns2__message"> ns2__message </a></code>
- `int arg1` is a required element *`<arg1>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteMessageFromClient` are available:

- `ns2__deleteMessageFromClient *soap_new_ns2__deleteMessageFromClient(struct soap*)` managed allocation with default initialization
- `ns2__deleteMessageFromClient *soap_new_ns2__deleteMessageFromClient(struct soap*, int n)` managed allocation of array `ns2__deleteMessageFromClient[n]`
- `ns2__deleteMessageFromClient *soap_new_req_ns2__deleteMessageFromClient(struct soap*, int arg1)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteMessageFromClient *soap_new_set_ns2__deleteMessageFromClient(struct soap*, ns2__message *arg0, int arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteMessageFromClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteMessageFromClient(struct soap*, const ns2__deleteMessageFromClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteMessageFromClient(struct soap*, const char *URL, const ns2__deleteMessageFromClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteMessageFromClient(struct soap*, const char *URL, const ns2__deleteMessageFromClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteMessageFromClient(struct soap*, const char *URL, const ns2__deleteMessageFromClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteMessageFromClient(struct soap*, ns2__deleteMessageFromClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteMessageFromClient(struct soap*, const char *URL, ns2__deleteMessageFromClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteMessageFromClient(struct soap*, ns2__deleteMessageFromClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteMessageFromClientResponse"></a>

### `ns2__deleteMessageFromClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 321, is serialized as XML schema type *`ns2:deleteMessageFromClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteMessageFromClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteMessageFromClientResponse` are available:

- `ns2__deleteMessageFromClientResponse *soap_new_ns2__deleteMessageFromClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteMessageFromClientResponse *soap_new_ns2__deleteMessageFromClientResponse(struct soap*, int n)` managed allocation of array `ns2__deleteMessageFromClientResponse[n]`
- `ns2__deleteMessageFromClientResponse *soap_new_req_ns2__deleteMessageFromClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteMessageFromClientResponse *soap_new_set_ns2__deleteMessageFromClientResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteMessageFromClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteMessageFromClientResponse(struct soap*, const ns2__deleteMessageFromClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteMessageFromClientResponse(struct soap*, const char *URL, const ns2__deleteMessageFromClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteMessageFromClientResponse(struct soap*, const char *URL, const ns2__deleteMessageFromClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteMessageFromClientResponse(struct soap*, const char *URL, const ns2__deleteMessageFromClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteMessageFromClientResponse(struct soap*, ns2__deleteMessageFromClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteMessageFromClientResponse(struct soap*, const char *URL, ns2__deleteMessageFromClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteMessageFromClientResponse(struct soap*, ns2__deleteMessageFromClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductLikeList"></a>

### `ns2__getProductLikeList`

This class is declared in [soap_head.h](soap_head.h) at line 323, is serialized as XML schema type *`ns2:getProductLikeList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns2:product'
        ns2__product *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductLikeList, default initialized and not managed by a soap context
        virtual ns2__getProductLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getProductLikeList() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getProductLikeList() { }
        /// Friend allocator used by soap_new_ns2__getProductLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductLikeList * SOAP_FMAC2 soap_instantiate_ns2__getProductLikeList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `ns2__product *arg1` is an optional element *`<arg1>`* of XML schema type *`ns2:product`*, where the type of this member is a pointer to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductLikeList` are available:

- `ns2__getProductLikeList *soap_new_ns2__getProductLikeList(struct soap*)` managed allocation with default initialization
- `ns2__getProductLikeList *soap_new_ns2__getProductLikeList(struct soap*, int n)` managed allocation of array `ns2__getProductLikeList[n]`
- `ns2__getProductLikeList *soap_new_req_ns2__getProductLikeList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductLikeList *soap_new_set_ns2__getProductLikeList(struct soap*, std::string *arg0, ns2__product *arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductLikeList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductLikeList(struct soap*, const ns2__getProductLikeList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductLikeList(struct soap*, const char *URL, const ns2__getProductLikeList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductLikeList(struct soap*, const char *URL, const ns2__getProductLikeList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductLikeList(struct soap*, const char *URL, const ns2__getProductLikeList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductLikeList(struct soap*, ns2__getProductLikeList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductLikeList(struct soap*, const char *URL, ns2__getProductLikeList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductLikeList(struct soap*, ns2__getProductLikeList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getProductLikeListResponse"></a>

### `ns2__getProductLikeListResponse`

This class is declared in [soap_head.h](soap_head.h) at line 325, is serialized as XML schema type *`ns2:getProductLikeListResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getProductLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        std::vector<ns2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getProductLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<ns2__product *> return_` is an optional element *`<return>`* of XML schema type *`ns2:product`*, where the type of this member is a container of pointers to <code><a href="#ns2__product"> ns2__product </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getProductLikeListResponse` are available:

- `ns2__getProductLikeListResponse *soap_new_ns2__getProductLikeListResponse(struct soap*)` managed allocation with default initialization
- `ns2__getProductLikeListResponse *soap_new_ns2__getProductLikeListResponse(struct soap*, int n)` managed allocation of array `ns2__getProductLikeListResponse[n]`
- `ns2__getProductLikeListResponse *soap_new_req_ns2__getProductLikeListResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getProductLikeListResponse *soap_new_set_ns2__getProductLikeListResponse(struct soap*, const std::vector<ns2__product *> & return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getProductLikeListResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getProductLikeListResponse(struct soap*, const ns2__getProductLikeListResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getProductLikeListResponse(struct soap*, const char *URL, const ns2__getProductLikeListResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getProductLikeListResponse(struct soap*, const char *URL, const ns2__getProductLikeListResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getProductLikeListResponse(struct soap*, const char *URL, const ns2__getProductLikeListResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getProductLikeListResponse(struct soap*, ns2__getProductLikeListResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getProductLikeListResponse(struct soap*, const char *URL, ns2__getProductLikeListResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getProductLikeListResponse(struct soap*, ns2__getProductLikeListResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getClientByNameAndPwd"></a>

### `ns2__getClientByNameAndPwd`

This class is declared in [soap_head.h](soap_head.h) at line 327, is serialized as XML schema type *`ns2:getClientByNameAndPwd`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getClientByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__getClientByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__getClientByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getClientByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__getClientByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__getClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *arg0` is an optional element *`<arg0>`* of XML schema type *`xsd:string`*
- `std::string *arg1` is an optional element *`<arg1>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getClientByNameAndPwd` are available:

- `ns2__getClientByNameAndPwd *soap_new_ns2__getClientByNameAndPwd(struct soap*)` managed allocation with default initialization
- `ns2__getClientByNameAndPwd *soap_new_ns2__getClientByNameAndPwd(struct soap*, int n)` managed allocation of array `ns2__getClientByNameAndPwd[n]`
- `ns2__getClientByNameAndPwd *soap_new_req_ns2__getClientByNameAndPwd(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getClientByNameAndPwd *soap_new_set_ns2__getClientByNameAndPwd(struct soap*, std::string *arg0, std::string *arg1)` managed allocation with public members assigned the values of these parameters
- `void ns2__getClientByNameAndPwd::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getClientByNameAndPwd(struct soap*, const ns2__getClientByNameAndPwd*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getClientByNameAndPwd(struct soap*, const char *URL, const ns2__getClientByNameAndPwd*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getClientByNameAndPwd(struct soap*, const char *URL, const ns2__getClientByNameAndPwd*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getClientByNameAndPwd(struct soap*, const char *URL, const ns2__getClientByNameAndPwd*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getClientByNameAndPwd(struct soap*, ns2__getClientByNameAndPwd*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getClientByNameAndPwd(struct soap*, const char *URL, ns2__getClientByNameAndPwd*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getClientByNameAndPwd(struct soap*, ns2__getClientByNameAndPwd*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__getClientByNameAndPwdResponse"></a>

### `ns2__getClientByNameAndPwdResponse`

This class is declared in [soap_head.h](soap_head.h) at line 329, is serialized as XML schema type *`ns2:getClientByNameAndPwdResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__getClientByNameAndPwdResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:client'
        ns2__client *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__getClientByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__getClientByNameAndPwdResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getClientByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__getClientByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__client *return_` is an optional element *`<return>`* of XML schema type *`ns2:client`*, where the type of this member is a pointer to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__getClientByNameAndPwdResponse` are available:

- `ns2__getClientByNameAndPwdResponse *soap_new_ns2__getClientByNameAndPwdResponse(struct soap*)` managed allocation with default initialization
- `ns2__getClientByNameAndPwdResponse *soap_new_ns2__getClientByNameAndPwdResponse(struct soap*, int n)` managed allocation of array `ns2__getClientByNameAndPwdResponse[n]`
- `ns2__getClientByNameAndPwdResponse *soap_new_req_ns2__getClientByNameAndPwdResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__getClientByNameAndPwdResponse *soap_new_set_ns2__getClientByNameAndPwdResponse(struct soap*, ns2__client *return_)` managed allocation with public members assigned the values of these parameters
- `void ns2__getClientByNameAndPwdResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__getClientByNameAndPwdResponse(struct soap*, const ns2__getClientByNameAndPwdResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__getClientByNameAndPwdResponse(struct soap*, const char *URL, const ns2__getClientByNameAndPwdResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__getClientByNameAndPwdResponse(struct soap*, const char *URL, const ns2__getClientByNameAndPwdResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__getClientByNameAndPwdResponse(struct soap*, const char *URL, const ns2__getClientByNameAndPwdResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__getClientByNameAndPwdResponse(struct soap*, ns2__getClientByNameAndPwdResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__getClientByNameAndPwdResponse(struct soap*, const char *URL, ns2__getClientByNameAndPwdResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__getClientByNameAndPwdResponse(struct soap*, ns2__getClientByNameAndPwdResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteShoppingCart"></a>

### `ns2__deleteShoppingCart`

This class is declared in [soap_head.h](soap_head.h) at line 331, is serialized as XML schema type *`ns2:deleteShoppingCart`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteShoppingCart {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShoppingCart
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShoppingCart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShoppingCart, default initialized and not managed by a soap context
        virtual ns2__deleteShoppingCart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShoppingCart); }
      public:
        /// Constructor with default initializations
        ns2__deleteShoppingCart() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__deleteShoppingCart() { }
        /// Friend allocator used by soap_new_ns2__deleteShoppingCart(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShoppingCart * SOAP_FMAC2 soap_instantiate_ns2__deleteShoppingCart(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__order *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:order`*, where the type of this member is a pointer to <code><a href="#ns2__order"> ns2__order </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteShoppingCart` are available:

- `ns2__deleteShoppingCart *soap_new_ns2__deleteShoppingCart(struct soap*)` managed allocation with default initialization
- `ns2__deleteShoppingCart *soap_new_ns2__deleteShoppingCart(struct soap*, int n)` managed allocation of array `ns2__deleteShoppingCart[n]`
- `ns2__deleteShoppingCart *soap_new_req_ns2__deleteShoppingCart(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteShoppingCart *soap_new_set_ns2__deleteShoppingCart(struct soap*, ns2__order *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteShoppingCart::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteShoppingCart(struct soap*, const ns2__deleteShoppingCart*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteShoppingCart(struct soap*, const char *URL, const ns2__deleteShoppingCart*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteShoppingCart(struct soap*, const char *URL, const ns2__deleteShoppingCart*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteShoppingCart(struct soap*, const char *URL, const ns2__deleteShoppingCart*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteShoppingCart(struct soap*, ns2__deleteShoppingCart*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteShoppingCart(struct soap*, const char *URL, ns2__deleteShoppingCart*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteShoppingCart(struct soap*, ns2__deleteShoppingCart*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__deleteShoppingCartResponse"></a>

### `ns2__deleteShoppingCartResponse`

This class is declared in [soap_head.h](soap_head.h) at line 333, is serialized as XML schema type *`ns2:deleteShoppingCartResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__deleteShoppingCartResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShoppingCartResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShoppingCartResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShoppingCartResponse, default initialized and not managed by a soap context
        virtual ns2__deleteShoppingCartResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShoppingCartResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteShoppingCartResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteShoppingCartResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteShoppingCartResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShoppingCartResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteShoppingCartResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__deleteShoppingCartResponse` are available:

- `ns2__deleteShoppingCartResponse *soap_new_ns2__deleteShoppingCartResponse(struct soap*)` managed allocation with default initialization
- `ns2__deleteShoppingCartResponse *soap_new_ns2__deleteShoppingCartResponse(struct soap*, int n)` managed allocation of array `ns2__deleteShoppingCartResponse[n]`
- `ns2__deleteShoppingCartResponse *soap_new_req_ns2__deleteShoppingCartResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__deleteShoppingCartResponse *soap_new_set_ns2__deleteShoppingCartResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__deleteShoppingCartResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__deleteShoppingCartResponse(struct soap*, const ns2__deleteShoppingCartResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__deleteShoppingCartResponse(struct soap*, const char *URL, const ns2__deleteShoppingCartResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__deleteShoppingCartResponse(struct soap*, const char *URL, const ns2__deleteShoppingCartResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__deleteShoppingCartResponse(struct soap*, const char *URL, const ns2__deleteShoppingCartResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__deleteShoppingCartResponse(struct soap*, ns2__deleteShoppingCartResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__deleteShoppingCartResponse(struct soap*, const char *URL, ns2__deleteShoppingCartResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__deleteShoppingCartResponse(struct soap*, ns2__deleteShoppingCartResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__InsertClient"></a>

### `ns2__InsertClient`

This class is declared in [soap_head.h](soap_head.h) at line 335, is serialized as XML schema type *`ns2:InsertClient`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__InsertClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertClient, default initialized and not managed by a soap context
        virtual ns2__InsertClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertClient); }
      public:
        /// Constructor with default initializations
        ns2__InsertClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__InsertClient() { }
        /// Friend allocator used by soap_new_ns2__InsertClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertClient * SOAP_FMAC2 soap_instantiate_ns2__InsertClient(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns2__client *arg0` is an optional element *`<arg0>`* of XML schema type *`ns2:client`*, where the type of this member is a pointer to <code><a href="#ns2__client"> ns2__client </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns2__InsertClient` are available:

- `ns2__InsertClient *soap_new_ns2__InsertClient(struct soap*)` managed allocation with default initialization
- `ns2__InsertClient *soap_new_ns2__InsertClient(struct soap*, int n)` managed allocation of array `ns2__InsertClient[n]`
- `ns2__InsertClient *soap_new_req_ns2__InsertClient(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__InsertClient *soap_new_set_ns2__InsertClient(struct soap*, ns2__client *arg0)` managed allocation with public members assigned the values of these parameters
- `void ns2__InsertClient::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__InsertClient(struct soap*, const ns2__InsertClient*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__InsertClient(struct soap*, const char *URL, const ns2__InsertClient*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__InsertClient(struct soap*, const char *URL, const ns2__InsertClient*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__InsertClient(struct soap*, const char *URL, const ns2__InsertClient*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__InsertClient(struct soap*, ns2__InsertClient*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__InsertClient(struct soap*, const char *URL, ns2__InsertClient*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__InsertClient(struct soap*, ns2__InsertClient*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__InsertClientResponse"></a>

### `ns2__InsertClientResponse`

This class is declared in [soap_head.h](soap_head.h) at line 337, is serialized as XML schema type *`ns2:InsertClientResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__InsertClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertClientResponse, default initialized and not managed by a soap context
        virtual ns2__InsertClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__InsertClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__InsertClientResponse() { }
        /// Friend allocator used by soap_new_ns2__InsertClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertClientResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertClientResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `struct soap *soap` the context that manages this object

The following operations on `ns2__InsertClientResponse` are available:

- `ns2__InsertClientResponse *soap_new_ns2__InsertClientResponse(struct soap*)` managed allocation with default initialization
- `ns2__InsertClientResponse *soap_new_ns2__InsertClientResponse(struct soap*, int n)` managed allocation of array `ns2__InsertClientResponse[n]`
- `ns2__InsertClientResponse *soap_new_req_ns2__InsertClientResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__InsertClientResponse *soap_new_set_ns2__InsertClientResponse(struct soap*)` managed allocation with public members assigned the values of these parameters
- `void ns2__InsertClientResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__InsertClientResponse(struct soap*, const ns2__InsertClientResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__InsertClientResponse(struct soap*, const char *URL, const ns2__InsertClientResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__InsertClientResponse(struct soap*, const char *URL, const ns2__InsertClientResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__InsertClientResponse(struct soap*, const char *URL, const ns2__InsertClientResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__InsertClientResponse(struct soap*, ns2__InsertClientResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__InsertClientResponse(struct soap*, const char *URL, ns2__InsertClientResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__InsertClientResponse(struct soap*, ns2__InsertClientResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__ns1__selectProductForUpdate"></a>

### `struct __ns1__selectProductForUpdate`

This struct is declared in [soap_head.h](soap_head.h) at line 2744, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__selectProductForUpdate()`.

[![][1] To top](#)


<a name="__ns1__addProduct"></a>

### `struct __ns1__addProduct`

This struct is declared in [soap_head.h](soap_head.h) at line 2811, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__addProduct()`.

[![][1] To top](#)


<a name="__ns1__deleteProductTypeByName"></a>

### `struct __ns1__deleteProductTypeByName`

This struct is declared in [soap_head.h](soap_head.h) at line 2878, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteProductTypeByName()`.

[![][1] To top](#)


<a name="__ns1__getOrderList"></a>

### `struct __ns1__getOrderList`

This struct is declared in [soap_head.h](soap_head.h) at line 2945, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getOrderList()`.

[![][1] To top](#)


<a name="__ns1__getShopByNameAndPwd"></a>

### `struct __ns1__getShopByNameAndPwd`

This struct is declared in [soap_head.h](soap_head.h) at line 3012, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getShopByNameAndPwd()`.

[![][1] To top](#)


<a name="__ns1__updateShop"></a>

### `struct __ns1__updateShop`

This struct is declared in [soap_head.h](soap_head.h) at line 3079, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__updateShop()`.

[![][1] To top](#)


<a name="__ns1__getProductListByInfo"></a>

### `struct __ns1__getProductListByInfo`

This struct is declared in [soap_head.h](soap_head.h) at line 3146, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getProductListByInfo()`.

[![][1] To top](#)


<a name="__ns1__getReadMessageFromShop"></a>

### `struct __ns1__getReadMessageFromShop`

This struct is declared in [soap_head.h](soap_head.h) at line 3213, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getReadMessageFromShop()`.

[![][1] To top](#)


<a name="__ns1__updateClient"></a>

### `struct __ns1__updateClient`

This struct is declared in [soap_head.h](soap_head.h) at line 3280, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__updateClient()`.

[![][1] To top](#)


<a name="__ns1__deleteProductByInfo"></a>

### `struct __ns1__deleteProductByInfo`

This struct is declared in [soap_head.h](soap_head.h) at line 3347, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteProductByInfo()`.

[![][1] To top](#)


<a name="__ns1__deleteClientByNameAndPwd"></a>

### `struct __ns1__deleteClientByNameAndPwd`

This struct is declared in [soap_head.h](soap_head.h) at line 3414, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteClientByNameAndPwd()`.

[![][1] To top](#)


<a name="__ns1__InsertShop"></a>

### `struct __ns1__InsertShop`

This struct is declared in [soap_head.h](soap_head.h) at line 3481, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__InsertShop()`.

[![][1] To top](#)


<a name="__ns1__updateMessageFromShop"></a>

### `struct __ns1__updateMessageFromShop`

This struct is declared in [soap_head.h](soap_head.h) at line 3548, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__updateMessageFromShop()`.

[![][1] To top](#)


<a name="__ns1__getProductTypeByProName"></a>

### `struct __ns1__getProductTypeByProName`

This struct is declared in [soap_head.h](soap_head.h) at line 3615, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getProductTypeByProName()`.

[![][1] To top](#)


<a name="__ns1__getClientList"></a>

### `struct __ns1__getClientList`

This struct is declared in [soap_head.h](soap_head.h) at line 3682, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getClientList()`.

[![][1] To top](#)


<a name="__ns1__purchaseProduct"></a>

### `struct __ns1__purchaseProduct`

This struct is declared in [soap_head.h](soap_head.h) at line 3749, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__purchaseProduct()`.

[![][1] To top](#)


<a name="__ns1__updateMessageFromClient"></a>

### `struct __ns1__updateMessageFromClient`

This struct is declared in [soap_head.h](soap_head.h) at line 3816, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__updateMessageFromClient()`.

[![][1] To top](#)


<a name="__ns1__getUnreadMessageFromClient"></a>

### `struct __ns1__getUnreadMessageFromClient`

This struct is declared in [soap_head.h](soap_head.h) at line 3883, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getUnreadMessageFromClient()`.

[![][1] To top](#)


<a name="__ns1__updateProductByInfo"></a>

### `struct __ns1__updateProductByInfo`

This struct is declared in [soap_head.h](soap_head.h) at line 3950, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__updateProductByInfo()`.

[![][1] To top](#)


<a name="__ns1__getMessageFromClient"></a>

### `struct __ns1__getMessageFromClient`

This struct is declared in [soap_head.h](soap_head.h) at line 4017, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getMessageFromClient()`.

[![][1] To top](#)


<a name="__ns1__addOrder"></a>

### `struct __ns1__addOrder`

This struct is declared in [soap_head.h](soap_head.h) at line 4084, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__addOrder()`.

[![][1] To top](#)


<a name="__ns1__deleteShopByNameAndPwd"></a>

### `struct __ns1__deleteShopByNameAndPwd`

This struct is declared in [soap_head.h](soap_head.h) at line 4151, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteShopByNameAndPwd()`.

[![][1] To top](#)


<a name="__ns1__getProductList"></a>

### `struct __ns1__getProductList`

This struct is declared in [soap_head.h](soap_head.h) at line 4218, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getProductList()`.

[![][1] To top](#)


<a name="__ns1__getOrderListHistory"></a>

### `struct __ns1__getOrderListHistory`

This struct is declared in [soap_head.h](soap_head.h) at line 4285, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getOrderListHistory()`.

[![][1] To top](#)


<a name="__ns1__getReadMessageFromClient"></a>

### `struct __ns1__getReadMessageFromClient`

This struct is declared in [soap_head.h](soap_head.h) at line 4352, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getReadMessageFromClient()`.

[![][1] To top](#)


<a name="__ns1__updateHistory"></a>

### `struct __ns1__updateHistory`

This struct is declared in [soap_head.h](soap_head.h) at line 4419, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__updateHistory()`.

[![][1] To top](#)


<a name="__ns1__InsertMessage"></a>

### `struct __ns1__InsertMessage`

This struct is declared in [soap_head.h](soap_head.h) at line 4486, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__InsertMessage()`.

[![][1] To top](#)


<a name="__ns1__getShopLikeList"></a>

### `struct __ns1__getShopLikeList`

This struct is declared in [soap_head.h](soap_head.h) at line 4553, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getShopLikeList()`.

[![][1] To top](#)


<a name="__ns1__getMessageFromShop"></a>

### `struct __ns1__getMessageFromShop`

This struct is declared in [soap_head.h](soap_head.h) at line 4620, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getMessageFromShop()`.

[![][1] To top](#)


<a name="__ns1__deleteMessageFromShop"></a>

### `struct __ns1__deleteMessageFromShop`

This struct is declared in [soap_head.h](soap_head.h) at line 4687, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteMessageFromShop()`.

[![][1] To top](#)


<a name="__ns1__getOrderLikeList"></a>

### `struct __ns1__getOrderLikeList`

This struct is declared in [soap_head.h](soap_head.h) at line 4754, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getOrderLikeList()`.

[![][1] To top](#)


<a name="__ns1__getUnreadMessageFromShop"></a>

### `struct __ns1__getUnreadMessageFromShop`

This struct is declared in [soap_head.h](soap_head.h) at line 4821, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getUnreadMessageFromShop()`.

[![][1] To top](#)


<a name="__ns1__getClientLikeList"></a>

### `struct __ns1__getClientLikeList`

This struct is declared in [soap_head.h](soap_head.h) at line 4888, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getClientLikeList()`.

[![][1] To top](#)


<a name="__ns1__getShopList"></a>

### `struct __ns1__getShopList`

This struct is declared in [soap_head.h](soap_head.h) at line 4955, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getShopList()`.

[![][1] To top](#)


<a name="__ns1__getOrderListByInfo"></a>

### `struct __ns1__getOrderListByInfo`

This struct is declared in [soap_head.h](soap_head.h) at line 5022, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getOrderListByInfo()`.

[![][1] To top](#)


<a name="__ns1__addProductType"></a>

### `struct __ns1__addProductType`

This struct is declared in [soap_head.h](soap_head.h) at line 5089, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__addProductType()`.

[![][1] To top](#)


<a name="__ns1__deleteMessageFromClient"></a>

### `struct __ns1__deleteMessageFromClient`

This struct is declared in [soap_head.h](soap_head.h) at line 5156, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteMessageFromClient()`.

[![][1] To top](#)


<a name="__ns1__getProductLikeList"></a>

### `struct __ns1__getProductLikeList`

This struct is declared in [soap_head.h](soap_head.h) at line 5223, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getProductLikeList()`.

[![][1] To top](#)


<a name="__ns1__getClientByNameAndPwd"></a>

### `struct __ns1__getClientByNameAndPwd`

This struct is declared in [soap_head.h](soap_head.h) at line 5290, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__getClientByNameAndPwd()`.

[![][1] To top](#)


<a name="__ns1__deleteShoppingCart"></a>

### `struct __ns1__deleteShoppingCart`

This struct is declared in [soap_head.h](soap_head.h) at line 5357, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__deleteShoppingCart()`.

[![][1] To top](#)


<a name="__ns1__InsertClient"></a>

### `struct __ns1__InsertClient`

This struct is declared in [soap_head.h](soap_head.h) at line 5424, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__InsertClient()`.

[![][1] To top](#)


<a name="SOAP_ENV__Header"></a>

### `struct SOAP_ENV__Header`

This struct is declared in [soap_head.h](soap_head.h) at line 5649, is the SOAP protocol *`<SOAP-ENV:Header>`* element with message-specific child elements that are mandatory to process when attributed with *`mustUnderstand="true"`*.  Headers are usually added and processed by plugins.  To remove the SOAP Header when sending or returning a message, set `soap->header = NULL`.  Use `soap_header(struct soap *soap)` to allocate a `struct SOAP_ENV__Header` which will be pointed to by `soap->header`, then initialize it with `soap_default_SOAP_ENV__Header(soap, soap->header)` and set one or more of its data members (if any):

*No SOAP headers are applicable*

This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Code"></a>

### `struct SOAP_ENV__Code`

This struct is declared in [soap_head.h](soap_head.h) at line 5649, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is the SOAP protocol *`<SOAP-ENV:Code>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Detail"></a>

### `struct SOAP_ENV__Detail`

This struct is declared in [soap_head.h](soap_head.h) at line 5649, is the SOAP protocol *`<SOAP-ENV:Detail>`* element with details returned by a service that triggered the error.  Fault details are added and processed by plugins by setting the `detail` (for SOAP 1.1) or `SOAP_ENV__Detail` (for SOAP 1.2) member of `struct SOAP_ENV__Fault` and then setting one ore more of the detail members:

- `char *__any` catch-all XML in literal XML string, see also <code><a href="#_XML"> _XML </a></code>
- `int __type` element *`<fault>`* serialized with C/C++ type `__type` = `SOAP_TYPE_<Type>`


This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Reason"></a>

### `struct SOAP_ENV__Reason`

This struct is declared in [soap_head.h](soap_head.h) at line 5649, is the SOAP protocol *`<SOAP-ENV:Reason>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Fault"></a>

### `struct SOAP_ENV__Fault`

This struct is declared in [soap_head.h](soap_head.h) at line 5649, is the SOAP protocol *`<SOAP-ENV:Fault>`* element with fault information and details returned by a service that triggered the error.  At the server side, a fault can be explicitly set within a service operation by calling and returning:

- `int soap_sender_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the sender is at fault (irrecoverable)
- `int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the receiver is at fault (recoverable, sender may retry)

A service operation may also return an HTTP status or error code (200 to 599).

At the client side the (proxy) call returns the error code which is also stored in `soap->error`.  The fault structure is pointed to by `soap->fault`.  The fault can be displayed with:

- `void soap_print_fault(struct soap *soap, FILE *fd)` display fault
- `void soap_print_fault_location(struct soap *soap, FILE *fd)` display the location of the fault in the XML message that caused it
- `void soap_sprint_fault(struct soap *soap, char *buf, size_t len)` write fault to buffer
- `void soap_stream_fault(struct soap *soap, std::ostream&)` write fault to stream
- `const char *soap_fault_subcode(struct soap *soap)` returns the SOAP Fault subcode QName string or NULL when absent
- `const char *soap_fault_string(struct soap *soap)` returns the SOAP Fault string/reason or NULL when absent
- `const char *soap_fault_detail(struct soap *soap)` returns the SOAP Fault detail XML string or NULL when absent
- `const char **soap_faultsubcode(struct soap *soap)` returns a pointer to the SOAP Fault to set this QName string
- `const char **soap_faultstring(struct soap *soap)` returns a pointer to the SOAP Fault string/reason to set this string
- `const char **soap_faultdetail(struct soap *soap)` returns a pointer to the SOAP Fault detail XML string to set this string or returns NULL when not accessible

This struct will be auto-generated when it is not explicitly declared in an interface header file and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


## Typedefs {#doc-typedefs}

A typedef type is serializable if its underlying base type is serializable.  Typedefs may declare custom serializers, meaning their underlying types are custom-serialized in XML using serialization rules that differ from the serialization rules of the underlying base type:
<table class="doxtable">
<tr><th> Typedef </th><th> Type </th><th> Declared </th><th> Serializable </th><th> Custom </th></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__decimal"> xsd__decimal </a></code></td><td><code> std::string </code></td><td> soap_head.h:153 </td><td> yes </td><td>  </td></tr>
</table>

<a name="_XML"></a>

### `_XML`

This typedef is internally generated and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_QName"></a>

### `_QName`

This typedef is internally generated and is a built-in string type to serialize a list of space-separated qualified names (*`xsd:QName`*), such that XML namespace prefixes are normalized to the XML prefixes defined in the [namespace table](#doc-namespaces) or replaced with "URI": when the namespace table has no prefix entry for the URI

[![][1] To top](#)


<a name="xsd__decimal"></a>

### `xsd__decimal`

This typedef is declared in [soap_head.h](soap_head.h) at line 153, is serialized as XML schema type *`xsd:decimal`* and has underlying base type `std::string`, which should be

- matching regex pattern "[-+]?(\d+|\d*\.\d*)"

[![][1] To top](#)


## Summary of Serializable Types {#doc-types}

Each serializable C/C++ *Type* with binding name *Name* has a set of auto-generated functions:

- `Type *soap_new_Name(struct soap*)` managed allocation and default initialization
- `Type *soap_new_Name(struct soap*, int n)` managed allocation and default initialization of an array `Type[n]`
- `void soap_default_Name(struct soap*, Type*)` initialize or reset non-class *Type* to default)
- `void Type::soap_default(struct soap*)` non-volatile class *Type* reset to default
- `Type *soap_dup_Name(struct soap*, Type *dst, const Type *src)` requires soapcpp2 option -Ec, deep copy `src` to `dst` managed by context or unmanaged when context is NULL, returning `dst` (if `dst` is NULL then allocates `dst` copy)
- `void soap_del_Name(struct soap*, Type*)` requires soapcpp2 option -Ec, deep delete *Type* which must be unmanaged
- `const char *soap_Name2s(struct soap*, Type)` primitive *Type* only, returns string-converted *Type* in temporary string buffer
- `int soap_s2Name(struct soap*, const char*, Type*)` primitive *Type* only, convert string to value, returns `SOAP_OK` or error code
- `int soap_write_Name(struct soap*, const Type*)` serialize *Type* to XML, returns `SOAP_OK` or error code
- `int soap_PUT_Name(struct soap*, const char *URL, const Type*)` REST PUT *Type* in XML, returns `SOAP_OK` or error code
- `int soap_PATCH_Name(struct soap*, const char *URL, const Type*)` REST PATCH *Type* in XML, returns `SOAP_OK` or error code
- `int soap_POST_send_Name(struct soap*, const char *URL, const Type*)` REST POST send *Type* in XML (MUST be followed by a `soap_POST_recv_OtherName`), returns `SOAP_OK` or error code
- `int soap_read_Name(struct soap*, Type*)` deserialize *Type* from XML, returns `SOAP_OK` or error code
- `int soap_GET_Name(struct soap*, const char *URL, Type*)` REST GET *Type* from XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_Name(struct soap*, Type*)` REST GET *Type* from XML (after a `soap_POST_send_OtherName`), returns `SOAP_OK` or error code
- `(Type *)soap_malloc(struct soap*, sizeof(Type))` raw managed allocation of primitive *Type* (types that are not structs or classes) without initialization
- `const char *soap_strdup(struct soap*, const char*)` managed allocation and duplication of string
- `const wchar_t *soap_wstrdup(struct soap*, const wchar_t*)` managed allocation and duplication of wide string

Each *Type* also has a unique type id `SOAP_TYPE_<Type>` that you can use to serialize `void*` in a struct/class by setting the `int __type` member to this type id. The unique type id is also used to distinguish derived class instances from base class instances by calling their `virtual soap_type()` methods that return this type id.

From the toolkit documentation:

- Set `soap->sendfd = fd` to serialize to an `int fd` file descriptor
- Set `soap->os = &os` to serialize to a `std::ostream os`
- Set `soap->recvfd = fd` to deserialize from an `int fd` file descriptor
- Set `soap->is = &is` to deserialize from a `std::istream`
- All managed allocated data is deleted by `soap_destroy(soap)` followed by `soap_end(soap)` with context `soap`

The table below lists the serializable types by *Type*, binding *Name*, *Kind*, and the XSD data binding type and/or element.  Pointers, arrays, and containers of these types are also serializable:

<table class="doxtable">
<tr><th> C/C++ Type </th><th> Name </th><th> Kind </th><th> XML schema name </th></tr>
<tr><td><code> char </code></td><td><code> byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> int </code></td><td><code> int </code></td><td> int </td><td> xsd:int </td></tr>
<tr><td><code> float </code></td><td><code> float </code></td><td> float </td><td> xsd:float </td></tr>
<tr><td><code> time_t </code></td><td><code> dateTime </code></td><td> time_t </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#ns2__InsertClientResponse"> ns2__InsertClientResponse </a></code></td><td><code> ns2__InsertClientResponse </code></td><td> class </td><td> ns2:InsertClientResponse </td></tr>
<tr><td><code><a href="#ns2__InsertClient"> ns2__InsertClient </a></code></td><td><code> ns2__InsertClient </code></td><td> class </td><td> ns2:InsertClient </td></tr>
<tr><td><code><a href="#ns2__deleteShoppingCartResponse"> ns2__deleteShoppingCartResponse </a></code></td><td><code> ns2__deleteShoppingCartResponse </code></td><td> class </td><td> ns2:deleteShoppingCartResponse </td></tr>
<tr><td><code><a href="#ns2__deleteShoppingCart"> ns2__deleteShoppingCart </a></code></td><td><code> ns2__deleteShoppingCart </code></td><td> class </td><td> ns2:deleteShoppingCart </td></tr>
<tr><td><code><a href="#ns2__getClientByNameAndPwdResponse"> ns2__getClientByNameAndPwdResponse </a></code></td><td><code> ns2__getClientByNameAndPwdResponse </code></td><td> class </td><td> ns2:getClientByNameAndPwdResponse </td></tr>
<tr><td><code><a href="#ns2__getClientByNameAndPwd"> ns2__getClientByNameAndPwd </a></code></td><td><code> ns2__getClientByNameAndPwd </code></td><td> class </td><td> ns2:getClientByNameAndPwd </td></tr>
<tr><td><code><a href="#ns2__getProductLikeListResponse"> ns2__getProductLikeListResponse </a></code></td><td><code> ns2__getProductLikeListResponse </code></td><td> class </td><td> ns2:getProductLikeListResponse </td></tr>
<tr><td><code><a href="#ns2__getProductLikeList"> ns2__getProductLikeList </a></code></td><td><code> ns2__getProductLikeList </code></td><td> class </td><td> ns2:getProductLikeList </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromClientResponse"> ns2__deleteMessageFromClientResponse </a></code></td><td><code> ns2__deleteMessageFromClientResponse </code></td><td> class </td><td> ns2:deleteMessageFromClientResponse </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromClient"> ns2__deleteMessageFromClient </a></code></td><td><code> ns2__deleteMessageFromClient </code></td><td> class </td><td> ns2:deleteMessageFromClient </td></tr>
<tr><td><code><a href="#ns2__addProductTypeResponse"> ns2__addProductTypeResponse </a></code></td><td><code> ns2__addProductTypeResponse </code></td><td> class </td><td> ns2:addProductTypeResponse </td></tr>
<tr><td><code><a href="#ns2__addProductType"> ns2__addProductType </a></code></td><td><code> ns2__addProductType </code></td><td> class </td><td> ns2:addProductType </td></tr>
<tr><td><code><a href="#ns2__getOrderListByInfoResponse"> ns2__getOrderListByInfoResponse </a></code></td><td><code> ns2__getOrderListByInfoResponse </code></td><td> class </td><td> ns2:getOrderListByInfoResponse </td></tr>
<tr><td><code><a href="#ns2__getOrderListByInfo"> ns2__getOrderListByInfo </a></code></td><td><code> ns2__getOrderListByInfo </code></td><td> class </td><td> ns2:getOrderListByInfo </td></tr>
<tr><td><code><a href="#ns2__getShopListResponse"> ns2__getShopListResponse </a></code></td><td><code> ns2__getShopListResponse </code></td><td> class </td><td> ns2:getShopListResponse </td></tr>
<tr><td><code><a href="#ns2__getShopList"> ns2__getShopList </a></code></td><td><code> ns2__getShopList </code></td><td> class </td><td> ns2:getShopList </td></tr>
<tr><td><code><a href="#ns2__getClientLikeListResponse"> ns2__getClientLikeListResponse </a></code></td><td><code> ns2__getClientLikeListResponse </code></td><td> class </td><td> ns2:getClientLikeListResponse </td></tr>
<tr><td><code><a href="#ns2__getClientLikeList"> ns2__getClientLikeList </a></code></td><td><code> ns2__getClientLikeList </code></td><td> class </td><td> ns2:getClientLikeList </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromShopResponse"> ns2__getUnreadMessageFromShopResponse </a></code></td><td><code> ns2__getUnreadMessageFromShopResponse </code></td><td> class </td><td> ns2:getUnreadMessageFromShopResponse </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromShop"> ns2__getUnreadMessageFromShop </a></code></td><td><code> ns2__getUnreadMessageFromShop </code></td><td> class </td><td> ns2:getUnreadMessageFromShop </td></tr>
<tr><td><code><a href="#ns2__getOrderLikeListResponse"> ns2__getOrderLikeListResponse </a></code></td><td><code> ns2__getOrderLikeListResponse </code></td><td> class </td><td> ns2:getOrderLikeListResponse </td></tr>
<tr><td><code><a href="#ns2__getOrderLikeList"> ns2__getOrderLikeList </a></code></td><td><code> ns2__getOrderLikeList </code></td><td> class </td><td> ns2:getOrderLikeList </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromShopResponse"> ns2__deleteMessageFromShopResponse </a></code></td><td><code> ns2__deleteMessageFromShopResponse </code></td><td> class </td><td> ns2:deleteMessageFromShopResponse </td></tr>
<tr><td><code><a href="#ns2__deleteMessageFromShop"> ns2__deleteMessageFromShop </a></code></td><td><code> ns2__deleteMessageFromShop </code></td><td> class </td><td> ns2:deleteMessageFromShop </td></tr>
<tr><td><code><a href="#ns2__getMessageFromShopResponse"> ns2__getMessageFromShopResponse </a></code></td><td><code> ns2__getMessageFromShopResponse </code></td><td> class </td><td> ns2:getMessageFromShopResponse </td></tr>
<tr><td><code><a href="#ns2__getMessageFromShop"> ns2__getMessageFromShop </a></code></td><td><code> ns2__getMessageFromShop </code></td><td> class </td><td> ns2:getMessageFromShop </td></tr>
<tr><td><code><a href="#ns2__getShopLikeListResponse"> ns2__getShopLikeListResponse </a></code></td><td><code> ns2__getShopLikeListResponse </code></td><td> class </td><td> ns2:getShopLikeListResponse </td></tr>
<tr><td><code><a href="#ns2__getShopLikeList"> ns2__getShopLikeList </a></code></td><td><code> ns2__getShopLikeList </code></td><td> class </td><td> ns2:getShopLikeList </td></tr>
<tr><td><code><a href="#ns2__InsertMessageResponse"> ns2__InsertMessageResponse </a></code></td><td><code> ns2__InsertMessageResponse </code></td><td> class </td><td> ns2:InsertMessageResponse </td></tr>
<tr><td><code><a href="#ns2__InsertMessage"> ns2__InsertMessage </a></code></td><td><code> ns2__InsertMessage </code></td><td> class </td><td> ns2:InsertMessage </td></tr>
<tr><td><code><a href="#ns2__updateHistoryResponse"> ns2__updateHistoryResponse </a></code></td><td><code> ns2__updateHistoryResponse </code></td><td> class </td><td> ns2:updateHistoryResponse </td></tr>
<tr><td><code><a href="#ns2__updateHistory"> ns2__updateHistory </a></code></td><td><code> ns2__updateHistory </code></td><td> class </td><td> ns2:updateHistory </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromClientResponse"> ns2__getReadMessageFromClientResponse </a></code></td><td><code> ns2__getReadMessageFromClientResponse </code></td><td> class </td><td> ns2:getReadMessageFromClientResponse </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromClient"> ns2__getReadMessageFromClient </a></code></td><td><code> ns2__getReadMessageFromClient </code></td><td> class </td><td> ns2:getReadMessageFromClient </td></tr>
<tr><td><code><a href="#ns2__getOrderListHistoryResponse"> ns2__getOrderListHistoryResponse </a></code></td><td><code> ns2__getOrderListHistoryResponse </code></td><td> class </td><td> ns2:getOrderListHistoryResponse </td></tr>
<tr><td><code><a href="#ns2__getOrderListHistory"> ns2__getOrderListHistory </a></code></td><td><code> ns2__getOrderListHistory </code></td><td> class </td><td> ns2:getOrderListHistory </td></tr>
<tr><td><code><a href="#ns2__getProductListResponse"> ns2__getProductListResponse </a></code></td><td><code> ns2__getProductListResponse </code></td><td> class </td><td> ns2:getProductListResponse </td></tr>
<tr><td><code><a href="#ns2__getProductList"> ns2__getProductList </a></code></td><td><code> ns2__getProductList </code></td><td> class </td><td> ns2:getProductList </td></tr>
<tr><td><code><a href="#ns2__deleteShopByNameAndPwdResponse"> ns2__deleteShopByNameAndPwdResponse </a></code></td><td><code> ns2__deleteShopByNameAndPwdResponse </code></td><td> class </td><td> ns2:deleteShopByNameAndPwdResponse </td></tr>
<tr><td><code><a href="#ns2__deleteShopByNameAndPwd"> ns2__deleteShopByNameAndPwd </a></code></td><td><code> ns2__deleteShopByNameAndPwd </code></td><td> class </td><td> ns2:deleteShopByNameAndPwd </td></tr>
<tr><td><code><a href="#ns2__addOrderResponse"> ns2__addOrderResponse </a></code></td><td><code> ns2__addOrderResponse </code></td><td> class </td><td> ns2:addOrderResponse </td></tr>
<tr><td><code><a href="#ns2__addOrder"> ns2__addOrder </a></code></td><td><code> ns2__addOrder </code></td><td> class </td><td> ns2:addOrder </td></tr>
<tr><td><code><a href="#ns2__getMessageFromClientResponse"> ns2__getMessageFromClientResponse </a></code></td><td><code> ns2__getMessageFromClientResponse </code></td><td> class </td><td> ns2:getMessageFromClientResponse </td></tr>
<tr><td><code><a href="#ns2__getMessageFromClient"> ns2__getMessageFromClient </a></code></td><td><code> ns2__getMessageFromClient </code></td><td> class </td><td> ns2:getMessageFromClient </td></tr>
<tr><td><code><a href="#ns2__updateProductByInfoResponse"> ns2__updateProductByInfoResponse </a></code></td><td><code> ns2__updateProductByInfoResponse </code></td><td> class </td><td> ns2:updateProductByInfoResponse </td></tr>
<tr><td><code><a href="#ns2__updateProductByInfo"> ns2__updateProductByInfo </a></code></td><td><code> ns2__updateProductByInfo </code></td><td> class </td><td> ns2:updateProductByInfo </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromClientResponse"> ns2__getUnreadMessageFromClientResponse </a></code></td><td><code> ns2__getUnreadMessageFromClientResponse </code></td><td> class </td><td> ns2:getUnreadMessageFromClientResponse </td></tr>
<tr><td><code><a href="#ns2__getUnreadMessageFromClient"> ns2__getUnreadMessageFromClient </a></code></td><td><code> ns2__getUnreadMessageFromClient </code></td><td> class </td><td> ns2:getUnreadMessageFromClient </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromClientResponse"> ns2__updateMessageFromClientResponse </a></code></td><td><code> ns2__updateMessageFromClientResponse </code></td><td> class </td><td> ns2:updateMessageFromClientResponse </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromClient"> ns2__updateMessageFromClient </a></code></td><td><code> ns2__updateMessageFromClient </code></td><td> class </td><td> ns2:updateMessageFromClient </td></tr>
<tr><td><code><a href="#ns2__purchaseProductResponse"> ns2__purchaseProductResponse </a></code></td><td><code> ns2__purchaseProductResponse </code></td><td> class </td><td> ns2:purchaseProductResponse </td></tr>
<tr><td><code><a href="#ns2__purchaseProduct"> ns2__purchaseProduct </a></code></td><td><code> ns2__purchaseProduct </code></td><td> class </td><td> ns2:purchaseProduct </td></tr>
<tr><td><code><a href="#ns2__getClientListResponse"> ns2__getClientListResponse </a></code></td><td><code> ns2__getClientListResponse </code></td><td> class </td><td> ns2:getClientListResponse </td></tr>
<tr><td><code><a href="#ns2__getClientList"> ns2__getClientList </a></code></td><td><code> ns2__getClientList </code></td><td> class </td><td> ns2:getClientList </td></tr>
<tr><td><code><a href="#ns2__productType"> ns2__productType </a></code></td><td><code> ns2__productType </code></td><td> class </td><td> ns2:productType </td></tr>
<tr><td><code><a href="#ns2__getProductTypeByProNameResponse"> ns2__getProductTypeByProNameResponse </a></code></td><td><code> ns2__getProductTypeByProNameResponse </code></td><td> class </td><td> ns2:getProductTypeByProNameResponse </td></tr>
<tr><td><code><a href="#ns2__getProductTypeByProName"> ns2__getProductTypeByProName </a></code></td><td><code> ns2__getProductTypeByProName </code></td><td> class </td><td> ns2:getProductTypeByProName </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromShopResponse"> ns2__updateMessageFromShopResponse </a></code></td><td><code> ns2__updateMessageFromShopResponse </code></td><td> class </td><td> ns2:updateMessageFromShopResponse </td></tr>
<tr><td><code><a href="#ns2__updateMessageFromShop"> ns2__updateMessageFromShop </a></code></td><td><code> ns2__updateMessageFromShop </code></td><td> class </td><td> ns2:updateMessageFromShop </td></tr>
<tr><td><code><a href="#ns2__InsertShopResponse"> ns2__InsertShopResponse </a></code></td><td><code> ns2__InsertShopResponse </code></td><td> class </td><td> ns2:InsertShopResponse </td></tr>
<tr><td><code><a href="#ns2__InsertShop"> ns2__InsertShop </a></code></td><td><code> ns2__InsertShop </code></td><td> class </td><td> ns2:InsertShop </td></tr>
<tr><td><code><a href="#ns2__deleteClientByNameAndPwdResponse"> ns2__deleteClientByNameAndPwdResponse </a></code></td><td><code> ns2__deleteClientByNameAndPwdResponse </code></td><td> class </td><td> ns2:deleteClientByNameAndPwdResponse </td></tr>
<tr><td><code><a href="#ns2__deleteClientByNameAndPwd"> ns2__deleteClientByNameAndPwd </a></code></td><td><code> ns2__deleteClientByNameAndPwd </code></td><td> class </td><td> ns2:deleteClientByNameAndPwd </td></tr>
<tr><td><code><a href="#ns2__deleteProductByInfoResponse"> ns2__deleteProductByInfoResponse </a></code></td><td><code> ns2__deleteProductByInfoResponse </code></td><td> class </td><td> ns2:deleteProductByInfoResponse </td></tr>
<tr><td><code><a href="#ns2__deleteProductByInfo"> ns2__deleteProductByInfo </a></code></td><td><code> ns2__deleteProductByInfo </code></td><td> class </td><td> ns2:deleteProductByInfo </td></tr>
<tr><td><code><a href="#ns2__updateClientResponse"> ns2__updateClientResponse </a></code></td><td><code> ns2__updateClientResponse </code></td><td> class </td><td> ns2:updateClientResponse </td></tr>
<tr><td><code><a href="#ns2__updateClient"> ns2__updateClient </a></code></td><td><code> ns2__updateClient </code></td><td> class </td><td> ns2:updateClient </td></tr>
<tr><td><code><a href="#ns2__message"> ns2__message </a></code></td><td><code> ns2__message </code></td><td> class </td><td> ns2:message </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromShopResponse"> ns2__getReadMessageFromShopResponse </a></code></td><td><code> ns2__getReadMessageFromShopResponse </code></td><td> class </td><td> ns2:getReadMessageFromShopResponse </td></tr>
<tr><td><code><a href="#ns2__client"> ns2__client </a></code></td><td><code> ns2__client </code></td><td> class </td><td> ns2:client </td></tr>
<tr><td><code><a href="#ns2__getReadMessageFromShop"> ns2__getReadMessageFromShop </a></code></td><td><code> ns2__getReadMessageFromShop </code></td><td> class </td><td> ns2:getReadMessageFromShop </td></tr>
<tr><td><code><a href="#ns2__getProductListByInfoResponse"> ns2__getProductListByInfoResponse </a></code></td><td><code> ns2__getProductListByInfoResponse </code></td><td> class </td><td> ns2:getProductListByInfoResponse </td></tr>
<tr><td><code><a href="#ns2__getProductListByInfo"> ns2__getProductListByInfo </a></code></td><td><code> ns2__getProductListByInfo </code></td><td> class </td><td> ns2:getProductListByInfo </td></tr>
<tr><td><code><a href="#ns2__updateShopResponse"> ns2__updateShopResponse </a></code></td><td><code> ns2__updateShopResponse </code></td><td> class </td><td> ns2:updateShopResponse </td></tr>
<tr><td><code><a href="#ns2__updateShop"> ns2__updateShop </a></code></td><td><code> ns2__updateShop </code></td><td> class </td><td> ns2:updateShop </td></tr>
<tr><td><code><a href="#ns2__shop"> ns2__shop </a></code></td><td><code> ns2__shop </code></td><td> class </td><td> ns2:shop </td></tr>
<tr><td><code><a href="#ns2__getShopByNameAndPwdResponse"> ns2__getShopByNameAndPwdResponse </a></code></td><td><code> ns2__getShopByNameAndPwdResponse </code></td><td> class </td><td> ns2:getShopByNameAndPwdResponse </td></tr>
<tr><td><code><a href="#ns2__getShopByNameAndPwd"> ns2__getShopByNameAndPwd </a></code></td><td><code> ns2__getShopByNameAndPwd </code></td><td> class </td><td> ns2:getShopByNameAndPwd </td></tr>
<tr><td><code><a href="#ns2__getOrderListResponse"> ns2__getOrderListResponse </a></code></td><td><code> ns2__getOrderListResponse </code></td><td> class </td><td> ns2:getOrderListResponse </td></tr>
<tr><td><code><a href="#ns2__order"> ns2__order </a></code></td><td><code> ns2__order </code></td><td> class </td><td> ns2:order </td></tr>
<tr><td><code><a href="#ns2__getOrderList"> ns2__getOrderList </a></code></td><td><code> ns2__getOrderList </code></td><td> class </td><td> ns2:getOrderList </td></tr>
<tr><td><code><a href="#ns2__deleteProductTypeByNameResponse"> ns2__deleteProductTypeByNameResponse </a></code></td><td><code> ns2__deleteProductTypeByNameResponse </code></td><td> class </td><td> ns2:deleteProductTypeByNameResponse </td></tr>
<tr><td><code><a href="#ns2__deleteProductTypeByName"> ns2__deleteProductTypeByName </a></code></td><td><code> ns2__deleteProductTypeByName </code></td><td> class </td><td> ns2:deleteProductTypeByName </td></tr>
<tr><td><code><a href="#ns2__addProductResponse"> ns2__addProductResponse </a></code></td><td><code> ns2__addProductResponse </code></td><td> class </td><td> ns2:addProductResponse </td></tr>
<tr><td><code><a href="#ns2__addProduct"> ns2__addProduct </a></code></td><td><code> ns2__addProduct </code></td><td> class </td><td> ns2:addProduct </td></tr>
<tr><td><code><a href="#ns2__product"> ns2__product </a></code></td><td><code> ns2__product </code></td><td> class </td><td> ns2:product </td></tr>
<tr><td><code><a href="#ns2__selectProductForUpdateResponse"> ns2__selectProductForUpdateResponse </a></code></td><td><code> ns2__selectProductForUpdateResponse </code></td><td> class </td><td> ns2:selectProductForUpdateResponse </td></tr>
<tr><td><code><a href="#ns2__selectProductForUpdate"> ns2__selectProductForUpdate </a></code></td><td><code> ns2__selectProductForUpdate </code></td><td> class </td><td> ns2:selectProductForUpdate </td></tr>
<tr><td><code> xsd__decimal </code></td><td><code> xsd__decimal </code></td><td> std::string </td><td> xsd:decimal </td></tr>
<tr><td><code> std::string </code></td><td><code> std__string </code></td><td> std::string </td><td> xsd:string </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td><code> SOAP_ENV__Fault </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td><code> SOAP_ENV__Reason </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td><code> SOAP_ENV__Detail </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td><code> SOAP_ENV__Code </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td><code> SOAP_ENV__Header </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> _QName </code></td><td> string </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> _XML </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code> char * </code></td><td><code> string </code></td><td> string </td><td> xsd:string </td></tr>
<tr><td><code> std::vector<ns2__shop *>  </code></td><td><code> std__vectorTemplateOfPointerTons2__shop </code></td><td> container </td><td> ns2:shop </td></tr>
<tr><td><code> std::vector<ns2__client *>  </code></td><td><code> std__vectorTemplateOfPointerTons2__client </code></td><td> container </td><td> ns2:client </td></tr>
<tr><td><code> std::vector<ns2__productType *>  </code></td><td><code> std__vectorTemplateOfPointerTons2__productType </code></td><td> container </td><td> ns2:productType </td></tr>
<tr><td><code> std::vector<ns2__message *>  </code></td><td><code> std__vectorTemplateOfPointerTons2__message </code></td><td> container </td><td> ns2:message </td></tr>
<tr><td><code> std::vector<ns2__product *>  </code></td><td><code> std__vectorTemplateOfPointerTons2__product </code></td><td> container </td><td> ns2:product </td></tr>
<tr><td><code> std::vector<ns2__order *>  </code></td><td><code> std__vectorTemplateOfPointerTons2__order </code></td><td> container </td><td> ns2:order </td></tr>
</table>

[![][1] To top](#)


## Web Client Proxy Class WholeMapperSoapBindingProxy {#doc-client}

This client proxy class is declared in [soapWholeMapperSoapBindingProxy.h](soapWholeMapperSoapBindingProxy.h) and defined in [soapWholeMapperSoapBindingProxy.cpp](soapWholeMapperSoapBindingProxy.cpp):

    class SOAP_CMAC WholeMapperSoapBindingProxy {
      public:
        /// Context to manage proxy IO and data
        struct soap *soap;
        /// flag indicating that this context is owned by this proxy and should be deleted by the destructor
        bool soap_own;
        /// Endpoint URL of service 'WholeMapperSoapBindingProxy' (change as needed)
        const char *soap_endpoint;
        /// Variables globally declared in soap_head.h, if any
        /// Construct a proxy with new managing context
        WholeMapperSoapBindingProxy();
        /// Copy constructor
        WholeMapperSoapBindingProxy(const WholeMapperSoapBindingProxy& rhs);
        /// Construct proxy given a shared managing context
        WholeMapperSoapBindingProxy(struct soap*);
        /// Construct proxy given a shared managing context and endpoint URL
        WholeMapperSoapBindingProxy(struct soap*, const char *soap_endpoint_url);
        /// Constructor taking an endpoint URL
        WholeMapperSoapBindingProxy(const char *soap_endpoint_url);
        /// Constructor taking input and output mode flags for the new managing context
        WholeMapperSoapBindingProxy(soap_mode iomode);
        /// Constructor taking endpoint URL and input and output mode flags for the new managing context
        WholeMapperSoapBindingProxy(const char *soap_endpoint_url, soap_mode iomode);
        /// Constructor taking input and output mode flags for the new managing context
        WholeMapperSoapBindingProxy(soap_mode imode, soap_mode omode);
        /// Destructor deletes deserialized data and its managing context, when the context was allocated by the constructor
        virtual ~WholeMapperSoapBindingProxy();
        /// Initializer used by constructors
        virtual void WholeMapperSoapBindingProxy_init(soap_mode imode, soap_mode omode);
        /// Return a copy that has a new managing context with the same engine state
        virtual WholeMapperSoapBindingProxy *copy();
        /// Copy assignment
        WholeMapperSoapBindingProxy& operator=(const WholeMapperSoapBindingProxy&);
        /// Delete all deserialized data (uses soap_destroy() and soap_end())
        virtual void destroy();
        /// Delete all deserialized data and reset to default
        virtual void reset();
        /// Disables and removes SOAP Header from message by setting soap->header = NULL
        virtual void soap_noheader();
        /// Get SOAP Header structure (i.e. soap->header, which is NULL when absent)
        virtual ::SOAP_ENV__Header *soap_header();
        /// Get SOAP Fault structure (i.e. soap->fault, which is NULL when absent)
        virtual ::SOAP_ENV__Fault *soap_fault();
        /// Get SOAP Fault subcode QName string (NULL when absent)
        virtual const char *soap_fault_subcode();
        /// Get SOAP Fault string/reason (NULL when absent)
        virtual const char *soap_fault_string();
        /// Get SOAP Fault detail XML string (NULL when absent)
        virtual const char *soap_fault_detail();
        /// Close connection (normally automatic, except for send_X ops)
        virtual int soap_close_socket();
        /// Force close connection (can kill a thread blocked on IO)
        virtual int soap_force_close_socket();
        /// Print fault
        virtual void soap_print_fault(FILE*);
    #ifndef WITH_LEAN
    #ifndef WITH_COMPAT
        /// Print fault to stream
        virtual void soap_stream_fault(std::ostream&);
    #endif
        /// Write fault to buffer
        virtual char *soap_sprint_fault(char *buf, size_t len);
    #endif
        //
        /// Web service synchronous operation 'selectProductForUpdate' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int selectProductForUpdate(ns2__selectProductForUpdate *ns2__selectProductForUpdate_, ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_) { return this->selectProductForUpdate(NULL, NULL, ns2__selectProductForUpdate_, ns2__selectProductForUpdateResponse_); }
        /// Web service synchronous operation 'selectProductForUpdate' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int selectProductForUpdate(const char *soap_endpoint_url, const char *soap_action, ns2__selectProductForUpdate *ns2__selectProductForUpdate_, ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_) { return this->send_selectProductForUpdate(soap_endpoint_url, soap_action, ns2__selectProductForUpdate_) || this->recv_selectProductForUpdate(ns2__selectProductForUpdateResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_selectProductForUpdate' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_selectProductForUpdate(const char *soap_endpoint_url, const char *soap_action, ns2__selectProductForUpdate *ns2__selectProductForUpdate_);
        /// Web service asynchronous operation 'recv_selectProductForUpdate' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_selectProductForUpdate(ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_);
        //
        /// Web service synchronous operation 'addProduct' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int addProduct(ns2__addProduct *ns2__addProduct_, ns2__addProductResponse &ns2__addProductResponse_) { return this->addProduct(NULL, NULL, ns2__addProduct_, ns2__addProductResponse_); }
        /// Web service synchronous operation 'addProduct' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int addProduct(const char *soap_endpoint_url, const char *soap_action, ns2__addProduct *ns2__addProduct_, ns2__addProductResponse &ns2__addProductResponse_) { return this->send_addProduct(soap_endpoint_url, soap_action, ns2__addProduct_) || this->recv_addProduct(ns2__addProductResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_addProduct' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_addProduct(const char *soap_endpoint_url, const char *soap_action, ns2__addProduct *ns2__addProduct_);
        /// Web service asynchronous operation 'recv_addProduct' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_addProduct(ns2__addProductResponse &ns2__addProductResponse_);
        //
        /// Web service synchronous operation 'deleteProductTypeByName' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductTypeByName(ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_, ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_) { return this->deleteProductTypeByName(NULL, NULL, ns2__deleteProductTypeByName_, ns2__deleteProductTypeByNameResponse_); }
        /// Web service synchronous operation 'deleteProductTypeByName' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductTypeByName(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_, ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_) { return this->send_deleteProductTypeByName(soap_endpoint_url, soap_action, ns2__deleteProductTypeByName_) || this->recv_deleteProductTypeByName(ns2__deleteProductTypeByNameResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteProductTypeByName' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteProductTypeByName(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_);
        /// Web service asynchronous operation 'recv_deleteProductTypeByName' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteProductTypeByName(ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_);
        //
        /// Web service synchronous operation 'getOrderList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderList(ns2__getOrderList *ns2__getOrderList_, ns2__getOrderListResponse &ns2__getOrderListResponse_) { return this->getOrderList(NULL, NULL, ns2__getOrderList_, ns2__getOrderListResponse_); }
        /// Web service synchronous operation 'getOrderList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderList *ns2__getOrderList_, ns2__getOrderListResponse &ns2__getOrderListResponse_) { return this->send_getOrderList(soap_endpoint_url, soap_action, ns2__getOrderList_) || this->recv_getOrderList(ns2__getOrderListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderList *ns2__getOrderList_);
        /// Web service asynchronous operation 'recv_getOrderList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderList(ns2__getOrderListResponse &ns2__getOrderListResponse_);
        //
        /// Web service synchronous operation 'getShopByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getShopByNameAndPwd(ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_, ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_) { return this->getShopByNameAndPwd(NULL, NULL, ns2__getShopByNameAndPwd_, ns2__getShopByNameAndPwdResponse_); }
        /// Web service synchronous operation 'getShopByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_, ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_) { return this->send_getShopByNameAndPwd(soap_endpoint_url, soap_action, ns2__getShopByNameAndPwd_) || this->recv_getShopByNameAndPwd(ns2__getShopByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getShopByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_);
        /// Web service asynchronous operation 'recv_getShopByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getShopByNameAndPwd(ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_);
        //
        /// Web service synchronous operation 'updateShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateShop(ns2__updateShop *ns2__updateShop_, ns2__updateShopResponse &ns2__updateShopResponse_) { return this->updateShop(NULL, NULL, ns2__updateShop_, ns2__updateShopResponse_); }
        /// Web service synchronous operation 'updateShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateShop *ns2__updateShop_, ns2__updateShopResponse &ns2__updateShopResponse_) { return this->send_updateShop(soap_endpoint_url, soap_action, ns2__updateShop_) || this->recv_updateShop(ns2__updateShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateShop *ns2__updateShop_);
        /// Web service asynchronous operation 'recv_updateShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateShop(ns2__updateShopResponse &ns2__updateShopResponse_);
        //
        /// Web service synchronous operation 'getProductListByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductListByInfo(ns2__getProductListByInfo *ns2__getProductListByInfo_, ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_) { return this->getProductListByInfo(NULL, NULL, ns2__getProductListByInfo_, ns2__getProductListByInfoResponse_); }
        /// Web service synchronous operation 'getProductListByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getProductListByInfo *ns2__getProductListByInfo_, ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_) { return this->send_getProductListByInfo(soap_endpoint_url, soap_action, ns2__getProductListByInfo_) || this->recv_getProductListByInfo(ns2__getProductListByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductListByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getProductListByInfo *ns2__getProductListByInfo_);
        /// Web service asynchronous operation 'recv_getProductListByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductListByInfo(ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_);
        //
        /// Web service synchronous operation 'getReadMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromShop(ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_, ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_) { return this->getReadMessageFromShop(NULL, NULL, ns2__getReadMessageFromShop_, ns2__getReadMessageFromShopResponse_); }
        /// Web service synchronous operation 'getReadMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_, ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_) { return this->send_getReadMessageFromShop(soap_endpoint_url, soap_action, ns2__getReadMessageFromShop_) || this->recv_getReadMessageFromShop(ns2__getReadMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getReadMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getReadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_);
        /// Web service asynchronous operation 'recv_getReadMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getReadMessageFromShop(ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_);
        //
        /// Web service synchronous operation 'updateClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateClient(ns2__updateClient *ns2__updateClient_, ns2__updateClientResponse &ns2__updateClientResponse_) { return this->updateClient(NULL, NULL, ns2__updateClient_, ns2__updateClientResponse_); }
        /// Web service synchronous operation 'updateClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateClient *ns2__updateClient_, ns2__updateClientResponse &ns2__updateClientResponse_) { return this->send_updateClient(soap_endpoint_url, soap_action, ns2__updateClient_) || this->recv_updateClient(ns2__updateClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateClient *ns2__updateClient_);
        /// Web service asynchronous operation 'recv_updateClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateClient(ns2__updateClientResponse &ns2__updateClientResponse_);
        //
        /// Web service synchronous operation 'deleteProductByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductByInfo(ns2__deleteProductByInfo *ns2__deleteProductByInfo_, ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_) { return this->deleteProductByInfo(NULL, NULL, ns2__deleteProductByInfo_, ns2__deleteProductByInfoResponse_); }
        /// Web service synchronous operation 'deleteProductByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductByInfo *ns2__deleteProductByInfo_, ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_) { return this->send_deleteProductByInfo(soap_endpoint_url, soap_action, ns2__deleteProductByInfo_) || this->recv_deleteProductByInfo(ns2__deleteProductByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteProductByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductByInfo *ns2__deleteProductByInfo_);
        /// Web service asynchronous operation 'recv_deleteProductByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteProductByInfo(ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_);
        //
        /// Web service synchronous operation 'deleteClientByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteClientByNameAndPwd(ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_, ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_) { return this->deleteClientByNameAndPwd(NULL, NULL, ns2__deleteClientByNameAndPwd_, ns2__deleteClientByNameAndPwdResponse_); }
        /// Web service synchronous operation 'deleteClientByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_, ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_) { return this->send_deleteClientByNameAndPwd(soap_endpoint_url, soap_action, ns2__deleteClientByNameAndPwd_) || this->recv_deleteClientByNameAndPwd(ns2__deleteClientByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteClientByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_);
        /// Web service asynchronous operation 'recv_deleteClientByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteClientByNameAndPwd(ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_);
        //
        /// Web service synchronous operation 'InsertShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int InsertShop(ns2__InsertShop *ns2__InsertShop_, ns2__InsertShopResponse &ns2__InsertShopResponse_) { return this->InsertShop(NULL, NULL, ns2__InsertShop_, ns2__InsertShopResponse_); }
        /// Web service synchronous operation 'InsertShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int InsertShop(const char *soap_endpoint_url, const char *soap_action, ns2__InsertShop *ns2__InsertShop_, ns2__InsertShopResponse &ns2__InsertShopResponse_) { return this->send_InsertShop(soap_endpoint_url, soap_action, ns2__InsertShop_) || this->recv_InsertShop(ns2__InsertShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_InsertShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_InsertShop(const char *soap_endpoint_url, const char *soap_action, ns2__InsertShop *ns2__InsertShop_);
        /// Web service asynchronous operation 'recv_InsertShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_InsertShop(ns2__InsertShopResponse &ns2__InsertShopResponse_);
        //
        /// Web service synchronous operation 'updateMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromShop(ns2__updateMessageFromShop *ns2__updateMessageFromShop_, ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_) { return this->updateMessageFromShop(NULL, NULL, ns2__updateMessageFromShop_, ns2__updateMessageFromShopResponse_); }
        /// Web service synchronous operation 'updateMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromShop *ns2__updateMessageFromShop_, ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_) { return this->send_updateMessageFromShop(soap_endpoint_url, soap_action, ns2__updateMessageFromShop_) || this->recv_updateMessageFromShop(ns2__updateMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromShop *ns2__updateMessageFromShop_);
        /// Web service asynchronous operation 'recv_updateMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateMessageFromShop(ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_);
        //
        /// Web service synchronous operation 'getProductTypeByProName' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductTypeByProName(ns2__getProductTypeByProName *ns2__getProductTypeByProName_, ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_) { return this->getProductTypeByProName(NULL, NULL, ns2__getProductTypeByProName_, ns2__getProductTypeByProNameResponse_); }
        /// Web service synchronous operation 'getProductTypeByProName' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductTypeByProName(const char *soap_endpoint_url, const char *soap_action, ns2__getProductTypeByProName *ns2__getProductTypeByProName_, ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_) { return this->send_getProductTypeByProName(soap_endpoint_url, soap_action, ns2__getProductTypeByProName_) || this->recv_getProductTypeByProName(ns2__getProductTypeByProNameResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductTypeByProName' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductTypeByProName(const char *soap_endpoint_url, const char *soap_action, ns2__getProductTypeByProName *ns2__getProductTypeByProName_);
        /// Web service asynchronous operation 'recv_getProductTypeByProName' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductTypeByProName(ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_);
        //
        /// Web service synchronous operation 'getClientList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getClientList(ns2__getClientList *ns2__getClientList_, ns2__getClientListResponse &ns2__getClientListResponse_) { return this->getClientList(NULL, NULL, ns2__getClientList_, ns2__getClientListResponse_); }
        /// Web service synchronous operation 'getClientList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getClientList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientList *ns2__getClientList_, ns2__getClientListResponse &ns2__getClientListResponse_) { return this->send_getClientList(soap_endpoint_url, soap_action, ns2__getClientList_) || this->recv_getClientList(ns2__getClientListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getClientList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getClientList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientList *ns2__getClientList_);
        /// Web service asynchronous operation 'recv_getClientList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getClientList(ns2__getClientListResponse &ns2__getClientListResponse_);
        //
        /// Web service synchronous operation 'purchaseProduct' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int purchaseProduct(ns2__purchaseProduct *ns2__purchaseProduct_, ns2__purchaseProductResponse &ns2__purchaseProductResponse_) { return this->purchaseProduct(NULL, NULL, ns2__purchaseProduct_, ns2__purchaseProductResponse_); }
        /// Web service synchronous operation 'purchaseProduct' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int purchaseProduct(const char *soap_endpoint_url, const char *soap_action, ns2__purchaseProduct *ns2__purchaseProduct_, ns2__purchaseProductResponse &ns2__purchaseProductResponse_) { return this->send_purchaseProduct(soap_endpoint_url, soap_action, ns2__purchaseProduct_) || this->recv_purchaseProduct(ns2__purchaseProductResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_purchaseProduct' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_purchaseProduct(const char *soap_endpoint_url, const char *soap_action, ns2__purchaseProduct *ns2__purchaseProduct_);
        /// Web service asynchronous operation 'recv_purchaseProduct' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_purchaseProduct(ns2__purchaseProductResponse &ns2__purchaseProductResponse_);
        //
        /// Web service synchronous operation 'updateMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromClient(ns2__updateMessageFromClient *ns2__updateMessageFromClient_, ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_) { return this->updateMessageFromClient(NULL, NULL, ns2__updateMessageFromClient_, ns2__updateMessageFromClientResponse_); }
        /// Web service synchronous operation 'updateMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromClient *ns2__updateMessageFromClient_, ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_) { return this->send_updateMessageFromClient(soap_endpoint_url, soap_action, ns2__updateMessageFromClient_) || this->recv_updateMessageFromClient(ns2__updateMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromClient *ns2__updateMessageFromClient_);
        /// Web service asynchronous operation 'recv_updateMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateMessageFromClient(ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_);
        //
        /// Web service synchronous operation 'getUnreadMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromClient(ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_, ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_) { return this->getUnreadMessageFromClient(NULL, NULL, ns2__getUnreadMessageFromClient_, ns2__getUnreadMessageFromClientResponse_); }
        /// Web service synchronous operation 'getUnreadMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_, ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_) { return this->send_getUnreadMessageFromClient(soap_endpoint_url, soap_action, ns2__getUnreadMessageFromClient_) || this->recv_getUnreadMessageFromClient(ns2__getUnreadMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getUnreadMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getUnreadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_);
        /// Web service asynchronous operation 'recv_getUnreadMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getUnreadMessageFromClient(ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_);
        //
        /// Web service synchronous operation 'updateProductByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateProductByInfo(ns2__updateProductByInfo *ns2__updateProductByInfo_, ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_) { return this->updateProductByInfo(NULL, NULL, ns2__updateProductByInfo_, ns2__updateProductByInfoResponse_); }
        /// Web service synchronous operation 'updateProductByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__updateProductByInfo *ns2__updateProductByInfo_, ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_) { return this->send_updateProductByInfo(soap_endpoint_url, soap_action, ns2__updateProductByInfo_) || this->recv_updateProductByInfo(ns2__updateProductByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateProductByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__updateProductByInfo *ns2__updateProductByInfo_);
        /// Web service asynchronous operation 'recv_updateProductByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateProductByInfo(ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_);
        //
        /// Web service synchronous operation 'getMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromClient(ns2__getMessageFromClient *ns2__getMessageFromClient_, ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_) { return this->getMessageFromClient(NULL, NULL, ns2__getMessageFromClient_, ns2__getMessageFromClientResponse_); }
        /// Web service synchronous operation 'getMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromClient *ns2__getMessageFromClient_, ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_) { return this->send_getMessageFromClient(soap_endpoint_url, soap_action, ns2__getMessageFromClient_) || this->recv_getMessageFromClient(ns2__getMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromClient *ns2__getMessageFromClient_);
        /// Web service asynchronous operation 'recv_getMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getMessageFromClient(ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_);
        //
        /// Web service synchronous operation 'addOrder' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int addOrder(ns2__addOrder *ns2__addOrder_, ns2__addOrderResponse &ns2__addOrderResponse_) { return this->addOrder(NULL, NULL, ns2__addOrder_, ns2__addOrderResponse_); }
        /// Web service synchronous operation 'addOrder' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int addOrder(const char *soap_endpoint_url, const char *soap_action, ns2__addOrder *ns2__addOrder_, ns2__addOrderResponse &ns2__addOrderResponse_) { return this->send_addOrder(soap_endpoint_url, soap_action, ns2__addOrder_) || this->recv_addOrder(ns2__addOrderResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_addOrder' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_addOrder(const char *soap_endpoint_url, const char *soap_action, ns2__addOrder *ns2__addOrder_);
        /// Web service asynchronous operation 'recv_addOrder' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_addOrder(ns2__addOrderResponse &ns2__addOrderResponse_);
        //
        /// Web service synchronous operation 'deleteShopByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShopByNameAndPwd(ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_, ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_) { return this->deleteShopByNameAndPwd(NULL, NULL, ns2__deleteShopByNameAndPwd_, ns2__deleteShopByNameAndPwdResponse_); }
        /// Web service synchronous operation 'deleteShopByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_, ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_) { return this->send_deleteShopByNameAndPwd(soap_endpoint_url, soap_action, ns2__deleteShopByNameAndPwd_) || this->recv_deleteShopByNameAndPwd(ns2__deleteShopByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteShopByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_);
        /// Web service asynchronous operation 'recv_deleteShopByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteShopByNameAndPwd(ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_);
        //
        /// Web service synchronous operation 'getProductList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductList(ns2__getProductList *ns2__getProductList_, ns2__getProductListResponse &ns2__getProductListResponse_) { return this->getProductList(NULL, NULL, ns2__getProductList_, ns2__getProductListResponse_); }
        /// Web service synchronous operation 'getProductList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductList *ns2__getProductList_, ns2__getProductListResponse &ns2__getProductListResponse_) { return this->send_getProductList(soap_endpoint_url, soap_action, ns2__getProductList_) || this->recv_getProductList(ns2__getProductListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductList *ns2__getProductList_);
        /// Web service asynchronous operation 'recv_getProductList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductList(ns2__getProductListResponse &ns2__getProductListResponse_);
        //
        /// Web service synchronous operation 'getOrderListHistory' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListHistory(ns2__getOrderListHistory *ns2__getOrderListHistory_, ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_) { return this->getOrderListHistory(NULL, NULL, ns2__getOrderListHistory_, ns2__getOrderListHistoryResponse_); }
        /// Web service synchronous operation 'getOrderListHistory' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListHistory(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListHistory *ns2__getOrderListHistory_, ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_) { return this->send_getOrderListHistory(soap_endpoint_url, soap_action, ns2__getOrderListHistory_) || this->recv_getOrderListHistory(ns2__getOrderListHistoryResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderListHistory' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderListHistory(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListHistory *ns2__getOrderListHistory_);
        /// Web service asynchronous operation 'recv_getOrderListHistory' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderListHistory(ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_);
        //
        /// Web service synchronous operation 'getReadMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromClient(ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_, ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_) { return this->getReadMessageFromClient(NULL, NULL, ns2__getReadMessageFromClient_, ns2__getReadMessageFromClientResponse_); }
        /// Web service synchronous operation 'getReadMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_, ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_) { return this->send_getReadMessageFromClient(soap_endpoint_url, soap_action, ns2__getReadMessageFromClient_) || this->recv_getReadMessageFromClient(ns2__getReadMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getReadMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getReadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_);
        /// Web service asynchronous operation 'recv_getReadMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getReadMessageFromClient(ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_);
        //
        /// Web service synchronous operation 'updateHistory' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateHistory(ns2__updateHistory *ns2__updateHistory_, ns2__updateHistoryResponse &ns2__updateHistoryResponse_) { return this->updateHistory(NULL, NULL, ns2__updateHistory_, ns2__updateHistoryResponse_); }
        /// Web service synchronous operation 'updateHistory' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateHistory(const char *soap_endpoint_url, const char *soap_action, ns2__updateHistory *ns2__updateHistory_, ns2__updateHistoryResponse &ns2__updateHistoryResponse_) { return this->send_updateHistory(soap_endpoint_url, soap_action, ns2__updateHistory_) || this->recv_updateHistory(ns2__updateHistoryResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateHistory' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateHistory(const char *soap_endpoint_url, const char *soap_action, ns2__updateHistory *ns2__updateHistory_);
        /// Web service asynchronous operation 'recv_updateHistory' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateHistory(ns2__updateHistoryResponse &ns2__updateHistoryResponse_);
        //
        /// Web service synchronous operation 'InsertMessage' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int InsertMessage(ns2__InsertMessage *ns2__InsertMessage_, ns2__InsertMessageResponse &ns2__InsertMessageResponse_) { return this->InsertMessage(NULL, NULL, ns2__InsertMessage_, ns2__InsertMessageResponse_); }
        /// Web service synchronous operation 'InsertMessage' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int InsertMessage(const char *soap_endpoint_url, const char *soap_action, ns2__InsertMessage *ns2__InsertMessage_, ns2__InsertMessageResponse &ns2__InsertMessageResponse_) { return this->send_InsertMessage(soap_endpoint_url, soap_action, ns2__InsertMessage_) || this->recv_InsertMessage(ns2__InsertMessageResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_InsertMessage' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_InsertMessage(const char *soap_endpoint_url, const char *soap_action, ns2__InsertMessage *ns2__InsertMessage_);
        /// Web service asynchronous operation 'recv_InsertMessage' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_InsertMessage(ns2__InsertMessageResponse &ns2__InsertMessageResponse_);
        //
        /// Web service synchronous operation 'getShopLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getShopLikeList(ns2__getShopLikeList *ns2__getShopLikeList_, ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_) { return this->getShopLikeList(NULL, NULL, ns2__getShopLikeList_, ns2__getShopLikeListResponse_); }
        /// Web service synchronous operation 'getShopLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getShopLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopLikeList *ns2__getShopLikeList_, ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_) { return this->send_getShopLikeList(soap_endpoint_url, soap_action, ns2__getShopLikeList_) || this->recv_getShopLikeList(ns2__getShopLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getShopLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getShopLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopLikeList *ns2__getShopLikeList_);
        /// Web service asynchronous operation 'recv_getShopLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getShopLikeList(ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_);
        //
        /// Web service synchronous operation 'getMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromShop(ns2__getMessageFromShop *ns2__getMessageFromShop_, ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_) { return this->getMessageFromShop(NULL, NULL, ns2__getMessageFromShop_, ns2__getMessageFromShopResponse_); }
        /// Web service synchronous operation 'getMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromShop *ns2__getMessageFromShop_, ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_) { return this->send_getMessageFromShop(soap_endpoint_url, soap_action, ns2__getMessageFromShop_) || this->recv_getMessageFromShop(ns2__getMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromShop *ns2__getMessageFromShop_);
        /// Web service asynchronous operation 'recv_getMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getMessageFromShop(ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_);
        //
        /// Web service synchronous operation 'deleteMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromShop(ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_, ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_) { return this->deleteMessageFromShop(NULL, NULL, ns2__deleteMessageFromShop_, ns2__deleteMessageFromShopResponse_); }
        /// Web service synchronous operation 'deleteMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_, ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_) { return this->send_deleteMessageFromShop(soap_endpoint_url, soap_action, ns2__deleteMessageFromShop_) || this->recv_deleteMessageFromShop(ns2__deleteMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_);
        /// Web service asynchronous operation 'recv_deleteMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteMessageFromShop(ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_);
        //
        /// Web service synchronous operation 'getOrderLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderLikeList(ns2__getOrderLikeList *ns2__getOrderLikeList_, ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_) { return this->getOrderLikeList(NULL, NULL, ns2__getOrderLikeList_, ns2__getOrderLikeListResponse_); }
        /// Web service synchronous operation 'getOrderLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderLikeList *ns2__getOrderLikeList_, ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_) { return this->send_getOrderLikeList(soap_endpoint_url, soap_action, ns2__getOrderLikeList_) || this->recv_getOrderLikeList(ns2__getOrderLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderLikeList *ns2__getOrderLikeList_);
        /// Web service asynchronous operation 'recv_getOrderLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderLikeList(ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_);
        //
        /// Web service synchronous operation 'getUnreadMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromShop(ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_, ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_) { return this->getUnreadMessageFromShop(NULL, NULL, ns2__getUnreadMessageFromShop_, ns2__getUnreadMessageFromShopResponse_); }
        /// Web service synchronous operation 'getUnreadMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_, ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_) { return this->send_getUnreadMessageFromShop(soap_endpoint_url, soap_action, ns2__getUnreadMessageFromShop_) || this->recv_getUnreadMessageFromShop(ns2__getUnreadMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getUnreadMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getUnreadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_);
        /// Web service asynchronous operation 'recv_getUnreadMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getUnreadMessageFromShop(ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_);
        //
        /// Web service synchronous operation 'getClientLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getClientLikeList(ns2__getClientLikeList *ns2__getClientLikeList_, ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_) { return this->getClientLikeList(NULL, NULL, ns2__getClientLikeList_, ns2__getClientLikeListResponse_); }
        /// Web service synchronous operation 'getClientLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getClientLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientLikeList *ns2__getClientLikeList_, ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_) { return this->send_getClientLikeList(soap_endpoint_url, soap_action, ns2__getClientLikeList_) || this->recv_getClientLikeList(ns2__getClientLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getClientLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getClientLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientLikeList *ns2__getClientLikeList_);
        /// Web service asynchronous operation 'recv_getClientLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getClientLikeList(ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_);
        //
        /// Web service synchronous operation 'getShopList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getShopList(ns2__getShopList *ns2__getShopList_, ns2__getShopListResponse &ns2__getShopListResponse_) { return this->getShopList(NULL, NULL, ns2__getShopList_, ns2__getShopListResponse_); }
        /// Web service synchronous operation 'getShopList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getShopList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopList *ns2__getShopList_, ns2__getShopListResponse &ns2__getShopListResponse_) { return this->send_getShopList(soap_endpoint_url, soap_action, ns2__getShopList_) || this->recv_getShopList(ns2__getShopListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getShopList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getShopList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopList *ns2__getShopList_);
        /// Web service asynchronous operation 'recv_getShopList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getShopList(ns2__getShopListResponse &ns2__getShopListResponse_);
        //
        /// Web service synchronous operation 'getOrderListByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListByInfo(ns2__getOrderListByInfo *ns2__getOrderListByInfo_, ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_) { return this->getOrderListByInfo(NULL, NULL, ns2__getOrderListByInfo_, ns2__getOrderListByInfoResponse_); }
        /// Web service synchronous operation 'getOrderListByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListByInfo *ns2__getOrderListByInfo_, ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_) { return this->send_getOrderListByInfo(soap_endpoint_url, soap_action, ns2__getOrderListByInfo_) || this->recv_getOrderListByInfo(ns2__getOrderListByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderListByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListByInfo *ns2__getOrderListByInfo_);
        /// Web service asynchronous operation 'recv_getOrderListByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderListByInfo(ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_);
        //
        /// Web service synchronous operation 'addProductType' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int addProductType(ns2__addProductType *ns2__addProductType_, ns2__addProductTypeResponse &ns2__addProductTypeResponse_) { return this->addProductType(NULL, NULL, ns2__addProductType_, ns2__addProductTypeResponse_); }
        /// Web service synchronous operation 'addProductType' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int addProductType(const char *soap_endpoint_url, const char *soap_action, ns2__addProductType *ns2__addProductType_, ns2__addProductTypeResponse &ns2__addProductTypeResponse_) { return this->send_addProductType(soap_endpoint_url, soap_action, ns2__addProductType_) || this->recv_addProductType(ns2__addProductTypeResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_addProductType' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_addProductType(const char *soap_endpoint_url, const char *soap_action, ns2__addProductType *ns2__addProductType_);
        /// Web service asynchronous operation 'recv_addProductType' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_addProductType(ns2__addProductTypeResponse &ns2__addProductTypeResponse_);
        //
        /// Web service synchronous operation 'deleteMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromClient(ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_, ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_) { return this->deleteMessageFromClient(NULL, NULL, ns2__deleteMessageFromClient_, ns2__deleteMessageFromClientResponse_); }
        /// Web service synchronous operation 'deleteMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_, ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_) { return this->send_deleteMessageFromClient(soap_endpoint_url, soap_action, ns2__deleteMessageFromClient_) || this->recv_deleteMessageFromClient(ns2__deleteMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_);
        /// Web service asynchronous operation 'recv_deleteMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteMessageFromClient(ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_);
        //
        /// Web service synchronous operation 'getProductLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductLikeList(ns2__getProductLikeList *ns2__getProductLikeList_, ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_) { return this->getProductLikeList(NULL, NULL, ns2__getProductLikeList_, ns2__getProductLikeListResponse_); }
        /// Web service synchronous operation 'getProductLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductLikeList *ns2__getProductLikeList_, ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_) { return this->send_getProductLikeList(soap_endpoint_url, soap_action, ns2__getProductLikeList_) || this->recv_getProductLikeList(ns2__getProductLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductLikeList *ns2__getProductLikeList_);
        /// Web service asynchronous operation 'recv_getProductLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductLikeList(ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_);
        //
        /// Web service synchronous operation 'getClientByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getClientByNameAndPwd(ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_, ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_) { return this->getClientByNameAndPwd(NULL, NULL, ns2__getClientByNameAndPwd_, ns2__getClientByNameAndPwdResponse_); }
        /// Web service synchronous operation 'getClientByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_, ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_) { return this->send_getClientByNameAndPwd(soap_endpoint_url, soap_action, ns2__getClientByNameAndPwd_) || this->recv_getClientByNameAndPwd(ns2__getClientByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getClientByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_);
        /// Web service asynchronous operation 'recv_getClientByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getClientByNameAndPwd(ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_);
        //
        /// Web service synchronous operation 'deleteShoppingCart' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShoppingCart(ns2__deleteShoppingCart *ns2__deleteShoppingCart_, ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_) { return this->deleteShoppingCart(NULL, NULL, ns2__deleteShoppingCart_, ns2__deleteShoppingCartResponse_); }
        /// Web service synchronous operation 'deleteShoppingCart' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShoppingCart(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShoppingCart *ns2__deleteShoppingCart_, ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_) { return this->send_deleteShoppingCart(soap_endpoint_url, soap_action, ns2__deleteShoppingCart_) || this->recv_deleteShoppingCart(ns2__deleteShoppingCartResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteShoppingCart' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteShoppingCart(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShoppingCart *ns2__deleteShoppingCart_);
        /// Web service asynchronous operation 'recv_deleteShoppingCart' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteShoppingCart(ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_);
        //
        /// Web service synchronous operation 'InsertClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int InsertClient(ns2__InsertClient *ns2__InsertClient_, ns2__InsertClientResponse &ns2__InsertClientResponse_) { return this->InsertClient(NULL, NULL, ns2__InsertClient_, ns2__InsertClientResponse_); }
        /// Web service synchronous operation 'InsertClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int InsertClient(const char *soap_endpoint_url, const char *soap_action, ns2__InsertClient *ns2__InsertClient_, ns2__InsertClientResponse &ns2__InsertClientResponse_) { return this->send_InsertClient(soap_endpoint_url, soap_action, ns2__InsertClient_) || this->recv_InsertClient(ns2__InsertClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_InsertClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_InsertClient(const char *soap_endpoint_url, const char *soap_action, ns2__InsertClient *ns2__InsertClient_);
        /// Web service asynchronous operation 'recv_InsertClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_InsertClient(ns2__InsertClientResponse &ns2__InsertClientResponse_);
    };

### Proxy Operation `WholeMapperSoapBindingProxy::selectProductForUpdate()`

This service operation is declared in [soap_head.h](soap_head.h) at line 2741 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'selectProductForUpdate' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int selectProductForUpdate(ns2__selectProductForUpdate *ns2__selectProductForUpdate_, ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_) { return this->selectProductForUpdate(NULL, NULL, ns2__selectProductForUpdate_, ns2__selectProductForUpdateResponse_); }
        /// Web service synchronous operation 'selectProductForUpdate' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int selectProductForUpdate(const char *soap_endpoint_url, const char *soap_action, ns2__selectProductForUpdate *ns2__selectProductForUpdate_, ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_) { return this->send_selectProductForUpdate(soap_endpoint_url, soap_action, ns2__selectProductForUpdate_) || this->recv_selectProductForUpdate(ns2__selectProductForUpdateResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_selectProductForUpdate' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_selectProductForUpdate(const char *soap_endpoint_url, const char *soap_action, ns2__selectProductForUpdate *ns2__selectProductForUpdate_);
        /// Web service asynchronous operation 'recv_selectProductForUpdate' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_selectProductForUpdate(ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__selectProductForUpdate *ns2__selectProductForUpdate_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__selectProductForUpdate"> ns2__selectProductForUpdate </a></code>
- `ns2__selectProductForUpdateResponse &ns2__selectProductForUpdateResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__selectProductForUpdateResponse"> ns2__selectProductForUpdateResponse </a></code>

The `selectProductForUpdate` method sends the request message and receives the response message, assigning the last parameter `ns2__selectProductForUpdateResponse_` the response value received. The `send_selectProductForUpdate` method sends the request message and the `recv_selectProductForUpdate` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::addProduct()`

This service operation is declared in [soap_head.h](soap_head.h) at line 2808 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'addProduct' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int addProduct(ns2__addProduct *ns2__addProduct_, ns2__addProductResponse &ns2__addProductResponse_) { return this->addProduct(NULL, NULL, ns2__addProduct_, ns2__addProductResponse_); }
        /// Web service synchronous operation 'addProduct' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int addProduct(const char *soap_endpoint_url, const char *soap_action, ns2__addProduct *ns2__addProduct_, ns2__addProductResponse &ns2__addProductResponse_) { return this->send_addProduct(soap_endpoint_url, soap_action, ns2__addProduct_) || this->recv_addProduct(ns2__addProductResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_addProduct' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_addProduct(const char *soap_endpoint_url, const char *soap_action, ns2__addProduct *ns2__addProduct_);
        /// Web service asynchronous operation 'recv_addProduct' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_addProduct(ns2__addProductResponse &ns2__addProductResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__addProduct *ns2__addProduct_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__addProduct"> ns2__addProduct </a></code>
- `ns2__addProductResponse &ns2__addProductResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__addProductResponse"> ns2__addProductResponse </a></code>

The `addProduct` method sends the request message and receives the response message, assigning the last parameter `ns2__addProductResponse_` the response value received. The `send_addProduct` method sends the request message and the `recv_addProduct` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteProductTypeByName()`

This service operation is declared in [soap_head.h](soap_head.h) at line 2875 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteProductTypeByName' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductTypeByName(ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_, ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_) { return this->deleteProductTypeByName(NULL, NULL, ns2__deleteProductTypeByName_, ns2__deleteProductTypeByNameResponse_); }
        /// Web service synchronous operation 'deleteProductTypeByName' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductTypeByName(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_, ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_) { return this->send_deleteProductTypeByName(soap_endpoint_url, soap_action, ns2__deleteProductTypeByName_) || this->recv_deleteProductTypeByName(ns2__deleteProductTypeByNameResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteProductTypeByName' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteProductTypeByName(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_);
        /// Web service asynchronous operation 'recv_deleteProductTypeByName' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteProductTypeByName(ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteProductTypeByName"> ns2__deleteProductTypeByName </a></code>
- `ns2__deleteProductTypeByNameResponse &ns2__deleteProductTypeByNameResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteProductTypeByNameResponse"> ns2__deleteProductTypeByNameResponse </a></code>

The `deleteProductTypeByName` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteProductTypeByNameResponse_` the response value received. The `send_deleteProductTypeByName` method sends the request message and the `recv_deleteProductTypeByName` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getOrderList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 2942 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getOrderList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderList(ns2__getOrderList *ns2__getOrderList_, ns2__getOrderListResponse &ns2__getOrderListResponse_) { return this->getOrderList(NULL, NULL, ns2__getOrderList_, ns2__getOrderListResponse_); }
        /// Web service synchronous operation 'getOrderList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderList *ns2__getOrderList_, ns2__getOrderListResponse &ns2__getOrderListResponse_) { return this->send_getOrderList(soap_endpoint_url, soap_action, ns2__getOrderList_) || this->recv_getOrderList(ns2__getOrderListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderList *ns2__getOrderList_);
        /// Web service asynchronous operation 'recv_getOrderList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderList(ns2__getOrderListResponse &ns2__getOrderListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getOrderList *ns2__getOrderList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getOrderList"> ns2__getOrderList </a></code>
- `ns2__getOrderListResponse &ns2__getOrderListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getOrderListResponse"> ns2__getOrderListResponse </a></code>

The `getOrderList` method sends the request message and receives the response message, assigning the last parameter `ns2__getOrderListResponse_` the response value received. The `send_getOrderList` method sends the request message and the `recv_getOrderList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getShopByNameAndPwd()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3009 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getShopByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getShopByNameAndPwd(ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_, ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_) { return this->getShopByNameAndPwd(NULL, NULL, ns2__getShopByNameAndPwd_, ns2__getShopByNameAndPwdResponse_); }
        /// Web service synchronous operation 'getShopByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_, ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_) { return this->send_getShopByNameAndPwd(soap_endpoint_url, soap_action, ns2__getShopByNameAndPwd_) || this->recv_getShopByNameAndPwd(ns2__getShopByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getShopByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_);
        /// Web service asynchronous operation 'recv_getShopByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getShopByNameAndPwd(ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getShopByNameAndPwd"> ns2__getShopByNameAndPwd </a></code>
- `ns2__getShopByNameAndPwdResponse &ns2__getShopByNameAndPwdResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getShopByNameAndPwdResponse"> ns2__getShopByNameAndPwdResponse </a></code>

The `getShopByNameAndPwd` method sends the request message and receives the response message, assigning the last parameter `ns2__getShopByNameAndPwdResponse_` the response value received. The `send_getShopByNameAndPwd` method sends the request message and the `recv_getShopByNameAndPwd` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::updateShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3076 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'updateShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateShop(ns2__updateShop *ns2__updateShop_, ns2__updateShopResponse &ns2__updateShopResponse_) { return this->updateShop(NULL, NULL, ns2__updateShop_, ns2__updateShopResponse_); }
        /// Web service synchronous operation 'updateShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateShop *ns2__updateShop_, ns2__updateShopResponse &ns2__updateShopResponse_) { return this->send_updateShop(soap_endpoint_url, soap_action, ns2__updateShop_) || this->recv_updateShop(ns2__updateShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateShop *ns2__updateShop_);
        /// Web service asynchronous operation 'recv_updateShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateShop(ns2__updateShopResponse &ns2__updateShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__updateShop *ns2__updateShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__updateShop"> ns2__updateShop </a></code>
- `ns2__updateShopResponse &ns2__updateShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__updateShopResponse"> ns2__updateShopResponse </a></code>

The `updateShop` method sends the request message and receives the response message, assigning the last parameter `ns2__updateShopResponse_` the response value received. The `send_updateShop` method sends the request message and the `recv_updateShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getProductListByInfo()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3143 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getProductListByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductListByInfo(ns2__getProductListByInfo *ns2__getProductListByInfo_, ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_) { return this->getProductListByInfo(NULL, NULL, ns2__getProductListByInfo_, ns2__getProductListByInfoResponse_); }
        /// Web service synchronous operation 'getProductListByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getProductListByInfo *ns2__getProductListByInfo_, ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_) { return this->send_getProductListByInfo(soap_endpoint_url, soap_action, ns2__getProductListByInfo_) || this->recv_getProductListByInfo(ns2__getProductListByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductListByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getProductListByInfo *ns2__getProductListByInfo_);
        /// Web service asynchronous operation 'recv_getProductListByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductListByInfo(ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getProductListByInfo *ns2__getProductListByInfo_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getProductListByInfo"> ns2__getProductListByInfo </a></code>
- `ns2__getProductListByInfoResponse &ns2__getProductListByInfoResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getProductListByInfoResponse"> ns2__getProductListByInfoResponse </a></code>

The `getProductListByInfo` method sends the request message and receives the response message, assigning the last parameter `ns2__getProductListByInfoResponse_` the response value received. The `send_getProductListByInfo` method sends the request message and the `recv_getProductListByInfo` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getReadMessageFromShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3210 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getReadMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromShop(ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_, ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_) { return this->getReadMessageFromShop(NULL, NULL, ns2__getReadMessageFromShop_, ns2__getReadMessageFromShopResponse_); }
        /// Web service synchronous operation 'getReadMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_, ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_) { return this->send_getReadMessageFromShop(soap_endpoint_url, soap_action, ns2__getReadMessageFromShop_) || this->recv_getReadMessageFromShop(ns2__getReadMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getReadMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getReadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_);
        /// Web service asynchronous operation 'recv_getReadMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getReadMessageFromShop(ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getReadMessageFromShop"> ns2__getReadMessageFromShop </a></code>
- `ns2__getReadMessageFromShopResponse &ns2__getReadMessageFromShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getReadMessageFromShopResponse"> ns2__getReadMessageFromShopResponse </a></code>

The `getReadMessageFromShop` method sends the request message and receives the response message, assigning the last parameter `ns2__getReadMessageFromShopResponse_` the response value received. The `send_getReadMessageFromShop` method sends the request message and the `recv_getReadMessageFromShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::updateClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3277 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'updateClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateClient(ns2__updateClient *ns2__updateClient_, ns2__updateClientResponse &ns2__updateClientResponse_) { return this->updateClient(NULL, NULL, ns2__updateClient_, ns2__updateClientResponse_); }
        /// Web service synchronous operation 'updateClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateClient *ns2__updateClient_, ns2__updateClientResponse &ns2__updateClientResponse_) { return this->send_updateClient(soap_endpoint_url, soap_action, ns2__updateClient_) || this->recv_updateClient(ns2__updateClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateClient *ns2__updateClient_);
        /// Web service asynchronous operation 'recv_updateClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateClient(ns2__updateClientResponse &ns2__updateClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__updateClient *ns2__updateClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__updateClient"> ns2__updateClient </a></code>
- `ns2__updateClientResponse &ns2__updateClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__updateClientResponse"> ns2__updateClientResponse </a></code>

The `updateClient` method sends the request message and receives the response message, assigning the last parameter `ns2__updateClientResponse_` the response value received. The `send_updateClient` method sends the request message and the `recv_updateClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteProductByInfo()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3344 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteProductByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductByInfo(ns2__deleteProductByInfo *ns2__deleteProductByInfo_, ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_) { return this->deleteProductByInfo(NULL, NULL, ns2__deleteProductByInfo_, ns2__deleteProductByInfoResponse_); }
        /// Web service synchronous operation 'deleteProductByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductByInfo *ns2__deleteProductByInfo_, ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_) { return this->send_deleteProductByInfo(soap_endpoint_url, soap_action, ns2__deleteProductByInfo_) || this->recv_deleteProductByInfo(ns2__deleteProductByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteProductByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__deleteProductByInfo *ns2__deleteProductByInfo_);
        /// Web service asynchronous operation 'recv_deleteProductByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteProductByInfo(ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteProductByInfo *ns2__deleteProductByInfo_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteProductByInfo"> ns2__deleteProductByInfo </a></code>
- `ns2__deleteProductByInfoResponse &ns2__deleteProductByInfoResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteProductByInfoResponse"> ns2__deleteProductByInfoResponse </a></code>

The `deleteProductByInfo` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteProductByInfoResponse_` the response value received. The `send_deleteProductByInfo` method sends the request message and the `recv_deleteProductByInfo` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteClientByNameAndPwd()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3411 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteClientByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteClientByNameAndPwd(ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_, ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_) { return this->deleteClientByNameAndPwd(NULL, NULL, ns2__deleteClientByNameAndPwd_, ns2__deleteClientByNameAndPwdResponse_); }
        /// Web service synchronous operation 'deleteClientByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_, ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_) { return this->send_deleteClientByNameAndPwd(soap_endpoint_url, soap_action, ns2__deleteClientByNameAndPwd_) || this->recv_deleteClientByNameAndPwd(ns2__deleteClientByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteClientByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_);
        /// Web service asynchronous operation 'recv_deleteClientByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteClientByNameAndPwd(ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteClientByNameAndPwd"> ns2__deleteClientByNameAndPwd </a></code>
- `ns2__deleteClientByNameAndPwdResponse &ns2__deleteClientByNameAndPwdResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteClientByNameAndPwdResponse"> ns2__deleteClientByNameAndPwdResponse </a></code>

The `deleteClientByNameAndPwd` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteClientByNameAndPwdResponse_` the response value received. The `send_deleteClientByNameAndPwd` method sends the request message and the `recv_deleteClientByNameAndPwd` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::InsertShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3478 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'InsertShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int InsertShop(ns2__InsertShop *ns2__InsertShop_, ns2__InsertShopResponse &ns2__InsertShopResponse_) { return this->InsertShop(NULL, NULL, ns2__InsertShop_, ns2__InsertShopResponse_); }
        /// Web service synchronous operation 'InsertShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int InsertShop(const char *soap_endpoint_url, const char *soap_action, ns2__InsertShop *ns2__InsertShop_, ns2__InsertShopResponse &ns2__InsertShopResponse_) { return this->send_InsertShop(soap_endpoint_url, soap_action, ns2__InsertShop_) || this->recv_InsertShop(ns2__InsertShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_InsertShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_InsertShop(const char *soap_endpoint_url, const char *soap_action, ns2__InsertShop *ns2__InsertShop_);
        /// Web service asynchronous operation 'recv_InsertShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_InsertShop(ns2__InsertShopResponse &ns2__InsertShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__InsertShop *ns2__InsertShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__InsertShop"> ns2__InsertShop </a></code>
- `ns2__InsertShopResponse &ns2__InsertShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__InsertShopResponse"> ns2__InsertShopResponse </a></code>

The `InsertShop` method sends the request message and receives the response message, assigning the last parameter `ns2__InsertShopResponse_` the response value received. The `send_InsertShop` method sends the request message and the `recv_InsertShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::updateMessageFromShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3545 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'updateMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromShop(ns2__updateMessageFromShop *ns2__updateMessageFromShop_, ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_) { return this->updateMessageFromShop(NULL, NULL, ns2__updateMessageFromShop_, ns2__updateMessageFromShopResponse_); }
        /// Web service synchronous operation 'updateMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromShop *ns2__updateMessageFromShop_, ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_) { return this->send_updateMessageFromShop(soap_endpoint_url, soap_action, ns2__updateMessageFromShop_) || this->recv_updateMessageFromShop(ns2__updateMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromShop *ns2__updateMessageFromShop_);
        /// Web service asynchronous operation 'recv_updateMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateMessageFromShop(ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__updateMessageFromShop *ns2__updateMessageFromShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__updateMessageFromShop"> ns2__updateMessageFromShop </a></code>
- `ns2__updateMessageFromShopResponse &ns2__updateMessageFromShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__updateMessageFromShopResponse"> ns2__updateMessageFromShopResponse </a></code>

The `updateMessageFromShop` method sends the request message and receives the response message, assigning the last parameter `ns2__updateMessageFromShopResponse_` the response value received. The `send_updateMessageFromShop` method sends the request message and the `recv_updateMessageFromShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getProductTypeByProName()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3612 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getProductTypeByProName' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductTypeByProName(ns2__getProductTypeByProName *ns2__getProductTypeByProName_, ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_) { return this->getProductTypeByProName(NULL, NULL, ns2__getProductTypeByProName_, ns2__getProductTypeByProNameResponse_); }
        /// Web service synchronous operation 'getProductTypeByProName' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductTypeByProName(const char *soap_endpoint_url, const char *soap_action, ns2__getProductTypeByProName *ns2__getProductTypeByProName_, ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_) { return this->send_getProductTypeByProName(soap_endpoint_url, soap_action, ns2__getProductTypeByProName_) || this->recv_getProductTypeByProName(ns2__getProductTypeByProNameResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductTypeByProName' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductTypeByProName(const char *soap_endpoint_url, const char *soap_action, ns2__getProductTypeByProName *ns2__getProductTypeByProName_);
        /// Web service asynchronous operation 'recv_getProductTypeByProName' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductTypeByProName(ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getProductTypeByProName *ns2__getProductTypeByProName_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getProductTypeByProName"> ns2__getProductTypeByProName </a></code>
- `ns2__getProductTypeByProNameResponse &ns2__getProductTypeByProNameResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getProductTypeByProNameResponse"> ns2__getProductTypeByProNameResponse </a></code>

The `getProductTypeByProName` method sends the request message and receives the response message, assigning the last parameter `ns2__getProductTypeByProNameResponse_` the response value received. The `send_getProductTypeByProName` method sends the request message and the `recv_getProductTypeByProName` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getClientList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3679 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getClientList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getClientList(ns2__getClientList *ns2__getClientList_, ns2__getClientListResponse &ns2__getClientListResponse_) { return this->getClientList(NULL, NULL, ns2__getClientList_, ns2__getClientListResponse_); }
        /// Web service synchronous operation 'getClientList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getClientList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientList *ns2__getClientList_, ns2__getClientListResponse &ns2__getClientListResponse_) { return this->send_getClientList(soap_endpoint_url, soap_action, ns2__getClientList_) || this->recv_getClientList(ns2__getClientListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getClientList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getClientList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientList *ns2__getClientList_);
        /// Web service asynchronous operation 'recv_getClientList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getClientList(ns2__getClientListResponse &ns2__getClientListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getClientList *ns2__getClientList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getClientList"> ns2__getClientList </a></code>
- `ns2__getClientListResponse &ns2__getClientListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getClientListResponse"> ns2__getClientListResponse </a></code>

The `getClientList` method sends the request message and receives the response message, assigning the last parameter `ns2__getClientListResponse_` the response value received. The `send_getClientList` method sends the request message and the `recv_getClientList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::purchaseProduct()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3746 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'purchaseProduct' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int purchaseProduct(ns2__purchaseProduct *ns2__purchaseProduct_, ns2__purchaseProductResponse &ns2__purchaseProductResponse_) { return this->purchaseProduct(NULL, NULL, ns2__purchaseProduct_, ns2__purchaseProductResponse_); }
        /// Web service synchronous operation 'purchaseProduct' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int purchaseProduct(const char *soap_endpoint_url, const char *soap_action, ns2__purchaseProduct *ns2__purchaseProduct_, ns2__purchaseProductResponse &ns2__purchaseProductResponse_) { return this->send_purchaseProduct(soap_endpoint_url, soap_action, ns2__purchaseProduct_) || this->recv_purchaseProduct(ns2__purchaseProductResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_purchaseProduct' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_purchaseProduct(const char *soap_endpoint_url, const char *soap_action, ns2__purchaseProduct *ns2__purchaseProduct_);
        /// Web service asynchronous operation 'recv_purchaseProduct' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_purchaseProduct(ns2__purchaseProductResponse &ns2__purchaseProductResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__purchaseProduct *ns2__purchaseProduct_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__purchaseProduct"> ns2__purchaseProduct </a></code>
- `ns2__purchaseProductResponse &ns2__purchaseProductResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__purchaseProductResponse"> ns2__purchaseProductResponse </a></code>

The `purchaseProduct` method sends the request message and receives the response message, assigning the last parameter `ns2__purchaseProductResponse_` the response value received. The `send_purchaseProduct` method sends the request message and the `recv_purchaseProduct` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::updateMessageFromClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3813 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'updateMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromClient(ns2__updateMessageFromClient *ns2__updateMessageFromClient_, ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_) { return this->updateMessageFromClient(NULL, NULL, ns2__updateMessageFromClient_, ns2__updateMessageFromClientResponse_); }
        /// Web service synchronous operation 'updateMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromClient *ns2__updateMessageFromClient_, ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_) { return this->send_updateMessageFromClient(soap_endpoint_url, soap_action, ns2__updateMessageFromClient_) || this->recv_updateMessageFromClient(ns2__updateMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__updateMessageFromClient *ns2__updateMessageFromClient_);
        /// Web service asynchronous operation 'recv_updateMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateMessageFromClient(ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__updateMessageFromClient *ns2__updateMessageFromClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__updateMessageFromClient"> ns2__updateMessageFromClient </a></code>
- `ns2__updateMessageFromClientResponse &ns2__updateMessageFromClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__updateMessageFromClientResponse"> ns2__updateMessageFromClientResponse </a></code>

The `updateMessageFromClient` method sends the request message and receives the response message, assigning the last parameter `ns2__updateMessageFromClientResponse_` the response value received. The `send_updateMessageFromClient` method sends the request message and the `recv_updateMessageFromClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getUnreadMessageFromClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3880 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getUnreadMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromClient(ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_, ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_) { return this->getUnreadMessageFromClient(NULL, NULL, ns2__getUnreadMessageFromClient_, ns2__getUnreadMessageFromClientResponse_); }
        /// Web service synchronous operation 'getUnreadMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_, ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_) { return this->send_getUnreadMessageFromClient(soap_endpoint_url, soap_action, ns2__getUnreadMessageFromClient_) || this->recv_getUnreadMessageFromClient(ns2__getUnreadMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getUnreadMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getUnreadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_);
        /// Web service asynchronous operation 'recv_getUnreadMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getUnreadMessageFromClient(ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getUnreadMessageFromClient"> ns2__getUnreadMessageFromClient </a></code>
- `ns2__getUnreadMessageFromClientResponse &ns2__getUnreadMessageFromClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getUnreadMessageFromClientResponse"> ns2__getUnreadMessageFromClientResponse </a></code>

The `getUnreadMessageFromClient` method sends the request message and receives the response message, assigning the last parameter `ns2__getUnreadMessageFromClientResponse_` the response value received. The `send_getUnreadMessageFromClient` method sends the request message and the `recv_getUnreadMessageFromClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::updateProductByInfo()`

This service operation is declared in [soap_head.h](soap_head.h) at line 3947 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'updateProductByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateProductByInfo(ns2__updateProductByInfo *ns2__updateProductByInfo_, ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_) { return this->updateProductByInfo(NULL, NULL, ns2__updateProductByInfo_, ns2__updateProductByInfoResponse_); }
        /// Web service synchronous operation 'updateProductByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__updateProductByInfo *ns2__updateProductByInfo_, ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_) { return this->send_updateProductByInfo(soap_endpoint_url, soap_action, ns2__updateProductByInfo_) || this->recv_updateProductByInfo(ns2__updateProductByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateProductByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateProductByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__updateProductByInfo *ns2__updateProductByInfo_);
        /// Web service asynchronous operation 'recv_updateProductByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateProductByInfo(ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__updateProductByInfo *ns2__updateProductByInfo_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__updateProductByInfo"> ns2__updateProductByInfo </a></code>
- `ns2__updateProductByInfoResponse &ns2__updateProductByInfoResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__updateProductByInfoResponse"> ns2__updateProductByInfoResponse </a></code>

The `updateProductByInfo` method sends the request message and receives the response message, assigning the last parameter `ns2__updateProductByInfoResponse_` the response value received. The `send_updateProductByInfo` method sends the request message and the `recv_updateProductByInfo` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getMessageFromClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4014 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromClient(ns2__getMessageFromClient *ns2__getMessageFromClient_, ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_) { return this->getMessageFromClient(NULL, NULL, ns2__getMessageFromClient_, ns2__getMessageFromClientResponse_); }
        /// Web service synchronous operation 'getMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromClient *ns2__getMessageFromClient_, ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_) { return this->send_getMessageFromClient(soap_endpoint_url, soap_action, ns2__getMessageFromClient_) || this->recv_getMessageFromClient(ns2__getMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromClient *ns2__getMessageFromClient_);
        /// Web service asynchronous operation 'recv_getMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getMessageFromClient(ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getMessageFromClient *ns2__getMessageFromClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getMessageFromClient"> ns2__getMessageFromClient </a></code>
- `ns2__getMessageFromClientResponse &ns2__getMessageFromClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getMessageFromClientResponse"> ns2__getMessageFromClientResponse </a></code>

The `getMessageFromClient` method sends the request message and receives the response message, assigning the last parameter `ns2__getMessageFromClientResponse_` the response value received. The `send_getMessageFromClient` method sends the request message and the `recv_getMessageFromClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::addOrder()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4081 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'addOrder' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int addOrder(ns2__addOrder *ns2__addOrder_, ns2__addOrderResponse &ns2__addOrderResponse_) { return this->addOrder(NULL, NULL, ns2__addOrder_, ns2__addOrderResponse_); }
        /// Web service synchronous operation 'addOrder' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int addOrder(const char *soap_endpoint_url, const char *soap_action, ns2__addOrder *ns2__addOrder_, ns2__addOrderResponse &ns2__addOrderResponse_) { return this->send_addOrder(soap_endpoint_url, soap_action, ns2__addOrder_) || this->recv_addOrder(ns2__addOrderResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_addOrder' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_addOrder(const char *soap_endpoint_url, const char *soap_action, ns2__addOrder *ns2__addOrder_);
        /// Web service asynchronous operation 'recv_addOrder' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_addOrder(ns2__addOrderResponse &ns2__addOrderResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__addOrder *ns2__addOrder_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__addOrder"> ns2__addOrder </a></code>
- `ns2__addOrderResponse &ns2__addOrderResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__addOrderResponse"> ns2__addOrderResponse </a></code>

The `addOrder` method sends the request message and receives the response message, assigning the last parameter `ns2__addOrderResponse_` the response value received. The `send_addOrder` method sends the request message and the `recv_addOrder` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteShopByNameAndPwd()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4148 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteShopByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShopByNameAndPwd(ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_, ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_) { return this->deleteShopByNameAndPwd(NULL, NULL, ns2__deleteShopByNameAndPwd_, ns2__deleteShopByNameAndPwdResponse_); }
        /// Web service synchronous operation 'deleteShopByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_, ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_) { return this->send_deleteShopByNameAndPwd(soap_endpoint_url, soap_action, ns2__deleteShopByNameAndPwd_) || this->recv_deleteShopByNameAndPwd(ns2__deleteShopByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteShopByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteShopByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_);
        /// Web service asynchronous operation 'recv_deleteShopByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteShopByNameAndPwd(ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteShopByNameAndPwd"> ns2__deleteShopByNameAndPwd </a></code>
- `ns2__deleteShopByNameAndPwdResponse &ns2__deleteShopByNameAndPwdResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteShopByNameAndPwdResponse"> ns2__deleteShopByNameAndPwdResponse </a></code>

The `deleteShopByNameAndPwd` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteShopByNameAndPwdResponse_` the response value received. The `send_deleteShopByNameAndPwd` method sends the request message and the `recv_deleteShopByNameAndPwd` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getProductList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4215 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getProductList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductList(ns2__getProductList *ns2__getProductList_, ns2__getProductListResponse &ns2__getProductListResponse_) { return this->getProductList(NULL, NULL, ns2__getProductList_, ns2__getProductListResponse_); }
        /// Web service synchronous operation 'getProductList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductList *ns2__getProductList_, ns2__getProductListResponse &ns2__getProductListResponse_) { return this->send_getProductList(soap_endpoint_url, soap_action, ns2__getProductList_) || this->recv_getProductList(ns2__getProductListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductList *ns2__getProductList_);
        /// Web service asynchronous operation 'recv_getProductList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductList(ns2__getProductListResponse &ns2__getProductListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getProductList *ns2__getProductList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getProductList"> ns2__getProductList </a></code>
- `ns2__getProductListResponse &ns2__getProductListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getProductListResponse"> ns2__getProductListResponse </a></code>

The `getProductList` method sends the request message and receives the response message, assigning the last parameter `ns2__getProductListResponse_` the response value received. The `send_getProductList` method sends the request message and the `recv_getProductList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getOrderListHistory()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4282 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getOrderListHistory' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListHistory(ns2__getOrderListHistory *ns2__getOrderListHistory_, ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_) { return this->getOrderListHistory(NULL, NULL, ns2__getOrderListHistory_, ns2__getOrderListHistoryResponse_); }
        /// Web service synchronous operation 'getOrderListHistory' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListHistory(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListHistory *ns2__getOrderListHistory_, ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_) { return this->send_getOrderListHistory(soap_endpoint_url, soap_action, ns2__getOrderListHistory_) || this->recv_getOrderListHistory(ns2__getOrderListHistoryResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderListHistory' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderListHistory(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListHistory *ns2__getOrderListHistory_);
        /// Web service asynchronous operation 'recv_getOrderListHistory' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderListHistory(ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getOrderListHistory *ns2__getOrderListHistory_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getOrderListHistory"> ns2__getOrderListHistory </a></code>
- `ns2__getOrderListHistoryResponse &ns2__getOrderListHistoryResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getOrderListHistoryResponse"> ns2__getOrderListHistoryResponse </a></code>

The `getOrderListHistory` method sends the request message and receives the response message, assigning the last parameter `ns2__getOrderListHistoryResponse_` the response value received. The `send_getOrderListHistory` method sends the request message and the `recv_getOrderListHistory` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getReadMessageFromClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4349 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getReadMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromClient(ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_, ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_) { return this->getReadMessageFromClient(NULL, NULL, ns2__getReadMessageFromClient_, ns2__getReadMessageFromClientResponse_); }
        /// Web service synchronous operation 'getReadMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getReadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_, ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_) { return this->send_getReadMessageFromClient(soap_endpoint_url, soap_action, ns2__getReadMessageFromClient_) || this->recv_getReadMessageFromClient(ns2__getReadMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getReadMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getReadMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_);
        /// Web service asynchronous operation 'recv_getReadMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getReadMessageFromClient(ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getReadMessageFromClient"> ns2__getReadMessageFromClient </a></code>
- `ns2__getReadMessageFromClientResponse &ns2__getReadMessageFromClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getReadMessageFromClientResponse"> ns2__getReadMessageFromClientResponse </a></code>

The `getReadMessageFromClient` method sends the request message and receives the response message, assigning the last parameter `ns2__getReadMessageFromClientResponse_` the response value received. The `send_getReadMessageFromClient` method sends the request message and the `recv_getReadMessageFromClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::updateHistory()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4416 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'updateHistory' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int updateHistory(ns2__updateHistory *ns2__updateHistory_, ns2__updateHistoryResponse &ns2__updateHistoryResponse_) { return this->updateHistory(NULL, NULL, ns2__updateHistory_, ns2__updateHistoryResponse_); }
        /// Web service synchronous operation 'updateHistory' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int updateHistory(const char *soap_endpoint_url, const char *soap_action, ns2__updateHistory *ns2__updateHistory_, ns2__updateHistoryResponse &ns2__updateHistoryResponse_) { return this->send_updateHistory(soap_endpoint_url, soap_action, ns2__updateHistory_) || this->recv_updateHistory(ns2__updateHistoryResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_updateHistory' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_updateHistory(const char *soap_endpoint_url, const char *soap_action, ns2__updateHistory *ns2__updateHistory_);
        /// Web service asynchronous operation 'recv_updateHistory' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_updateHistory(ns2__updateHistoryResponse &ns2__updateHistoryResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__updateHistory *ns2__updateHistory_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__updateHistory"> ns2__updateHistory </a></code>
- `ns2__updateHistoryResponse &ns2__updateHistoryResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__updateHistoryResponse"> ns2__updateHistoryResponse </a></code>

The `updateHistory` method sends the request message and receives the response message, assigning the last parameter `ns2__updateHistoryResponse_` the response value received. The `send_updateHistory` method sends the request message and the `recv_updateHistory` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::InsertMessage()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4483 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'InsertMessage' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int InsertMessage(ns2__InsertMessage *ns2__InsertMessage_, ns2__InsertMessageResponse &ns2__InsertMessageResponse_) { return this->InsertMessage(NULL, NULL, ns2__InsertMessage_, ns2__InsertMessageResponse_); }
        /// Web service synchronous operation 'InsertMessage' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int InsertMessage(const char *soap_endpoint_url, const char *soap_action, ns2__InsertMessage *ns2__InsertMessage_, ns2__InsertMessageResponse &ns2__InsertMessageResponse_) { return this->send_InsertMessage(soap_endpoint_url, soap_action, ns2__InsertMessage_) || this->recv_InsertMessage(ns2__InsertMessageResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_InsertMessage' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_InsertMessage(const char *soap_endpoint_url, const char *soap_action, ns2__InsertMessage *ns2__InsertMessage_);
        /// Web service asynchronous operation 'recv_InsertMessage' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_InsertMessage(ns2__InsertMessageResponse &ns2__InsertMessageResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__InsertMessage *ns2__InsertMessage_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__InsertMessage"> ns2__InsertMessage </a></code>
- `ns2__InsertMessageResponse &ns2__InsertMessageResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__InsertMessageResponse"> ns2__InsertMessageResponse </a></code>

The `InsertMessage` method sends the request message and receives the response message, assigning the last parameter `ns2__InsertMessageResponse_` the response value received. The `send_InsertMessage` method sends the request message and the `recv_InsertMessage` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getShopLikeList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4550 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getShopLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getShopLikeList(ns2__getShopLikeList *ns2__getShopLikeList_, ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_) { return this->getShopLikeList(NULL, NULL, ns2__getShopLikeList_, ns2__getShopLikeListResponse_); }
        /// Web service synchronous operation 'getShopLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getShopLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopLikeList *ns2__getShopLikeList_, ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_) { return this->send_getShopLikeList(soap_endpoint_url, soap_action, ns2__getShopLikeList_) || this->recv_getShopLikeList(ns2__getShopLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getShopLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getShopLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopLikeList *ns2__getShopLikeList_);
        /// Web service asynchronous operation 'recv_getShopLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getShopLikeList(ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getShopLikeList *ns2__getShopLikeList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getShopLikeList"> ns2__getShopLikeList </a></code>
- `ns2__getShopLikeListResponse &ns2__getShopLikeListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getShopLikeListResponse"> ns2__getShopLikeListResponse </a></code>

The `getShopLikeList` method sends the request message and receives the response message, assigning the last parameter `ns2__getShopLikeListResponse_` the response value received. The `send_getShopLikeList` method sends the request message and the `recv_getShopLikeList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getMessageFromShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4617 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromShop(ns2__getMessageFromShop *ns2__getMessageFromShop_, ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_) { return this->getMessageFromShop(NULL, NULL, ns2__getMessageFromShop_, ns2__getMessageFromShopResponse_); }
        /// Web service synchronous operation 'getMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromShop *ns2__getMessageFromShop_, ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_) { return this->send_getMessageFromShop(soap_endpoint_url, soap_action, ns2__getMessageFromShop_) || this->recv_getMessageFromShop(ns2__getMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getMessageFromShop *ns2__getMessageFromShop_);
        /// Web service asynchronous operation 'recv_getMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getMessageFromShop(ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getMessageFromShop *ns2__getMessageFromShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getMessageFromShop"> ns2__getMessageFromShop </a></code>
- `ns2__getMessageFromShopResponse &ns2__getMessageFromShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getMessageFromShopResponse"> ns2__getMessageFromShopResponse </a></code>

The `getMessageFromShop` method sends the request message and receives the response message, assigning the last parameter `ns2__getMessageFromShopResponse_` the response value received. The `send_getMessageFromShop` method sends the request message and the `recv_getMessageFromShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteMessageFromShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4684 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromShop(ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_, ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_) { return this->deleteMessageFromShop(NULL, NULL, ns2__deleteMessageFromShop_, ns2__deleteMessageFromShopResponse_); }
        /// Web service synchronous operation 'deleteMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_, ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_) { return this->send_deleteMessageFromShop(soap_endpoint_url, soap_action, ns2__deleteMessageFromShop_) || this->recv_deleteMessageFromShop(ns2__deleteMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_);
        /// Web service asynchronous operation 'recv_deleteMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteMessageFromShop(ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteMessageFromShop"> ns2__deleteMessageFromShop </a></code>
- `ns2__deleteMessageFromShopResponse &ns2__deleteMessageFromShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteMessageFromShopResponse"> ns2__deleteMessageFromShopResponse </a></code>

The `deleteMessageFromShop` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteMessageFromShopResponse_` the response value received. The `send_deleteMessageFromShop` method sends the request message and the `recv_deleteMessageFromShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getOrderLikeList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4751 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getOrderLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderLikeList(ns2__getOrderLikeList *ns2__getOrderLikeList_, ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_) { return this->getOrderLikeList(NULL, NULL, ns2__getOrderLikeList_, ns2__getOrderLikeListResponse_); }
        /// Web service synchronous operation 'getOrderLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderLikeList *ns2__getOrderLikeList_, ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_) { return this->send_getOrderLikeList(soap_endpoint_url, soap_action, ns2__getOrderLikeList_) || this->recv_getOrderLikeList(ns2__getOrderLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderLikeList *ns2__getOrderLikeList_);
        /// Web service asynchronous operation 'recv_getOrderLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderLikeList(ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getOrderLikeList *ns2__getOrderLikeList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getOrderLikeList"> ns2__getOrderLikeList </a></code>
- `ns2__getOrderLikeListResponse &ns2__getOrderLikeListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getOrderLikeListResponse"> ns2__getOrderLikeListResponse </a></code>

The `getOrderLikeList` method sends the request message and receives the response message, assigning the last parameter `ns2__getOrderLikeListResponse_` the response value received. The `send_getOrderLikeList` method sends the request message and the `recv_getOrderLikeList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getUnreadMessageFromShop()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4818 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getUnreadMessageFromShop' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromShop(ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_, ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_) { return this->getUnreadMessageFromShop(NULL, NULL, ns2__getUnreadMessageFromShop_, ns2__getUnreadMessageFromShopResponse_); }
        /// Web service synchronous operation 'getUnreadMessageFromShop' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getUnreadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_, ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_) { return this->send_getUnreadMessageFromShop(soap_endpoint_url, soap_action, ns2__getUnreadMessageFromShop_) || this->recv_getUnreadMessageFromShop(ns2__getUnreadMessageFromShopResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getUnreadMessageFromShop' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getUnreadMessageFromShop(const char *soap_endpoint_url, const char *soap_action, ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_);
        /// Web service asynchronous operation 'recv_getUnreadMessageFromShop' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getUnreadMessageFromShop(ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getUnreadMessageFromShop"> ns2__getUnreadMessageFromShop </a></code>
- `ns2__getUnreadMessageFromShopResponse &ns2__getUnreadMessageFromShopResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getUnreadMessageFromShopResponse"> ns2__getUnreadMessageFromShopResponse </a></code>

The `getUnreadMessageFromShop` method sends the request message and receives the response message, assigning the last parameter `ns2__getUnreadMessageFromShopResponse_` the response value received. The `send_getUnreadMessageFromShop` method sends the request message and the `recv_getUnreadMessageFromShop` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getClientLikeList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4885 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getClientLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getClientLikeList(ns2__getClientLikeList *ns2__getClientLikeList_, ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_) { return this->getClientLikeList(NULL, NULL, ns2__getClientLikeList_, ns2__getClientLikeListResponse_); }
        /// Web service synchronous operation 'getClientLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getClientLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientLikeList *ns2__getClientLikeList_, ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_) { return this->send_getClientLikeList(soap_endpoint_url, soap_action, ns2__getClientLikeList_) || this->recv_getClientLikeList(ns2__getClientLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getClientLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getClientLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getClientLikeList *ns2__getClientLikeList_);
        /// Web service asynchronous operation 'recv_getClientLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getClientLikeList(ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getClientLikeList *ns2__getClientLikeList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getClientLikeList"> ns2__getClientLikeList </a></code>
- `ns2__getClientLikeListResponse &ns2__getClientLikeListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getClientLikeListResponse"> ns2__getClientLikeListResponse </a></code>

The `getClientLikeList` method sends the request message and receives the response message, assigning the last parameter `ns2__getClientLikeListResponse_` the response value received. The `send_getClientLikeList` method sends the request message and the `recv_getClientLikeList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getShopList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 4952 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getShopList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getShopList(ns2__getShopList *ns2__getShopList_, ns2__getShopListResponse &ns2__getShopListResponse_) { return this->getShopList(NULL, NULL, ns2__getShopList_, ns2__getShopListResponse_); }
        /// Web service synchronous operation 'getShopList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getShopList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopList *ns2__getShopList_, ns2__getShopListResponse &ns2__getShopListResponse_) { return this->send_getShopList(soap_endpoint_url, soap_action, ns2__getShopList_) || this->recv_getShopList(ns2__getShopListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getShopList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getShopList(const char *soap_endpoint_url, const char *soap_action, ns2__getShopList *ns2__getShopList_);
        /// Web service asynchronous operation 'recv_getShopList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getShopList(ns2__getShopListResponse &ns2__getShopListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getShopList *ns2__getShopList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getShopList"> ns2__getShopList </a></code>
- `ns2__getShopListResponse &ns2__getShopListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getShopListResponse"> ns2__getShopListResponse </a></code>

The `getShopList` method sends the request message and receives the response message, assigning the last parameter `ns2__getShopListResponse_` the response value received. The `send_getShopList` method sends the request message and the `recv_getShopList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getOrderListByInfo()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5019 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getOrderListByInfo' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListByInfo(ns2__getOrderListByInfo *ns2__getOrderListByInfo_, ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_) { return this->getOrderListByInfo(NULL, NULL, ns2__getOrderListByInfo_, ns2__getOrderListByInfoResponse_); }
        /// Web service synchronous operation 'getOrderListByInfo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getOrderListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListByInfo *ns2__getOrderListByInfo_, ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_) { return this->send_getOrderListByInfo(soap_endpoint_url, soap_action, ns2__getOrderListByInfo_) || this->recv_getOrderListByInfo(ns2__getOrderListByInfoResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getOrderListByInfo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getOrderListByInfo(const char *soap_endpoint_url, const char *soap_action, ns2__getOrderListByInfo *ns2__getOrderListByInfo_);
        /// Web service asynchronous operation 'recv_getOrderListByInfo' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getOrderListByInfo(ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getOrderListByInfo *ns2__getOrderListByInfo_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getOrderListByInfo"> ns2__getOrderListByInfo </a></code>
- `ns2__getOrderListByInfoResponse &ns2__getOrderListByInfoResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getOrderListByInfoResponse"> ns2__getOrderListByInfoResponse </a></code>

The `getOrderListByInfo` method sends the request message and receives the response message, assigning the last parameter `ns2__getOrderListByInfoResponse_` the response value received. The `send_getOrderListByInfo` method sends the request message and the `recv_getOrderListByInfo` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::addProductType()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5086 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'addProductType' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int addProductType(ns2__addProductType *ns2__addProductType_, ns2__addProductTypeResponse &ns2__addProductTypeResponse_) { return this->addProductType(NULL, NULL, ns2__addProductType_, ns2__addProductTypeResponse_); }
        /// Web service synchronous operation 'addProductType' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int addProductType(const char *soap_endpoint_url, const char *soap_action, ns2__addProductType *ns2__addProductType_, ns2__addProductTypeResponse &ns2__addProductTypeResponse_) { return this->send_addProductType(soap_endpoint_url, soap_action, ns2__addProductType_) || this->recv_addProductType(ns2__addProductTypeResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_addProductType' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_addProductType(const char *soap_endpoint_url, const char *soap_action, ns2__addProductType *ns2__addProductType_);
        /// Web service asynchronous operation 'recv_addProductType' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_addProductType(ns2__addProductTypeResponse &ns2__addProductTypeResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__addProductType *ns2__addProductType_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__addProductType"> ns2__addProductType </a></code>
- `ns2__addProductTypeResponse &ns2__addProductTypeResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__addProductTypeResponse"> ns2__addProductTypeResponse </a></code>

The `addProductType` method sends the request message and receives the response message, assigning the last parameter `ns2__addProductTypeResponse_` the response value received. The `send_addProductType` method sends the request message and the `recv_addProductType` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteMessageFromClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5153 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteMessageFromClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromClient(ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_, ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_) { return this->deleteMessageFromClient(NULL, NULL, ns2__deleteMessageFromClient_, ns2__deleteMessageFromClientResponse_); }
        /// Web service synchronous operation 'deleteMessageFromClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_, ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_) { return this->send_deleteMessageFromClient(soap_endpoint_url, soap_action, ns2__deleteMessageFromClient_) || this->recv_deleteMessageFromClient(ns2__deleteMessageFromClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteMessageFromClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteMessageFromClient(const char *soap_endpoint_url, const char *soap_action, ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_);
        /// Web service asynchronous operation 'recv_deleteMessageFromClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteMessageFromClient(ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteMessageFromClient"> ns2__deleteMessageFromClient </a></code>
- `ns2__deleteMessageFromClientResponse &ns2__deleteMessageFromClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteMessageFromClientResponse"> ns2__deleteMessageFromClientResponse </a></code>

The `deleteMessageFromClient` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteMessageFromClientResponse_` the response value received. The `send_deleteMessageFromClient` method sends the request message and the `recv_deleteMessageFromClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getProductLikeList()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5220 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getProductLikeList' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getProductLikeList(ns2__getProductLikeList *ns2__getProductLikeList_, ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_) { return this->getProductLikeList(NULL, NULL, ns2__getProductLikeList_, ns2__getProductLikeListResponse_); }
        /// Web service synchronous operation 'getProductLikeList' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getProductLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductLikeList *ns2__getProductLikeList_, ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_) { return this->send_getProductLikeList(soap_endpoint_url, soap_action, ns2__getProductLikeList_) || this->recv_getProductLikeList(ns2__getProductLikeListResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getProductLikeList' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getProductLikeList(const char *soap_endpoint_url, const char *soap_action, ns2__getProductLikeList *ns2__getProductLikeList_);
        /// Web service asynchronous operation 'recv_getProductLikeList' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getProductLikeList(ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getProductLikeList *ns2__getProductLikeList_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getProductLikeList"> ns2__getProductLikeList </a></code>
- `ns2__getProductLikeListResponse &ns2__getProductLikeListResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getProductLikeListResponse"> ns2__getProductLikeListResponse </a></code>

The `getProductLikeList` method sends the request message and receives the response message, assigning the last parameter `ns2__getProductLikeListResponse_` the response value received. The `send_getProductLikeList` method sends the request message and the `recv_getProductLikeList` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::getClientByNameAndPwd()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5287 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'getClientByNameAndPwd' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int getClientByNameAndPwd(ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_, ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_) { return this->getClientByNameAndPwd(NULL, NULL, ns2__getClientByNameAndPwd_, ns2__getClientByNameAndPwdResponse_); }
        /// Web service synchronous operation 'getClientByNameAndPwd' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int getClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_, ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_) { return this->send_getClientByNameAndPwd(soap_endpoint_url, soap_action, ns2__getClientByNameAndPwd_) || this->recv_getClientByNameAndPwd(ns2__getClientByNameAndPwdResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_getClientByNameAndPwd' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_getClientByNameAndPwd(const char *soap_endpoint_url, const char *soap_action, ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_);
        /// Web service asynchronous operation 'recv_getClientByNameAndPwd' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_getClientByNameAndPwd(ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__getClientByNameAndPwd"> ns2__getClientByNameAndPwd </a></code>
- `ns2__getClientByNameAndPwdResponse &ns2__getClientByNameAndPwdResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__getClientByNameAndPwdResponse"> ns2__getClientByNameAndPwdResponse </a></code>

The `getClientByNameAndPwd` method sends the request message and receives the response message, assigning the last parameter `ns2__getClientByNameAndPwdResponse_` the response value received. The `send_getClientByNameAndPwd` method sends the request message and the `recv_getClientByNameAndPwd` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::deleteShoppingCart()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5354 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'deleteShoppingCart' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShoppingCart(ns2__deleteShoppingCart *ns2__deleteShoppingCart_, ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_) { return this->deleteShoppingCart(NULL, NULL, ns2__deleteShoppingCart_, ns2__deleteShoppingCartResponse_); }
        /// Web service synchronous operation 'deleteShoppingCart' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int deleteShoppingCart(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShoppingCart *ns2__deleteShoppingCart_, ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_) { return this->send_deleteShoppingCart(soap_endpoint_url, soap_action, ns2__deleteShoppingCart_) || this->recv_deleteShoppingCart(ns2__deleteShoppingCartResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_deleteShoppingCart' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_deleteShoppingCart(const char *soap_endpoint_url, const char *soap_action, ns2__deleteShoppingCart *ns2__deleteShoppingCart_);
        /// Web service asynchronous operation 'recv_deleteShoppingCart' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_deleteShoppingCart(ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__deleteShoppingCart *ns2__deleteShoppingCart_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__deleteShoppingCart"> ns2__deleteShoppingCart </a></code>
- `ns2__deleteShoppingCartResponse &ns2__deleteShoppingCartResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__deleteShoppingCartResponse"> ns2__deleteShoppingCartResponse </a></code>

The `deleteShoppingCart` method sends the request message and receives the response message, assigning the last parameter `ns2__deleteShoppingCartResponse_` the response value received. The `send_deleteShoppingCart` method sends the request message and the `recv_deleteShoppingCart` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


### Proxy Operation `WholeMapperSoapBindingProxy::InsertClient()`

This service operation is declared in [soap_head.h](soap_head.h) at line 5421 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- SOAP response action "Response"
- Default service endpoint URL "http://localhost:8090/WholeMapper"
- Operation namespace prefix `ns1` and URI "[http://service.linexus.com/](#doc-namespaces)"

To invoke this service operation, use the following methods:

        //
        /// Web service synchronous operation 'InsertClient' with default endpoint and default SOAP Action header, returns SOAP_OK or error code
        virtual int InsertClient(ns2__InsertClient *ns2__InsertClient_, ns2__InsertClientResponse &ns2__InsertClientResponse_) { return this->InsertClient(NULL, NULL, ns2__InsertClient_, ns2__InsertClientResponse_); }
        /// Web service synchronous operation 'InsertClient' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int InsertClient(const char *soap_endpoint_url, const char *soap_action, ns2__InsertClient *ns2__InsertClient_, ns2__InsertClientResponse &ns2__InsertClientResponse_) { return this->send_InsertClient(soap_endpoint_url, soap_action, ns2__InsertClient_) || this->recv_InsertClient(ns2__InsertClientResponse_) ? this->soap->error : SOAP_OK; }
        /// Web service asynchronous operation 'send_InsertClient' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code
        virtual int send_InsertClient(const char *soap_endpoint_url, const char *soap_action, ns2__InsertClient *ns2__InsertClient_);
        /// Web service asynchronous operation 'recv_InsertClient' to receive a response message from the connected endpoint, returns SOAP_OK or error code
        virtual int recv_InsertClient(ns2__InsertClientResponse &ns2__InsertClientResponse_);

where:

- `const char *soap_endpoint_url` is the endpoint URL or NULL to use the default endpoint
- `const char *soap_action` is the SOAP action header or NULL to use the default action
- `ns2__InsertClient *ns2__InsertClient_` is optional, where the type of this parameter is a pointer to <code><a href="#ns2__InsertClient"> ns2__InsertClient </a></code>
- `ns2__InsertClientResponse &ns2__InsertClientResponse_` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns2__InsertClientResponse"> ns2__InsertClientResponse </a></code>

The `InsertClient` method sends the request message and receives the response message, assigning the last parameter `ns2__InsertClientResponse_` the response value received. The `send_InsertClient` method sends the request message and the `recv_InsertClient` method receives the response message asynchronously. These methods return `SOAP_OK` or an error code.

[![][1] To top](#)


## Schemas and Namespaces {#doc-namespaces}

The following schemas and namespaces are used in addition to the predefined SOAP and built-in XSD namespaces:

- Prefix `ns1` is bound to namespace URI *`http://service.linexus.com/`* with local element and attribute form default *`unqualified`*
- Prefix `ns2` is bound to namespace URI *`http://dao.linexus.com/`* with local element form default *`unqualified`* and attribute form default *`unqualified`*


The following namespace table is saved to WholeMapperSoapBinding.nsmap:

    struct Namespace namespaces[] = {
        { "SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL },
        { "SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL },
        { "xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL },
        { "xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL },
        { "ns1", "http://service.linexus.com/", NULL, NULL },
        { "ns2", "http://dao.linexus.com/", NULL, NULL },
        { NULL, NULL, NULL, NULL} /* end of namespaces[] */
    };

The table binds XML namespace prefixes (first column) to namespace URIs (second column), similar to xmlns:prefix="URI" in XML.  The third column is a URI pattern with `*` wildcards that is also accepted as a valid namespace URI for inbound XML messages.  The fourth column is NULL.  This table is globally defined for the gSOAP engine.  The engine context will look for it unless you compiled the gSOAP source codes with `-DWITH_NONAMESPACES`.  You must assign this or another namespace table with `soap_set_namespaces(struct soap *soap, struct Namespace *namespaces)` after initializing the context and before processing XML.

[![][1] To top](#)



  [1]: https://www.genivia.com/images/go-up.png

--------------------------------------------------------------------------------

_Generated on Sun Jan 05 2025 12:46:22 UTC by soapcpp2 v2.8.135 for soap_head.h._
_The gSOAP XML Web services tools are Copyright (C) Robert van Engelen, Genivia Inc. All Rights Reserved._
