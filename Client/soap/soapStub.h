/* soapStub.h
   Generated by gSOAP 2.8.135 for soap_head.h

gSOAP XML Web services tools
Copyright (C) 2000,2024, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://dao.linexus.com/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208135
# error "GSOAP VERSION 208135 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns2__selectProductForUpdate;	/* soap_head.h:163 */
class ns2__selectProductForUpdateResponse;	/* soap_head.h:165 */
class ns2__product;	/* soap_head.h:167 */
class ns2__addProduct;	/* soap_head.h:169 */
class ns2__addProductResponse;	/* soap_head.h:171 */
class ns2__deleteProductTypeByName;	/* soap_head.h:173 */
class ns2__deleteProductTypeByNameResponse;	/* soap_head.h:175 */
class ns2__getOrderList;	/* soap_head.h:177 */
class ns2__order;	/* soap_head.h:179 */
class ns2__getOrderListResponse;	/* soap_head.h:181 */
class ns2__getShopByNameAndPwd;	/* soap_head.h:183 */
class ns2__getShopByNameAndPwdResponse;	/* soap_head.h:185 */
class ns2__shop;	/* soap_head.h:187 */
class ns2__updateShop;	/* soap_head.h:189 */
class ns2__updateShopResponse;	/* soap_head.h:191 */
class ns2__getProductListByInfo;	/* soap_head.h:193 */
class ns2__getProductListByInfoResponse;	/* soap_head.h:195 */
class ns2__getReadMessageFromShop;	/* soap_head.h:197 */
class ns2__client;	/* soap_head.h:199 */
class ns2__getReadMessageFromShopResponse;	/* soap_head.h:201 */
class ns2__message;	/* soap_head.h:203 */
class ns2__updateClient;	/* soap_head.h:205 */
class ns2__updateClientResponse;	/* soap_head.h:207 */
class ns2__deleteProductByInfo;	/* soap_head.h:209 */
class ns2__deleteProductByInfoResponse;	/* soap_head.h:211 */
class ns2__deleteClientByNameAndPwd;	/* soap_head.h:213 */
class ns2__deleteClientByNameAndPwdResponse;	/* soap_head.h:215 */
class ns2__InsertShop;	/* soap_head.h:217 */
class ns2__InsertShopResponse;	/* soap_head.h:219 */
class ns2__updateMessageFromShop;	/* soap_head.h:221 */
class ns2__updateMessageFromShopResponse;	/* soap_head.h:223 */
class ns2__getProductTypeByProName;	/* soap_head.h:225 */
class ns2__getProductTypeByProNameResponse;	/* soap_head.h:227 */
class ns2__productType;	/* soap_head.h:229 */
class ns2__getClientList;	/* soap_head.h:231 */
class ns2__getClientListResponse;	/* soap_head.h:233 */
class ns2__purchaseProduct;	/* soap_head.h:235 */
class ns2__purchaseProductResponse;	/* soap_head.h:237 */
class ns2__updateMessageFromClient;	/* soap_head.h:239 */
class ns2__updateMessageFromClientResponse;	/* soap_head.h:241 */
class ns2__getUnreadMessageFromClient;	/* soap_head.h:243 */
class ns2__getUnreadMessageFromClientResponse;	/* soap_head.h:245 */
class ns2__updateProductByInfo;	/* soap_head.h:247 */
class ns2__updateProductByInfoResponse;	/* soap_head.h:249 */
class ns2__getMessageFromClient;	/* soap_head.h:251 */
class ns2__getMessageFromClientResponse;	/* soap_head.h:253 */
class ns2__addOrder;	/* soap_head.h:255 */
class ns2__addOrderResponse;	/* soap_head.h:257 */
class ns2__deleteShopByNameAndPwd;	/* soap_head.h:259 */
class ns2__deleteShopByNameAndPwdResponse;	/* soap_head.h:261 */
class ns2__getProductList;	/* soap_head.h:263 */
class ns2__getProductListResponse;	/* soap_head.h:265 */
class ns2__getOrderListHistory;	/* soap_head.h:267 */
class ns2__getOrderListHistoryResponse;	/* soap_head.h:269 */
class ns2__getReadMessageFromClient;	/* soap_head.h:271 */
class ns2__getReadMessageFromClientResponse;	/* soap_head.h:273 */
class ns2__updateHistory;	/* soap_head.h:275 */
class ns2__updateHistoryResponse;	/* soap_head.h:277 */
class ns2__InsertMessage;	/* soap_head.h:279 */
class ns2__InsertMessageResponse;	/* soap_head.h:281 */
class ns2__getShopLikeList;	/* soap_head.h:283 */
class ns2__getShopLikeListResponse;	/* soap_head.h:285 */
class ns2__getMessageFromShop;	/* soap_head.h:287 */
class ns2__getMessageFromShopResponse;	/* soap_head.h:289 */
class ns2__deleteMessageFromShop;	/* soap_head.h:291 */
class ns2__deleteMessageFromShopResponse;	/* soap_head.h:293 */
class ns2__getOrderLikeList;	/* soap_head.h:295 */
class ns2__getOrderLikeListResponse;	/* soap_head.h:297 */
class ns2__getUnreadMessageFromShop;	/* soap_head.h:299 */
class ns2__getUnreadMessageFromShopResponse;	/* soap_head.h:301 */
class ns2__getClientLikeList;	/* soap_head.h:303 */
class ns2__getClientLikeListResponse;	/* soap_head.h:305 */
class ns2__getShopList;	/* soap_head.h:307 */
class ns2__getShopListResponse;	/* soap_head.h:309 */
class ns2__getOrderListByInfo;	/* soap_head.h:311 */
class ns2__getOrderListByInfoResponse;	/* soap_head.h:313 */
class ns2__addProductType;	/* soap_head.h:315 */
class ns2__addProductTypeResponse;	/* soap_head.h:317 */
class ns2__deleteMessageFromClient;	/* soap_head.h:319 */
class ns2__deleteMessageFromClientResponse;	/* soap_head.h:321 */
class ns2__getProductLikeList;	/* soap_head.h:323 */
class ns2__getProductLikeListResponse;	/* soap_head.h:325 */
class ns2__getClientByNameAndPwd;	/* soap_head.h:327 */
class ns2__getClientByNameAndPwdResponse;	/* soap_head.h:329 */
class ns2__deleteShoppingCart;	/* soap_head.h:331 */
class ns2__deleteShoppingCartResponse;	/* soap_head.h:333 */
class ns2__InsertClient;	/* soap_head.h:335 */
class ns2__InsertClientResponse;	/* soap_head.h:337 */
struct __ns1__selectProductForUpdate;	/* soap_head.h:2744 */
struct __ns1__addProduct;	/* soap_head.h:2811 */
struct __ns1__deleteProductTypeByName;	/* soap_head.h:2878 */
struct __ns1__getOrderList;	/* soap_head.h:2945 */
struct __ns1__getShopByNameAndPwd;	/* soap_head.h:3012 */
struct __ns1__updateShop;	/* soap_head.h:3079 */
struct __ns1__getProductListByInfo;	/* soap_head.h:3146 */
struct __ns1__getReadMessageFromShop;	/* soap_head.h:3213 */
struct __ns1__updateClient;	/* soap_head.h:3280 */
struct __ns1__deleteProductByInfo;	/* soap_head.h:3347 */
struct __ns1__deleteClientByNameAndPwd;	/* soap_head.h:3414 */
struct __ns1__InsertShop;	/* soap_head.h:3481 */
struct __ns1__updateMessageFromShop;	/* soap_head.h:3548 */
struct __ns1__getProductTypeByProName;	/* soap_head.h:3615 */
struct __ns1__getClientList;	/* soap_head.h:3682 */
struct __ns1__purchaseProduct;	/* soap_head.h:3749 */
struct __ns1__updateMessageFromClient;	/* soap_head.h:3816 */
struct __ns1__getUnreadMessageFromClient;	/* soap_head.h:3883 */
struct __ns1__updateProductByInfo;	/* soap_head.h:3950 */
struct __ns1__getMessageFromClient;	/* soap_head.h:4017 */
struct __ns1__addOrder;	/* soap_head.h:4084 */
struct __ns1__deleteShopByNameAndPwd;	/* soap_head.h:4151 */
struct __ns1__getProductList;	/* soap_head.h:4218 */
struct __ns1__getOrderListHistory;	/* soap_head.h:4285 */
struct __ns1__getReadMessageFromClient;	/* soap_head.h:4352 */
struct __ns1__updateHistory;	/* soap_head.h:4419 */
struct __ns1__InsertMessage;	/* soap_head.h:4486 */
struct __ns1__getShopLikeList;	/* soap_head.h:4553 */
struct __ns1__getMessageFromShop;	/* soap_head.h:4620 */
struct __ns1__deleteMessageFromShop;	/* soap_head.h:4687 */
struct __ns1__getOrderLikeList;	/* soap_head.h:4754 */
struct __ns1__getUnreadMessageFromShop;	/* soap_head.h:4821 */
struct __ns1__getClientLikeList;	/* soap_head.h:4888 */
struct __ns1__getShopList;	/* soap_head.h:4955 */
struct __ns1__getOrderListByInfo;	/* soap_head.h:5022 */
struct __ns1__addProductType;	/* soap_head.h:5089 */
struct __ns1__deleteMessageFromClient;	/* soap_head.h:5156 */
struct __ns1__getProductLikeList;	/* soap_head.h:5223 */
struct __ns1__getClientByNameAndPwd;	/* soap_head.h:5290 */
struct __ns1__deleteShoppingCart;	/* soap_head.h:5357 */
struct __ns1__InsertClient;	/* soap_head.h:5424 */

/* soap_head.h:163 */
#ifndef SOAP_TYPE_ns2__selectProductForUpdate
#define SOAP_TYPE_ns2__selectProductForUpdate (10)
/* complex XML schema type 'ns2:selectProductForUpdate': */
class SOAP_CMAC ns2__selectProductForUpdate {
      public:
        /// Required element 'arg0' of XML schema type 'xsd:int'
        int arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__selectProductForUpdate
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__selectProductForUpdate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__selectProductForUpdate, default initialized and not managed by a soap context
        virtual ns2__selectProductForUpdate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__selectProductForUpdate); }
      public:
        /// Constructor with default initializations
        ns2__selectProductForUpdate() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__selectProductForUpdate() { }
        /// Friend allocator used by soap_new_ns2__selectProductForUpdate(struct soap*, int)
        friend SOAP_FMAC1 ns2__selectProductForUpdate * SOAP_FMAC2 soap_instantiate_ns2__selectProductForUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:165 */
#ifndef SOAP_TYPE_ns2__selectProductForUpdateResponse
#define SOAP_TYPE_ns2__selectProductForUpdateResponse (11)
/* complex XML schema type 'ns2:selectProductForUpdateResponse': */
class SOAP_CMAC ns2__selectProductForUpdateResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        ns2__product *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__selectProductForUpdateResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__selectProductForUpdateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__selectProductForUpdateResponse, default initialized and not managed by a soap context
        virtual ns2__selectProductForUpdateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__selectProductForUpdateResponse); }
      public:
        /// Constructor with default initializations
        ns2__selectProductForUpdateResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__selectProductForUpdateResponse() { }
        /// Friend allocator used by soap_new_ns2__selectProductForUpdateResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__selectProductForUpdateResponse * SOAP_FMAC2 soap_instantiate_ns2__selectProductForUpdateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:167 */
#ifndef SOAP_TYPE_ns2__product
#define SOAP_TYPE_ns2__product (12)
/* complex XML schema type 'ns2:product': */
class SOAP_CMAC ns2__product {
      public:
        /// Optional element 'discountEndTime' of XML schema type 'xsd:dateTime'
        time_t *discountEndTime;
        /// Optional element 'discountStartTime' of XML schema type 'xsd:dateTime'
        time_t *discountStartTime;
        /// Optional element 'flashSaleEndTime' of XML schema type 'xsd:dateTime'
        time_t *flashSaleEndTime;
        /// Required element 'flashSalePurchaseLimit' of XML schema type 'xsd:int'
        int flashSalePurchaseLimit;
        /// Optional element 'flashSaleStartTime' of XML schema type 'xsd:dateTime'
        time_t *flashSaleStartTime;
        /// Required element 'productBuyNum' of XML schema type 'xsd:int'
        int productBuyNum;
        /// Required element 'productDiscount' of XML schema type 'xsd:float'
        float productDiscount;
        /// Required element 'productFlashSalePrice' of XML schema type 'xsd:float'
        float productFlashSalePrice;
        /// Required element 'productId' of XML schema type 'xsd:int'
        int productId;
        /// Optional element 'productImage' of XML schema type 'xsd:string'
        std::string *productImage;
        /// Optional element 'productName' of XML schema type 'xsd:string'
        std::string *productName;
        /// Required element 'productNum' of XML schema type 'xsd:int'
        int productNum;
        /// Required element 'productPrice' of XML schema type 'xsd:int'
        int productPrice;
        /// Required element 'productShopId' of XML schema type 'xsd:int'
        int productShopId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__product
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__product; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__product, default initialized and not managed by a soap context
        virtual ns2__product *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__product); }
      public:
        /// Constructor with default initializations
        ns2__product() : discountEndTime(), discountStartTime(), flashSaleEndTime(), flashSalePurchaseLimit(), flashSaleStartTime(), productBuyNum(), productDiscount(), productFlashSalePrice(), productId(), productImage(), productName(), productNum(), productPrice(), productShopId(), soap() { }
        ns2__product(time_t* discountEndTime, time_t* discountStartTime, time_t* flashSaleEndTime, int flashSalePurchaseLimit, time_t* flashSaleStartTime, int shopId, int buynum, float discount, float productFlashSalePrice, int pId, std::string* pImage, std::string* pName, int pNum, int pPrice)
            : discountEndTime(discountEndTime), discountStartTime(discountStartTime), flashSaleEndTime(flashSaleEndTime), flashSalePurchaseLimit(flashSalePurchaseLimit),
            flashSaleStartTime(flashSaleStartTime), productShopId(shopId), productBuyNum(buynum), productDiscount(discount), productFlashSalePrice(productFlashSalePrice), productId(pId), productImage(pImage), productName(pName), productNum(pNum), productPrice(pPrice), soap() {
        }
        /// Destructor
        virtual ~ns2__product() { }
        /// Friend allocator used by soap_new_ns2__product(struct soap*, int)
        friend SOAP_FMAC1 ns2__product * SOAP_FMAC2 soap_instantiate_ns2__product(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:169 */
#ifndef SOAP_TYPE_ns2__addProduct
#define SOAP_TYPE_ns2__addProduct (13)
/* complex XML schema type 'ns2:addProduct': */
class SOAP_CMAC ns2__addProduct {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProduct
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProduct, default initialized and not managed by a soap context
        virtual ns2__addProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProduct); }
      public:
        /// Constructor with default initializations
        ns2__addProduct() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__addProduct() { }
        /// Friend allocator used by soap_new_ns2__addProduct(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProduct * SOAP_FMAC2 soap_instantiate_ns2__addProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:171 */
#ifndef SOAP_TYPE_ns2__addProductResponse
#define SOAP_TYPE_ns2__addProductResponse (14)
/* complex XML schema type 'ns2:addProductResponse': */
class SOAP_CMAC ns2__addProductResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProductResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProductResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProductResponse, default initialized and not managed by a soap context
        virtual ns2__addProductResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProductResponse); }
      public:
        /// Constructor with default initializations
        ns2__addProductResponse() : soap() { }
        /// Destructor
        virtual ~ns2__addProductResponse() { }
        /// Friend allocator used by soap_new_ns2__addProductResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProductResponse * SOAP_FMAC2 soap_instantiate_ns2__addProductResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:173 */
#ifndef SOAP_TYPE_ns2__deleteProductTypeByName
#define SOAP_TYPE_ns2__deleteProductTypeByName (15)
/* complex XML schema type 'ns2:deleteProductTypeByName': */
class SOAP_CMAC ns2__deleteProductTypeByName {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductTypeByName
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductTypeByName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductTypeByName, default initialized and not managed by a soap context
        virtual ns2__deleteProductTypeByName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductTypeByName); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductTypeByName() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__deleteProductTypeByName() { }
        /// Friend allocator used by soap_new_ns2__deleteProductTypeByName(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate_ns2__deleteProductTypeByName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:175 */
#ifndef SOAP_TYPE_ns2__deleteProductTypeByNameResponse
#define SOAP_TYPE_ns2__deleteProductTypeByNameResponse (16)
/* complex XML schema type 'ns2:deleteProductTypeByNameResponse': */
class SOAP_CMAC ns2__deleteProductTypeByNameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductTypeByNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductTypeByNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductTypeByNameResponse, default initialized and not managed by a soap context
        virtual ns2__deleteProductTypeByNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductTypeByNameResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductTypeByNameResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteProductTypeByNameResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteProductTypeByNameResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductTypeByNameResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteProductTypeByNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:177 */
#ifndef SOAP_TYPE_ns2__getOrderList
#define SOAP_TYPE_ns2__getOrderList (17)
/* complex XML schema type 'ns2:getOrderList': */
class SOAP_CMAC ns2__getOrderList {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderList, default initialized and not managed by a soap context
        virtual ns2__getOrderList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderList); }
      public:
        /// Constructor with default initializations
        ns2__getOrderList() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderList() { }
        /// Friend allocator used by soap_new_ns2__getOrderList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderList * SOAP_FMAC2 soap_instantiate_ns2__getOrderList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:179 */
#ifndef SOAP_TYPE_ns2__order
#define SOAP_TYPE_ns2__order (18)
/* complex XML schema type 'ns2:order': */
class SOAP_CMAC ns2__order {
      public:
        /// Required element 'orderCheck' of XML schema type 'xsd:int'
        int orderCheck;
        /// Optional element 'orderClient' of XML schema type 'xsd:string'
        std::string *orderClient;
        /// Required element 'orderClientId' of XML schema type 'xsd:int'
        int orderClientId;
        /// Optional element 'orderCost' of XML schema type 'xsd:decimal'
        std::string *orderCost;
        /// Required element 'orderHide' of XML schema type 'xsd:int'
        int orderHide;
        /// Required element 'orderId' of XML schema type 'xsd:int'
        int orderId;
        /// Required element 'orderProductId' of XML schema type 'xsd:int'
        int orderProductId;
        /// Optional element 'orderProductName' of XML schema type 'xsd:string'
        std::string *orderProductName;
        /// Required element 'orderProductNum' of XML schema type 'xsd:int'
        int orderProductNum;
        /// Optional element 'orderProductStyle' of XML schema type 'xsd:string'
        std::string *orderProductStyle;
        /// Required element 'orderRefund' of XML schema type 'xsd:int'
        int orderRefund;
        /// Required element 'orderShip' of XML schema type 'xsd:int'
        int orderShip;
        /// Required element 'orderShopId' of XML schema type 'xsd:int'
        int orderShopId;
        /// Optional element 'orderTime' of XML schema type 'xsd:dateTime'
        time_t *orderTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__order
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__order; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__order, default initialized and not managed by a soap context
        virtual ns2__order *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__order); }
      public:
        /// Constructor with default initializations
        ns2__order() : orderCheck(), orderClient(), orderClientId(), orderCost(), orderHide(), orderId(), orderProductId(), orderProductName(), orderProductNum(), orderProductStyle(), orderRefund(), orderShip(), orderShopId(), orderTime(), soap() { }
        ns2__order(int shopId, int check, std::string* client, int cid, std::string* cost, int hide, int id, int pid, std::string* Pname, int Pnum, std::string* Pstyle, time_t* time, int ship, int refund) :
            orderShopId(shopId), orderCheck(check), orderClient(client), orderClientId(cid), orderCost(cost), orderHide(hide), orderId(id), orderProductId(pid), orderProductName(Pname), orderProductNum(Pnum), orderProductStyle(Pstyle), orderTime(time),
            orderShip(ship), orderRefund(refund), soap() {
        }
        /// Destructor
        virtual ~ns2__order() { }
        /// Friend allocator used by soap_new_ns2__order(struct soap*, int)
        friend SOAP_FMAC1 ns2__order * SOAP_FMAC2 soap_instantiate_ns2__order(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:181 */
#ifndef SOAP_TYPE_ns2__getOrderListResponse
#define SOAP_TYPE_ns2__getOrderListResponse (19)
/* complex XML schema type 'ns2:getOrderListResponse': */
class SOAP_CMAC ns2__getOrderListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:183 */
#ifndef SOAP_TYPE_ns2__getShopByNameAndPwd
#define SOAP_TYPE_ns2__getShopByNameAndPwd (20)
/* complex XML schema type 'ns2:getShopByNameAndPwd': */
class SOAP_CMAC ns2__getShopByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__getShopByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__getShopByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getShopByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__getShopByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__getShopByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:185 */
#ifndef SOAP_TYPE_ns2__getShopByNameAndPwdResponse
#define SOAP_TYPE_ns2__getShopByNameAndPwdResponse (21)
/* complex XML schema type 'ns2:getShopByNameAndPwdResponse': */
class SOAP_CMAC ns2__getShopByNameAndPwdResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:shop'
        ns2__shop *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__getShopByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__getShopByNameAndPwdResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getShopByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__getShopByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:187 */
#ifndef SOAP_TYPE_ns2__shop
#define SOAP_TYPE_ns2__shop (22)
/* complex XML schema type 'ns2:shop': */
class SOAP_CMAC ns2__shop {
      public:
        /// Optional element 'shopEmail' of XML schema type 'xsd:string'
        std::string *shopEmail;
        /// Required element 'shopId' of XML schema type 'xsd:int'
        int shopId;
        /// Optional element 'shopImage' of XML schema type 'xsd:string'
        std::string *shopImage;
        /// Optional element 'shopName' of XML schema type 'xsd:string'
        std::string *shopName;
        /// Optional element 'shopPhone' of XML schema type 'xsd:string'
        std::string *shopPhone;
        /// Optional element 'shopPwd' of XML schema type 'xsd:string'
        std::string *shopPwd;
        /// Optional element 'shopSignTime' of XML schema type 'xsd:dateTime'
        time_t *shopSignTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__shop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__shop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__shop, default initialized and not managed by a soap context
        virtual ns2__shop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__shop); }
      public:
        /// Constructor with default initializations
        ns2__shop() : shopEmail(), shopId(), shopImage(), shopName(), shopPhone(), shopPwd(), shopSignTime(), soap() { }
        ns2__shop(std::string* email, int id, std::string* image, std::string* name, std::string* phone, std::string* pwd, time_t* time)
            : shopEmail(email), shopId(id), shopImage(image), shopName(name), shopPhone(phone), shopPwd(pwd), shopSignTime(time), soap() {
        }
        /// Destructor
        virtual ~ns2__shop() { }
        /// Friend allocator used by soap_new_ns2__shop(struct soap*, int)
        friend SOAP_FMAC1 ns2__shop * SOAP_FMAC2 soap_instantiate_ns2__shop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:189 */
#ifndef SOAP_TYPE_ns2__updateShop
#define SOAP_TYPE_ns2__updateShop (23)
/* complex XML schema type 'ns2:updateShop': */
class SOAP_CMAC ns2__updateShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateShop, default initialized and not managed by a soap context
        virtual ns2__updateShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateShop); }
      public:
        /// Constructor with default initializations
        ns2__updateShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateShop() { }
        /// Friend allocator used by soap_new_ns2__updateShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateShop * SOAP_FMAC2 soap_instantiate_ns2__updateShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:191 */
#ifndef SOAP_TYPE_ns2__updateShopResponse
#define SOAP_TYPE_ns2__updateShopResponse (24)
/* complex XML schema type 'ns2:updateShopResponse': */
class SOAP_CMAC ns2__updateShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateShopResponse, default initialized and not managed by a soap context
        virtual ns2__updateShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateShopResponse() { }
        /// Friend allocator used by soap_new_ns2__updateShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateShopResponse * SOAP_FMAC2 soap_instantiate_ns2__updateShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:193 */
#ifndef SOAP_TYPE_ns2__getProductListByInfo
#define SOAP_TYPE_ns2__getProductListByInfo (25)
/* complex XML schema type 'ns2:getProductListByInfo': */
class SOAP_CMAC ns2__getProductListByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductListByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductListByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductListByInfo, default initialized and not managed by a soap context
        virtual ns2__getProductListByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductListByInfo); }
      public:
        /// Constructor with default initializations
        ns2__getProductListByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getProductListByInfo() { }
        /// Friend allocator used by soap_new_ns2__getProductListByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductListByInfo * SOAP_FMAC2 soap_instantiate_ns2__getProductListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:195 */
#ifndef SOAP_TYPE_ns2__getProductListByInfoResponse
#define SOAP_TYPE_ns2__getProductListByInfoResponse (26)
/* complex XML schema type 'ns2:getProductListByInfoResponse': */
class SOAP_CMAC ns2__getProductListByInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        std::vector<ns2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductListByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductListByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductListByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__getProductListByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductListByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductListByInfoResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductListByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductListByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductListByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductListByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:197 */
#ifndef SOAP_TYPE_ns2__getReadMessageFromShop
#define SOAP_TYPE_ns2__getReadMessageFromShop (27)
/* complex XML schema type 'ns2:getReadMessageFromShop': */
class SOAP_CMAC ns2__getReadMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:199 */
#ifndef SOAP_TYPE_ns2__client
#define SOAP_TYPE_ns2__client (28)
/* complex XML schema type 'ns2:client': */
class SOAP_CMAC ns2__client {
      public:
        /// Required element 'clientBought' of XML schema type 'xsd:int'
        int clientBought;
        /// Optional element 'clientEmail' of XML schema type 'xsd:string'
        std::string *clientEmail;
        /// Required element 'clientId' of XML schema type 'xsd:int'
        int clientId;
        /// Optional element 'clientImage' of XML schema type 'xsd:string'
        std::string *clientImage;
        /// Optional element 'clientName' of XML schema type 'xsd:string'
        std::string *clientName;
        /// Optional element 'clientPhone' of XML schema type 'xsd:string'
        std::string *clientPhone;
        /// Optional element 'clientPwd' of XML schema type 'xsd:string'
        std::string *clientPwd;
        /// Optional element 'clientSignTime' of XML schema type 'xsd:dateTime'
        time_t *clientSignTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__client
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__client; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__client, default initialized and not managed by a soap context
        virtual ns2__client *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__client); }
      public:
        /// Constructor with default initializations
        ns2__client() : clientBought(), clientEmail(), clientId(), clientImage(), clientName(), clientPhone(), clientPwd(), clientSignTime(), soap() { }
        ns2__client(int bought, std::string* email, int id, std::string* image, std::string* name, std::string* phone, std::string* pwd, time_t* time) :
            clientBought(bought), clientEmail(email), clientId(id), clientImage(image), clientName(name), clientPhone(phone), clientPwd(pwd), clientSignTime(time), soap() {
        }
        /// Destructor
        virtual ~ns2__client() { }
        /// Friend allocator used by soap_new_ns2__client(struct soap*, int)
        friend SOAP_FMAC1 ns2__client * SOAP_FMAC2 soap_instantiate_ns2__client(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:201 */
#ifndef SOAP_TYPE_ns2__getReadMessageFromShopResponse
#define SOAP_TYPE_ns2__getReadMessageFromShopResponse (29)
/* complex XML schema type 'ns2:getReadMessageFromShopResponse': */
class SOAP_CMAC ns2__getReadMessageFromShopResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromShopResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:203 */
#ifndef SOAP_TYPE_ns2__message
#define SOAP_TYPE_ns2__message (30)
/* complex XML schema type 'ns2:message': */
class SOAP_CMAC ns2__message {
      public:
        /// Required element 'msgClientId' of XML schema type 'xsd:int'
        int msgClientId;
        /// Optional element 'msgClientName' of XML schema type 'xsd:string'
        std::string *msgClientName;
        /// Optional element 'msgContent' of XML schema type 'xsd:string'
        std::string *msgContent;
        /// Required element 'msgFrom' of XML schema type 'xsd:int'
        int msgFrom;
        /// Required element 'msgId' of XML schema type 'xsd:int'
        int msgId;
        /// Required element 'msgShopId' of XML schema type 'xsd:int'
        int msgShopId;
        /// Optional element 'msgShopName' of XML schema type 'xsd:string'
        std::string *msgShopName;
        /// Optional element 'msgTime' of XML schema type 'xsd:dateTime'
        time_t *msgTime;
        /// Required element 'readStatus' of XML schema type 'xsd:int'
        int readStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__message
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__message, default initialized and not managed by a soap context
        virtual ns2__message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__message); }
      public:
        /// Constructor with default initializations
        ns2__message() : msgClientId(), msgClientName(), msgContent(), msgFrom(), msgId(), msgShopId(), msgShopName(), msgTime(), readStatus(), soap() { }
        ns2__message(int clientId, std::string* content, int id, int shopId, time_t* Time, int readStatus, std::string* clientName, std::string* shopName, int msgFrom)
            : msgClientId(clientId), msgContent(content), msgId(id), msgShopId(shopId), msgTime(Time), readStatus(readStatus), msgClientName(clientName), msgShopName(shopName), msgFrom(msgFrom), soap() {
        }
        /// Destructor
        virtual ~ns2__message() { }
        /// Friend allocator used by soap_new_ns2__message(struct soap*, int)
        friend SOAP_FMAC1 ns2__message * SOAP_FMAC2 soap_instantiate_ns2__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:205 */
#ifndef SOAP_TYPE_ns2__updateClient
#define SOAP_TYPE_ns2__updateClient (31)
/* complex XML schema type 'ns2:updateClient': */
class SOAP_CMAC ns2__updateClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateClient, default initialized and not managed by a soap context
        virtual ns2__updateClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateClient); }
      public:
        /// Constructor with default initializations
        ns2__updateClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateClient() { }
        /// Friend allocator used by soap_new_ns2__updateClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateClient * SOAP_FMAC2 soap_instantiate_ns2__updateClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:207 */
#ifndef SOAP_TYPE_ns2__updateClientResponse
#define SOAP_TYPE_ns2__updateClientResponse (32)
/* complex XML schema type 'ns2:updateClientResponse': */
class SOAP_CMAC ns2__updateClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateClientResponse, default initialized and not managed by a soap context
        virtual ns2__updateClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateClientResponse() { }
        /// Friend allocator used by soap_new_ns2__updateClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateClientResponse * SOAP_FMAC2 soap_instantiate_ns2__updateClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:209 */
#ifndef SOAP_TYPE_ns2__deleteProductByInfo
#define SOAP_TYPE_ns2__deleteProductByInfo (33)
/* complex XML schema type 'ns2:deleteProductByInfo': */
class SOAP_CMAC ns2__deleteProductByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductByInfo, default initialized and not managed by a soap context
        virtual ns2__deleteProductByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductByInfo); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__deleteProductByInfo() { }
        /// Friend allocator used by soap_new_ns2__deleteProductByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductByInfo * SOAP_FMAC2 soap_instantiate_ns2__deleteProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:211 */
#ifndef SOAP_TYPE_ns2__deleteProductByInfoResponse
#define SOAP_TYPE_ns2__deleteProductByInfoResponse (34)
/* complex XML schema type 'ns2:deleteProductByInfoResponse': */
class SOAP_CMAC ns2__deleteProductByInfoResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteProductByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteProductByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteProductByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__deleteProductByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteProductByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteProductByInfoResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteProductByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteProductByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteProductByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteProductByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:213 */
#ifndef SOAP_TYPE_ns2__deleteClientByNameAndPwd
#define SOAP_TYPE_ns2__deleteClientByNameAndPwd (35)
/* complex XML schema type 'ns2:deleteClientByNameAndPwd': */
class SOAP_CMAC ns2__deleteClientByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteClientByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteClientByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteClientByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__deleteClientByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteClientByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__deleteClientByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteClientByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__deleteClientByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__deleteClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:215 */
#ifndef SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse
#define SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse (36)
/* complex XML schema type 'ns2:deleteClientByNameAndPwdResponse': */
class SOAP_CMAC ns2__deleteClientByNameAndPwdResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteClientByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__deleteClientByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteClientByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteClientByNameAndPwdResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteClientByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteClientByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteClientByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:217 */
#ifndef SOAP_TYPE_ns2__InsertShop
#define SOAP_TYPE_ns2__InsertShop (37)
/* complex XML schema type 'ns2:InsertShop': */
class SOAP_CMAC ns2__InsertShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertShop, default initialized and not managed by a soap context
        virtual ns2__InsertShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertShop); }
      public:
        /// Constructor with default initializations
        ns2__InsertShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__InsertShop() { }
        /// Friend allocator used by soap_new_ns2__InsertShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertShop * SOAP_FMAC2 soap_instantiate_ns2__InsertShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:219 */
#ifndef SOAP_TYPE_ns2__InsertShopResponse
#define SOAP_TYPE_ns2__InsertShopResponse (38)
/* complex XML schema type 'ns2:InsertShopResponse': */
class SOAP_CMAC ns2__InsertShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertShopResponse, default initialized and not managed by a soap context
        virtual ns2__InsertShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__InsertShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__InsertShopResponse() { }
        /// Friend allocator used by soap_new_ns2__InsertShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertShopResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:221 */
#ifndef SOAP_TYPE_ns2__updateMessageFromShop
#define SOAP_TYPE_ns2__updateMessageFromShop (39)
/* complex XML schema type 'ns2:updateMessageFromShop': */
class SOAP_CMAC ns2__updateMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromShop() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:223 */
#ifndef SOAP_TYPE_ns2__updateMessageFromShopResponse
#define SOAP_TYPE_ns2__updateMessageFromShopResponse (40)
/* complex XML schema type 'ns2:updateMessageFromShopResponse': */
class SOAP_CMAC ns2__updateMessageFromShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:225 */
#ifndef SOAP_TYPE_ns2__getProductTypeByProName
#define SOAP_TYPE_ns2__getProductTypeByProName (41)
/* complex XML schema type 'ns2:getProductTypeByProName': */
class SOAP_CMAC ns2__getProductTypeByProName {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductTypeByProName
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductTypeByProName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductTypeByProName, default initialized and not managed by a soap context
        virtual ns2__getProductTypeByProName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductTypeByProName); }
      public:
        /// Constructor with default initializations
        ns2__getProductTypeByProName() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getProductTypeByProName() { }
        /// Friend allocator used by soap_new_ns2__getProductTypeByProName(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductTypeByProName * SOAP_FMAC2 soap_instantiate_ns2__getProductTypeByProName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:227 */
#ifndef SOAP_TYPE_ns2__getProductTypeByProNameResponse
#define SOAP_TYPE_ns2__getProductTypeByProNameResponse (42)
/* complex XML schema type 'ns2:getProductTypeByProNameResponse': */
class SOAP_CMAC ns2__getProductTypeByProNameResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:productType'
        std::vector<ns2__productType *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductTypeByProNameResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductTypeByProNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductTypeByProNameResponse, default initialized and not managed by a soap context
        virtual ns2__getProductTypeByProNameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductTypeByProNameResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductTypeByProNameResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductTypeByProNameResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductTypeByProNameResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductTypeByProNameResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductTypeByProNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:229 */
#ifndef SOAP_TYPE_ns2__productType
#define SOAP_TYPE_ns2__productType (43)
/* complex XML schema type 'ns2:productType': */
class SOAP_CMAC ns2__productType {
      public:
        /// Required element 'typeId' of XML schema type 'xsd:int'
        int typeId;
        /// Optional element 'typeName' of XML schema type 'xsd:string'
        std::string *typeName;
        /// Optional element 'typeProduct' of XML schema type 'xsd:string'
        std::string *typeProduct;
        /// Required element 'typeProductId' of XML schema type 'xsd:int'
        int typeProductId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__productType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__productType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__productType, default initialized and not managed by a soap context
        virtual ns2__productType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__productType); }
      public:
        /// Constructor with default initializations
        ns2__productType() : typeId(), typeName(), typeProduct(), typeProductId(), soap() { }
        /// Destructor
        virtual ~ns2__productType() { }
        /// Friend allocator used by soap_new_ns2__productType(struct soap*, int)
        friend SOAP_FMAC1 ns2__productType * SOAP_FMAC2 soap_instantiate_ns2__productType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:231 */
#ifndef SOAP_TYPE_ns2__getClientList
#define SOAP_TYPE_ns2__getClientList (44)
/* complex XML schema type 'ns2:getClientList': */
class SOAP_CMAC ns2__getClientList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientList, default initialized and not managed by a soap context
        virtual ns2__getClientList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientList); }
      public:
        /// Constructor with default initializations
        ns2__getClientList() : soap() { }
        /// Destructor
        virtual ~ns2__getClientList() { }
        /// Friend allocator used by soap_new_ns2__getClientList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientList * SOAP_FMAC2 soap_instantiate_ns2__getClientList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:233 */
#ifndef SOAP_TYPE_ns2__getClientListResponse
#define SOAP_TYPE_ns2__getClientListResponse (45)
/* complex XML schema type 'ns2:getClientListResponse': */
class SOAP_CMAC ns2__getClientListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:client'
        std::vector<ns2__client *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientListResponse, default initialized and not managed by a soap context
        virtual ns2__getClientListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getClientListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getClientListResponse() { }
        /// Friend allocator used by soap_new_ns2__getClientListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientListResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:235 */
#ifndef SOAP_TYPE_ns2__purchaseProduct
#define SOAP_TYPE_ns2__purchaseProduct (46)
/* complex XML schema type 'ns2:purchaseProduct': */
class SOAP_CMAC ns2__purchaseProduct {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__purchaseProduct
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__purchaseProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__purchaseProduct, default initialized and not managed by a soap context
        virtual ns2__purchaseProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__purchaseProduct); }
      public:
        /// Constructor with default initializations
        ns2__purchaseProduct() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__purchaseProduct() { }
        /// Friend allocator used by soap_new_ns2__purchaseProduct(struct soap*, int)
        friend SOAP_FMAC1 ns2__purchaseProduct * SOAP_FMAC2 soap_instantiate_ns2__purchaseProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:237 */
#ifndef SOAP_TYPE_ns2__purchaseProductResponse
#define SOAP_TYPE_ns2__purchaseProductResponse (47)
/* complex XML schema type 'ns2:purchaseProductResponse': */
class SOAP_CMAC ns2__purchaseProductResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__purchaseProductResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__purchaseProductResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__purchaseProductResponse, default initialized and not managed by a soap context
        virtual ns2__purchaseProductResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__purchaseProductResponse); }
      public:
        /// Constructor with default initializations
        ns2__purchaseProductResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__purchaseProductResponse() { }
        /// Friend allocator used by soap_new_ns2__purchaseProductResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__purchaseProductResponse * SOAP_FMAC2 soap_instantiate_ns2__purchaseProductResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:239 */
#ifndef SOAP_TYPE_ns2__updateMessageFromClient
#define SOAP_TYPE_ns2__updateMessageFromClient (48)
/* complex XML schema type 'ns2:updateMessageFromClient': */
class SOAP_CMAC ns2__updateMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromClient() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:241 */
#ifndef SOAP_TYPE_ns2__updateMessageFromClientResponse
#define SOAP_TYPE_ns2__updateMessageFromClientResponse (49)
/* complex XML schema type 'ns2:updateMessageFromClientResponse': */
class SOAP_CMAC ns2__updateMessageFromClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__updateMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateMessageFromClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__updateMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:243 */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromClient
#define SOAP_TYPE_ns2__getUnreadMessageFromClient (50)
/* complex XML schema type 'ns2:getUnreadMessageFromClient': */
class SOAP_CMAC ns2__getUnreadMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:245 */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromClientResponse
#define SOAP_TYPE_ns2__getUnreadMessageFromClientResponse (51)
/* complex XML schema type 'ns2:getUnreadMessageFromClientResponse': */
class SOAP_CMAC ns2__getUnreadMessageFromClientResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromClientResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:247 */
#ifndef SOAP_TYPE_ns2__updateProductByInfo
#define SOAP_TYPE_ns2__updateProductByInfo (52)
/* complex XML schema type 'ns2:updateProductByInfo': */
class SOAP_CMAC ns2__updateProductByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:product'
        ns2__product *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateProductByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateProductByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateProductByInfo, default initialized and not managed by a soap context
        virtual ns2__updateProductByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateProductByInfo); }
      public:
        /// Constructor with default initializations
        ns2__updateProductByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateProductByInfo() { }
        /// Friend allocator used by soap_new_ns2__updateProductByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateProductByInfo * SOAP_FMAC2 soap_instantiate_ns2__updateProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:249 */
#ifndef SOAP_TYPE_ns2__updateProductByInfoResponse
#define SOAP_TYPE_ns2__updateProductByInfoResponse (53)
/* complex XML schema type 'ns2:updateProductByInfoResponse': */
class SOAP_CMAC ns2__updateProductByInfoResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateProductByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateProductByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateProductByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__updateProductByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateProductByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateProductByInfoResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateProductByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__updateProductByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateProductByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__updateProductByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:251 */
#ifndef SOAP_TYPE_ns2__getMessageFromClient
#define SOAP_TYPE_ns2__getMessageFromClient (54)
/* complex XML schema type 'ns2:getMessageFromClient': */
class SOAP_CMAC ns2__getMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__getMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:253 */
#ifndef SOAP_TYPE_ns2__getMessageFromClientResponse
#define SOAP_TYPE_ns2__getMessageFromClientResponse (55)
/* complex XML schema type 'ns2:getMessageFromClientResponse': */
class SOAP_CMAC ns2__getMessageFromClientResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__getMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromClientResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:255 */
#ifndef SOAP_TYPE_ns2__addOrder
#define SOAP_TYPE_ns2__addOrder (56)
/* complex XML schema type 'ns2:addOrder': */
class SOAP_CMAC ns2__addOrder {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addOrder
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addOrder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addOrder, default initialized and not managed by a soap context
        virtual ns2__addOrder *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addOrder); }
      public:
        /// Constructor with default initializations
        ns2__addOrder() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__addOrder() { }
        /// Friend allocator used by soap_new_ns2__addOrder(struct soap*, int)
        friend SOAP_FMAC1 ns2__addOrder * SOAP_FMAC2 soap_instantiate_ns2__addOrder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:257 */
#ifndef SOAP_TYPE_ns2__addOrderResponse
#define SOAP_TYPE_ns2__addOrderResponse (57)
/* complex XML schema type 'ns2:addOrderResponse': */
class SOAP_CMAC ns2__addOrderResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addOrderResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addOrderResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addOrderResponse, default initialized and not managed by a soap context
        virtual ns2__addOrderResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addOrderResponse); }
      public:
        /// Constructor with default initializations
        ns2__addOrderResponse() : soap() { }
        /// Destructor
        virtual ~ns2__addOrderResponse() { }
        /// Friend allocator used by soap_new_ns2__addOrderResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__addOrderResponse * SOAP_FMAC2 soap_instantiate_ns2__addOrderResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:259 */
#ifndef SOAP_TYPE_ns2__deleteShopByNameAndPwd
#define SOAP_TYPE_ns2__deleteShopByNameAndPwd (58)
/* complex XML schema type 'ns2:deleteShopByNameAndPwd': */
class SOAP_CMAC ns2__deleteShopByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShopByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShopByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShopByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__deleteShopByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShopByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__deleteShopByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteShopByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__deleteShopByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShopByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__deleteShopByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:261 */
#ifndef SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse
#define SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse (59)
/* complex XML schema type 'ns2:deleteShopByNameAndPwdResponse': */
class SOAP_CMAC ns2__deleteShopByNameAndPwdResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShopByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__deleteShopByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShopByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteShopByNameAndPwdResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteShopByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteShopByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShopByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteShopByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:263 */
#ifndef SOAP_TYPE_ns2__getProductList
#define SOAP_TYPE_ns2__getProductList (60)
/* complex XML schema type 'ns2:getProductList': */
class SOAP_CMAC ns2__getProductList {
      public:
        /// Required element 'arg0' of XML schema type 'xsd:int'
        int arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductList, default initialized and not managed by a soap context
        virtual ns2__getProductList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductList); }
      public:
        /// Constructor with default initializations
        ns2__getProductList() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getProductList() { }
        /// Friend allocator used by soap_new_ns2__getProductList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductList * SOAP_FMAC2 soap_instantiate_ns2__getProductList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:265 */
#ifndef SOAP_TYPE_ns2__getProductListResponse
#define SOAP_TYPE_ns2__getProductListResponse (61)
/* complex XML schema type 'ns2:getProductListResponse': */
class SOAP_CMAC ns2__getProductListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        std::vector<ns2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductListResponse, default initialized and not managed by a soap context
        virtual ns2__getProductListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductListResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductListResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:267 */
#ifndef SOAP_TYPE_ns2__getOrderListHistory
#define SOAP_TYPE_ns2__getOrderListHistory (62)
/* complex XML schema type 'ns2:getOrderListHistory': */
class SOAP_CMAC ns2__getOrderListHistory {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListHistory
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListHistory, default initialized and not managed by a soap context
        virtual ns2__getOrderListHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListHistory); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListHistory() : soap() { }
        /// Destructor
        virtual ~ns2__getOrderListHistory() { }
        /// Friend allocator used by soap_new_ns2__getOrderListHistory(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListHistory * SOAP_FMAC2 soap_instantiate_ns2__getOrderListHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:269 */
#ifndef SOAP_TYPE_ns2__getOrderListHistoryResponse
#define SOAP_TYPE_ns2__getOrderListHistoryResponse (63)
/* complex XML schema type 'ns2:getOrderListHistoryResponse': */
class SOAP_CMAC ns2__getOrderListHistoryResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListHistoryResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderListHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListHistoryResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListHistoryResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListHistoryResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderListHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListHistoryResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:271 */
#ifndef SOAP_TYPE_ns2__getReadMessageFromClient
#define SOAP_TYPE_ns2__getReadMessageFromClient (64)
/* complex XML schema type 'ns2:getReadMessageFromClient': */
class SOAP_CMAC ns2__getReadMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:shop'
        ns2__shop *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:273 */
#ifndef SOAP_TYPE_ns2__getReadMessageFromClientResponse
#define SOAP_TYPE_ns2__getReadMessageFromClientResponse (65)
/* complex XML schema type 'ns2:getReadMessageFromClientResponse': */
class SOAP_CMAC ns2__getReadMessageFromClientResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getReadMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getReadMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getReadMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__getReadMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getReadMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__getReadMessageFromClientResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getReadMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__getReadMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getReadMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:275 */
#ifndef SOAP_TYPE_ns2__updateHistory
#define SOAP_TYPE_ns2__updateHistory (66)
/* complex XML schema type 'ns2:updateHistory': */
class SOAP_CMAC ns2__updateHistory {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateHistory
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateHistory, default initialized and not managed by a soap context
        virtual ns2__updateHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateHistory); }
      public:
        /// Constructor with default initializations
        ns2__updateHistory() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__updateHistory() { }
        /// Friend allocator used by soap_new_ns2__updateHistory(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateHistory * SOAP_FMAC2 soap_instantiate_ns2__updateHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:277 */
#ifndef SOAP_TYPE_ns2__updateHistoryResponse
#define SOAP_TYPE_ns2__updateHistoryResponse (67)
/* complex XML schema type 'ns2:updateHistoryResponse': */
class SOAP_CMAC ns2__updateHistoryResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__updateHistoryResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__updateHistoryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__updateHistoryResponse, default initialized and not managed by a soap context
        virtual ns2__updateHistoryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__updateHistoryResponse); }
      public:
        /// Constructor with default initializations
        ns2__updateHistoryResponse() : soap() { }
        /// Destructor
        virtual ~ns2__updateHistoryResponse() { }
        /// Friend allocator used by soap_new_ns2__updateHistoryResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__updateHistoryResponse * SOAP_FMAC2 soap_instantiate_ns2__updateHistoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:279 */
#ifndef SOAP_TYPE_ns2__InsertMessage
#define SOAP_TYPE_ns2__InsertMessage (68)
/* complex XML schema type 'ns2:InsertMessage': */
class SOAP_CMAC ns2__InsertMessage {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertMessage
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertMessage, default initialized and not managed by a soap context
        virtual ns2__InsertMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertMessage); }
      public:
        /// Constructor with default initializations
        ns2__InsertMessage() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__InsertMessage() { }
        /// Friend allocator used by soap_new_ns2__InsertMessage(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertMessage * SOAP_FMAC2 soap_instantiate_ns2__InsertMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:281 */
#ifndef SOAP_TYPE_ns2__InsertMessageResponse
#define SOAP_TYPE_ns2__InsertMessageResponse (69)
/* complex XML schema type 'ns2:InsertMessageResponse': */
class SOAP_CMAC ns2__InsertMessageResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertMessageResponse, default initialized and not managed by a soap context
        virtual ns2__InsertMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertMessageResponse); }
      public:
        /// Constructor with default initializations
        ns2__InsertMessageResponse() : soap() { }
        /// Destructor
        virtual ~ns2__InsertMessageResponse() { }
        /// Friend allocator used by soap_new_ns2__InsertMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertMessageResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:283 */
#ifndef SOAP_TYPE_ns2__getShopLikeList
#define SOAP_TYPE_ns2__getShopLikeList (70)
/* complex XML schema type 'ns2:getShopLikeList': */
class SOAP_CMAC ns2__getShopLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopLikeList, default initialized and not managed by a soap context
        virtual ns2__getShopLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getShopLikeList() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getShopLikeList() { }
        /// Friend allocator used by soap_new_ns2__getShopLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopLikeList * SOAP_FMAC2 soap_instantiate_ns2__getShopLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:285 */
#ifndef SOAP_TYPE_ns2__getShopLikeListResponse
#define SOAP_TYPE_ns2__getShopLikeListResponse (71)
/* complex XML schema type 'ns2:getShopLikeListResponse': */
class SOAP_CMAC ns2__getShopLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:shop'
        std::vector<ns2__shop *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getShopLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getShopLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getShopLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getShopLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:287 */
#ifndef SOAP_TYPE_ns2__getMessageFromShop
#define SOAP_TYPE_ns2__getMessageFromShop (72)
/* complex XML schema type 'ns2:getMessageFromShop': */
class SOAP_CMAC ns2__getMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__getMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:289 */
#ifndef SOAP_TYPE_ns2__getMessageFromShopResponse
#define SOAP_TYPE_ns2__getMessageFromShopResponse (73)
/* complex XML schema type 'ns2:getMessageFromShopResponse': */
class SOAP_CMAC ns2__getMessageFromShopResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__getMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__getMessageFromShopResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__getMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:291 */
#ifndef SOAP_TYPE_ns2__deleteMessageFromShop
#define SOAP_TYPE_ns2__deleteMessageFromShop (74)
/* complex XML schema type 'ns2:deleteMessageFromShop': */
class SOAP_CMAC ns2__deleteMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromShop() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:293 */
#ifndef SOAP_TYPE_ns2__deleteMessageFromShopResponse
#define SOAP_TYPE_ns2__deleteMessageFromShopResponse (75)
/* complex XML schema type 'ns2:deleteMessageFromShopResponse': */
class SOAP_CMAC ns2__deleteMessageFromShopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromShopResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:295 */
#ifndef SOAP_TYPE_ns2__getOrderLikeList
#define SOAP_TYPE_ns2__getOrderLikeList (76)
/* complex XML schema type 'ns2:getOrderLikeList': */
class SOAP_CMAC ns2__getOrderLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns2:order'
        ns2__order *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderLikeList, default initialized and not managed by a soap context
        virtual ns2__getOrderLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getOrderLikeList() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderLikeList() { }
        /// Friend allocator used by soap_new_ns2__getOrderLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderLikeList * SOAP_FMAC2 soap_instantiate_ns2__getOrderLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:297 */
#ifndef SOAP_TYPE_ns2__getOrderLikeListResponse
#define SOAP_TYPE_ns2__getOrderLikeListResponse (77)
/* complex XML schema type 'ns2:getOrderLikeListResponse': */
class SOAP_CMAC ns2__getOrderLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:299 */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromShop
#define SOAP_TYPE_ns2__getUnreadMessageFromShop (78)
/* complex XML schema type 'ns2:getUnreadMessageFromShop': */
class SOAP_CMAC ns2__getUnreadMessageFromShop {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromShop
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromShop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromShop, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromShop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromShop); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromShop() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromShop() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromShop(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:301 */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromShopResponse
#define SOAP_TYPE_ns2__getUnreadMessageFromShopResponse (79)
/* complex XML schema type 'ns2:getUnreadMessageFromShopResponse': */
class SOAP_CMAC ns2__getUnreadMessageFromShopResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:message'
        std::vector<ns2__message *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getUnreadMessageFromShopResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getUnreadMessageFromShopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getUnreadMessageFromShopResponse, default initialized and not managed by a soap context
        virtual ns2__getUnreadMessageFromShopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getUnreadMessageFromShopResponse); }
      public:
        /// Constructor with default initializations
        ns2__getUnreadMessageFromShopResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getUnreadMessageFromShopResponse() { }
        /// Friend allocator used by soap_new_ns2__getUnreadMessageFromShopResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getUnreadMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromShopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:303 */
#ifndef SOAP_TYPE_ns2__getClientLikeList
#define SOAP_TYPE_ns2__getClientLikeList (80)
/* complex XML schema type 'ns2:getClientLikeList': */
class SOAP_CMAC ns2__getClientLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientLikeList, default initialized and not managed by a soap context
        virtual ns2__getClientLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getClientLikeList() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getClientLikeList() { }
        /// Friend allocator used by soap_new_ns2__getClientLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientLikeList * SOAP_FMAC2 soap_instantiate_ns2__getClientLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:305 */
#ifndef SOAP_TYPE_ns2__getClientLikeListResponse
#define SOAP_TYPE_ns2__getClientLikeListResponse (81)
/* complex XML schema type 'ns2:getClientLikeListResponse': */
class SOAP_CMAC ns2__getClientLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:client'
        std::vector<ns2__client *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getClientLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getClientLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getClientLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getClientLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:307 */
#ifndef SOAP_TYPE_ns2__getShopList
#define SOAP_TYPE_ns2__getShopList (82)
/* complex XML schema type 'ns2:getShopList': */
class SOAP_CMAC ns2__getShopList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopList, default initialized and not managed by a soap context
        virtual ns2__getShopList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopList); }
      public:
        /// Constructor with default initializations
        ns2__getShopList() : soap() { }
        /// Destructor
        virtual ~ns2__getShopList() { }
        /// Friend allocator used by soap_new_ns2__getShopList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopList * SOAP_FMAC2 soap_instantiate_ns2__getShopList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:309 */
#ifndef SOAP_TYPE_ns2__getShopListResponse
#define SOAP_TYPE_ns2__getShopListResponse (83)
/* complex XML schema type 'ns2:getShopListResponse': */
class SOAP_CMAC ns2__getShopListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:shop'
        std::vector<ns2__shop *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getShopListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getShopListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getShopListResponse, default initialized and not managed by a soap context
        virtual ns2__getShopListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getShopListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getShopListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getShopListResponse() { }
        /// Friend allocator used by soap_new_ns2__getShopListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getShopListResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:311 */
#ifndef SOAP_TYPE_ns2__getOrderListByInfo
#define SOAP_TYPE_ns2__getOrderListByInfo (84)
/* complex XML schema type 'ns2:getOrderListByInfo': */
class SOAP_CMAC ns2__getOrderListByInfo {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListByInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListByInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListByInfo, default initialized and not managed by a soap context
        virtual ns2__getOrderListByInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListByInfo); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListByInfo() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListByInfo() { }
        /// Friend allocator used by soap_new_ns2__getOrderListByInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListByInfo * SOAP_FMAC2 soap_instantiate_ns2__getOrderListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:313 */
#ifndef SOAP_TYPE_ns2__getOrderListByInfoResponse
#define SOAP_TYPE_ns2__getOrderListByInfoResponse (85)
/* complex XML schema type 'ns2:getOrderListByInfoResponse': */
class SOAP_CMAC ns2__getOrderListByInfoResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:order'
        std::vector<ns2__order *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getOrderListByInfoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getOrderListByInfoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getOrderListByInfoResponse, default initialized and not managed by a soap context
        virtual ns2__getOrderListByInfoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getOrderListByInfoResponse); }
      public:
        /// Constructor with default initializations
        ns2__getOrderListByInfoResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getOrderListByInfoResponse() { }
        /// Friend allocator used by soap_new_ns2__getOrderListByInfoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getOrderListByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListByInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:315 */
#ifndef SOAP_TYPE_ns2__addProductType
#define SOAP_TYPE_ns2__addProductType (86)
/* complex XML schema type 'ns2:addProductType': */
class SOAP_CMAC ns2__addProductType {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:productType'
        ns2__productType *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProductType
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProductType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProductType, default initialized and not managed by a soap context
        virtual ns2__addProductType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProductType); }
      public:
        /// Constructor with default initializations
        ns2__addProductType() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__addProductType() { }
        /// Friend allocator used by soap_new_ns2__addProductType(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProductType * SOAP_FMAC2 soap_instantiate_ns2__addProductType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:317 */
#ifndef SOAP_TYPE_ns2__addProductTypeResponse
#define SOAP_TYPE_ns2__addProductTypeResponse (87)
/* complex XML schema type 'ns2:addProductTypeResponse': */
class SOAP_CMAC ns2__addProductTypeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__addProductTypeResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__addProductTypeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__addProductTypeResponse, default initialized and not managed by a soap context
        virtual ns2__addProductTypeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__addProductTypeResponse); }
      public:
        /// Constructor with default initializations
        ns2__addProductTypeResponse() : soap() { }
        /// Destructor
        virtual ~ns2__addProductTypeResponse() { }
        /// Friend allocator used by soap_new_ns2__addProductTypeResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__addProductTypeResponse * SOAP_FMAC2 soap_instantiate_ns2__addProductTypeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:319 */
#ifndef SOAP_TYPE_ns2__deleteMessageFromClient
#define SOAP_TYPE_ns2__deleteMessageFromClient (88)
/* complex XML schema type 'ns2:deleteMessageFromClient': */
class SOAP_CMAC ns2__deleteMessageFromClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:message'
        ns2__message *arg0;
        /// Required element 'arg1' of XML schema type 'xsd:int'
        int arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromClient, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromClient); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromClient() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromClient() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:321 */
#ifndef SOAP_TYPE_ns2__deleteMessageFromClientResponse
#define SOAP_TYPE_ns2__deleteMessageFromClientResponse (89)
/* complex XML schema type 'ns2:deleteMessageFromClientResponse': */
class SOAP_CMAC ns2__deleteMessageFromClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteMessageFromClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteMessageFromClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteMessageFromClientResponse, default initialized and not managed by a soap context
        virtual ns2__deleteMessageFromClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteMessageFromClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteMessageFromClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteMessageFromClientResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteMessageFromClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:323 */
#ifndef SOAP_TYPE_ns2__getProductLikeList
#define SOAP_TYPE_ns2__getProductLikeList (90)
/* complex XML schema type 'ns2:getProductLikeList': */
class SOAP_CMAC ns2__getProductLikeList {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns2:product'
        ns2__product *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductLikeList
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductLikeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductLikeList, default initialized and not managed by a soap context
        virtual ns2__getProductLikeList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductLikeList); }
      public:
        /// Constructor with default initializations
        ns2__getProductLikeList() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getProductLikeList() { }
        /// Friend allocator used by soap_new_ns2__getProductLikeList(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductLikeList * SOAP_FMAC2 soap_instantiate_ns2__getProductLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:325 */
#ifndef SOAP_TYPE_ns2__getProductLikeListResponse
#define SOAP_TYPE_ns2__getProductLikeListResponse (91)
/* complex XML schema type 'ns2:getProductLikeListResponse': */
class SOAP_CMAC ns2__getProductLikeListResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:product'
        std::vector<ns2__product *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getProductLikeListResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getProductLikeListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getProductLikeListResponse, default initialized and not managed by a soap context
        virtual ns2__getProductLikeListResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getProductLikeListResponse); }
      public:
        /// Constructor with default initializations
        ns2__getProductLikeListResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getProductLikeListResponse() { }
        /// Friend allocator used by soap_new_ns2__getProductLikeListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getProductLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductLikeListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:327 */
#ifndef SOAP_TYPE_ns2__getClientByNameAndPwd
#define SOAP_TYPE_ns2__getClientByNameAndPwd (92)
/* complex XML schema type 'ns2:getClientByNameAndPwd': */
class SOAP_CMAC ns2__getClientByNameAndPwd {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientByNameAndPwd
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientByNameAndPwd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientByNameAndPwd, default initialized and not managed by a soap context
        virtual ns2__getClientByNameAndPwd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientByNameAndPwd); }
      public:
        /// Constructor with default initializations
        ns2__getClientByNameAndPwd() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns2__getClientByNameAndPwd() { }
        /// Friend allocator used by soap_new_ns2__getClientByNameAndPwd(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__getClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:329 */
#ifndef SOAP_TYPE_ns2__getClientByNameAndPwdResponse
#define SOAP_TYPE_ns2__getClientByNameAndPwdResponse (93)
/* complex XML schema type 'ns2:getClientByNameAndPwdResponse': */
class SOAP_CMAC ns2__getClientByNameAndPwdResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns2:client'
        ns2__client *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__getClientByNameAndPwdResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__getClientByNameAndPwdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__getClientByNameAndPwdResponse, default initialized and not managed by a soap context
        virtual ns2__getClientByNameAndPwdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__getClientByNameAndPwdResponse); }
      public:
        /// Constructor with default initializations
        ns2__getClientByNameAndPwdResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns2__getClientByNameAndPwdResponse() { }
        /// Friend allocator used by soap_new_ns2__getClientByNameAndPwdResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__getClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientByNameAndPwdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:331 */
#ifndef SOAP_TYPE_ns2__deleteShoppingCart
#define SOAP_TYPE_ns2__deleteShoppingCart (94)
/* complex XML schema type 'ns2:deleteShoppingCart': */
class SOAP_CMAC ns2__deleteShoppingCart {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:order'
        ns2__order *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShoppingCart
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShoppingCart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShoppingCart, default initialized and not managed by a soap context
        virtual ns2__deleteShoppingCart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShoppingCart); }
      public:
        /// Constructor with default initializations
        ns2__deleteShoppingCart() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__deleteShoppingCart() { }
        /// Friend allocator used by soap_new_ns2__deleteShoppingCart(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShoppingCart * SOAP_FMAC2 soap_instantiate_ns2__deleteShoppingCart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:333 */
#ifndef SOAP_TYPE_ns2__deleteShoppingCartResponse
#define SOAP_TYPE_ns2__deleteShoppingCartResponse (95)
/* complex XML schema type 'ns2:deleteShoppingCartResponse': */
class SOAP_CMAC ns2__deleteShoppingCartResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__deleteShoppingCartResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__deleteShoppingCartResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__deleteShoppingCartResponse, default initialized and not managed by a soap context
        virtual ns2__deleteShoppingCartResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__deleteShoppingCartResponse); }
      public:
        /// Constructor with default initializations
        ns2__deleteShoppingCartResponse() : soap() { }
        /// Destructor
        virtual ~ns2__deleteShoppingCartResponse() { }
        /// Friend allocator used by soap_new_ns2__deleteShoppingCartResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__deleteShoppingCartResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteShoppingCartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:335 */
#ifndef SOAP_TYPE_ns2__InsertClient
#define SOAP_TYPE_ns2__InsertClient (96)
/* complex XML schema type 'ns2:InsertClient': */
class SOAP_CMAC ns2__InsertClient {
      public:
        /// Optional element 'arg0' of XML schema type 'ns2:client'
        ns2__client *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertClient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertClient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertClient, default initialized and not managed by a soap context
        virtual ns2__InsertClient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertClient); }
      public:
        /// Constructor with default initializations
        ns2__InsertClient() : arg0(), soap() { }
        /// Destructor
        virtual ~ns2__InsertClient() { }
        /// Friend allocator used by soap_new_ns2__InsertClient(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertClient * SOAP_FMAC2 soap_instantiate_ns2__InsertClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:337 */
#ifndef SOAP_TYPE_ns2__InsertClientResponse
#define SOAP_TYPE_ns2__InsertClientResponse (97)
/* complex XML schema type 'ns2:InsertClientResponse': */
class SOAP_CMAC ns2__InsertClientResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InsertClientResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InsertClientResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InsertClientResponse, default initialized and not managed by a soap context
        virtual ns2__InsertClientResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InsertClientResponse); }
      public:
        /// Constructor with default initializations
        ns2__InsertClientResponse() : soap() { }
        /// Destructor
        virtual ~ns2__InsertClientResponse() { }
        /// Friend allocator used by soap_new_ns2__InsertClientResponse(struct soap*, int)
        friend SOAP_FMAC1 ns2__InsertClientResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertClientResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:2744 */
#ifndef SOAP_TYPE___ns1__selectProductForUpdate
#define SOAP_TYPE___ns1__selectProductForUpdate (119)
/* Wrapper: */
struct SOAP_CMAC __ns1__selectProductForUpdate {
      public:
        /** Optional element 'ns2:selectProductForUpdate' of XML schema type 'ns2:selectProductForUpdate' */
        ns2__selectProductForUpdate *ns2__selectProductForUpdate_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__selectProductForUpdate */
        long soap_type() const { return SOAP_TYPE___ns1__selectProductForUpdate; }
        /** Constructor with member initializations */
        __ns1__selectProductForUpdate() : ns2__selectProductForUpdate_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__selectProductForUpdate * SOAP_FMAC2 soap_instantiate___ns1__selectProductForUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:2811 */
#ifndef SOAP_TYPE___ns1__addProduct
#define SOAP_TYPE___ns1__addProduct (123)
/* Wrapper: */
struct SOAP_CMAC __ns1__addProduct {
      public:
        /** Optional element 'ns2:addProduct' of XML schema type 'ns2:addProduct' */
        ns2__addProduct *ns2__addProduct_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__addProduct */
        long soap_type() const { return SOAP_TYPE___ns1__addProduct; }
        /** Constructor with member initializations */
        __ns1__addProduct() : ns2__addProduct_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__addProduct * SOAP_FMAC2 soap_instantiate___ns1__addProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:2878 */
#ifndef SOAP_TYPE___ns1__deleteProductTypeByName
#define SOAP_TYPE___ns1__deleteProductTypeByName (127)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteProductTypeByName {
      public:
        /** Optional element 'ns2:deleteProductTypeByName' of XML schema type 'ns2:deleteProductTypeByName' */
        ns2__deleteProductTypeByName *ns2__deleteProductTypeByName_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteProductTypeByName */
        long soap_type() const { return SOAP_TYPE___ns1__deleteProductTypeByName; }
        /** Constructor with member initializations */
        __ns1__deleteProductTypeByName() : ns2__deleteProductTypeByName_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate___ns1__deleteProductTypeByName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:2945 */
#ifndef SOAP_TYPE___ns1__getOrderList
#define SOAP_TYPE___ns1__getOrderList (131)
/* Wrapper: */
struct SOAP_CMAC __ns1__getOrderList {
      public:
        /** Optional element 'ns2:getOrderList' of XML schema type 'ns2:getOrderList' */
        ns2__getOrderList *ns2__getOrderList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getOrderList */
        long soap_type() const { return SOAP_TYPE___ns1__getOrderList; }
        /** Constructor with member initializations */
        __ns1__getOrderList() : ns2__getOrderList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getOrderList * SOAP_FMAC2 soap_instantiate___ns1__getOrderList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3012 */
#ifndef SOAP_TYPE___ns1__getShopByNameAndPwd
#define SOAP_TYPE___ns1__getShopByNameAndPwd (135)
/* Wrapper: */
struct SOAP_CMAC __ns1__getShopByNameAndPwd {
      public:
        /** Optional element 'ns2:getShopByNameAndPwd' of XML schema type 'ns2:getShopByNameAndPwd' */
        ns2__getShopByNameAndPwd *ns2__getShopByNameAndPwd_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getShopByNameAndPwd */
        long soap_type() const { return SOAP_TYPE___ns1__getShopByNameAndPwd; }
        /** Constructor with member initializations */
        __ns1__getShopByNameAndPwd() : ns2__getShopByNameAndPwd_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getShopByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__getShopByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3079 */
#ifndef SOAP_TYPE___ns1__updateShop
#define SOAP_TYPE___ns1__updateShop (139)
/* Wrapper: */
struct SOAP_CMAC __ns1__updateShop {
      public:
        /** Optional element 'ns2:updateShop' of XML schema type 'ns2:updateShop' */
        ns2__updateShop *ns2__updateShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateShop */
        long soap_type() const { return SOAP_TYPE___ns1__updateShop; }
        /** Constructor with member initializations */
        __ns1__updateShop() : ns2__updateShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__updateShop * SOAP_FMAC2 soap_instantiate___ns1__updateShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3146 */
#ifndef SOAP_TYPE___ns1__getProductListByInfo
#define SOAP_TYPE___ns1__getProductListByInfo (143)
/* Wrapper: */
struct SOAP_CMAC __ns1__getProductListByInfo {
      public:
        /** Optional element 'ns2:getProductListByInfo' of XML schema type 'ns2:getProductListByInfo' */
        ns2__getProductListByInfo *ns2__getProductListByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getProductListByInfo */
        long soap_type() const { return SOAP_TYPE___ns1__getProductListByInfo; }
        /** Constructor with member initializations */
        __ns1__getProductListByInfo() : ns2__getProductListByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getProductListByInfo * SOAP_FMAC2 soap_instantiate___ns1__getProductListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3213 */
#ifndef SOAP_TYPE___ns1__getReadMessageFromShop
#define SOAP_TYPE___ns1__getReadMessageFromShop (147)
/* Wrapper: */
struct SOAP_CMAC __ns1__getReadMessageFromShop {
      public:
        /** Optional element 'ns2:getReadMessageFromShop' of XML schema type 'ns2:getReadMessageFromShop' */
        ns2__getReadMessageFromShop *ns2__getReadMessageFromShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getReadMessageFromShop */
        long soap_type() const { return SOAP_TYPE___ns1__getReadMessageFromShop; }
        /** Constructor with member initializations */
        __ns1__getReadMessageFromShop() : ns2__getReadMessageFromShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getReadMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__getReadMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3280 */
#ifndef SOAP_TYPE___ns1__updateClient
#define SOAP_TYPE___ns1__updateClient (151)
/* Wrapper: */
struct SOAP_CMAC __ns1__updateClient {
      public:
        /** Optional element 'ns2:updateClient' of XML schema type 'ns2:updateClient' */
        ns2__updateClient *ns2__updateClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateClient */
        long soap_type() const { return SOAP_TYPE___ns1__updateClient; }
        /** Constructor with member initializations */
        __ns1__updateClient() : ns2__updateClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__updateClient * SOAP_FMAC2 soap_instantiate___ns1__updateClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3347 */
#ifndef SOAP_TYPE___ns1__deleteProductByInfo
#define SOAP_TYPE___ns1__deleteProductByInfo (155)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteProductByInfo {
      public:
        /** Optional element 'ns2:deleteProductByInfo' of XML schema type 'ns2:deleteProductByInfo' */
        ns2__deleteProductByInfo *ns2__deleteProductByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteProductByInfo */
        long soap_type() const { return SOAP_TYPE___ns1__deleteProductByInfo; }
        /** Constructor with member initializations */
        __ns1__deleteProductByInfo() : ns2__deleteProductByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteProductByInfo * SOAP_FMAC2 soap_instantiate___ns1__deleteProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3414 */
#ifndef SOAP_TYPE___ns1__deleteClientByNameAndPwd
#define SOAP_TYPE___ns1__deleteClientByNameAndPwd (159)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteClientByNameAndPwd {
      public:
        /** Optional element 'ns2:deleteClientByNameAndPwd' of XML schema type 'ns2:deleteClientByNameAndPwd' */
        ns2__deleteClientByNameAndPwd *ns2__deleteClientByNameAndPwd_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteClientByNameAndPwd */
        long soap_type() const { return SOAP_TYPE___ns1__deleteClientByNameAndPwd; }
        /** Constructor with member initializations */
        __ns1__deleteClientByNameAndPwd() : ns2__deleteClientByNameAndPwd_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__deleteClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3481 */
#ifndef SOAP_TYPE___ns1__InsertShop
#define SOAP_TYPE___ns1__InsertShop (163)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsertShop {
      public:
        /** Optional element 'ns2:InsertShop' of XML schema type 'ns2:InsertShop' */
        ns2__InsertShop *ns2__InsertShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsertShop */
        long soap_type() const { return SOAP_TYPE___ns1__InsertShop; }
        /** Constructor with member initializations */
        __ns1__InsertShop() : ns2__InsertShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsertShop * SOAP_FMAC2 soap_instantiate___ns1__InsertShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3548 */
#ifndef SOAP_TYPE___ns1__updateMessageFromShop
#define SOAP_TYPE___ns1__updateMessageFromShop (167)
/* Wrapper: */
struct SOAP_CMAC __ns1__updateMessageFromShop {
      public:
        /** Optional element 'ns2:updateMessageFromShop' of XML schema type 'ns2:updateMessageFromShop' */
        ns2__updateMessageFromShop *ns2__updateMessageFromShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateMessageFromShop */
        long soap_type() const { return SOAP_TYPE___ns1__updateMessageFromShop; }
        /** Constructor with member initializations */
        __ns1__updateMessageFromShop() : ns2__updateMessageFromShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__updateMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__updateMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3615 */
#ifndef SOAP_TYPE___ns1__getProductTypeByProName
#define SOAP_TYPE___ns1__getProductTypeByProName (171)
/* Wrapper: */
struct SOAP_CMAC __ns1__getProductTypeByProName {
      public:
        /** Optional element 'ns2:getProductTypeByProName' of XML schema type 'ns2:getProductTypeByProName' */
        ns2__getProductTypeByProName *ns2__getProductTypeByProName_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getProductTypeByProName */
        long soap_type() const { return SOAP_TYPE___ns1__getProductTypeByProName; }
        /** Constructor with member initializations */
        __ns1__getProductTypeByProName() : ns2__getProductTypeByProName_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getProductTypeByProName * SOAP_FMAC2 soap_instantiate___ns1__getProductTypeByProName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3682 */
#ifndef SOAP_TYPE___ns1__getClientList
#define SOAP_TYPE___ns1__getClientList (175)
/* Wrapper: */
struct SOAP_CMAC __ns1__getClientList {
      public:
        /** Optional element 'ns2:getClientList' of XML schema type 'ns2:getClientList' */
        ns2__getClientList *ns2__getClientList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getClientList */
        long soap_type() const { return SOAP_TYPE___ns1__getClientList; }
        /** Constructor with member initializations */
        __ns1__getClientList() : ns2__getClientList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getClientList * SOAP_FMAC2 soap_instantiate___ns1__getClientList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3749 */
#ifndef SOAP_TYPE___ns1__purchaseProduct
#define SOAP_TYPE___ns1__purchaseProduct (179)
/* Wrapper: */
struct SOAP_CMAC __ns1__purchaseProduct {
      public:
        /** Optional element 'ns2:purchaseProduct' of XML schema type 'ns2:purchaseProduct' */
        ns2__purchaseProduct *ns2__purchaseProduct_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__purchaseProduct */
        long soap_type() const { return SOAP_TYPE___ns1__purchaseProduct; }
        /** Constructor with member initializations */
        __ns1__purchaseProduct() : ns2__purchaseProduct_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__purchaseProduct * SOAP_FMAC2 soap_instantiate___ns1__purchaseProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3816 */
#ifndef SOAP_TYPE___ns1__updateMessageFromClient
#define SOAP_TYPE___ns1__updateMessageFromClient (183)
/* Wrapper: */
struct SOAP_CMAC __ns1__updateMessageFromClient {
      public:
        /** Optional element 'ns2:updateMessageFromClient' of XML schema type 'ns2:updateMessageFromClient' */
        ns2__updateMessageFromClient *ns2__updateMessageFromClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateMessageFromClient */
        long soap_type() const { return SOAP_TYPE___ns1__updateMessageFromClient; }
        /** Constructor with member initializations */
        __ns1__updateMessageFromClient() : ns2__updateMessageFromClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__updateMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__updateMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3883 */
#ifndef SOAP_TYPE___ns1__getUnreadMessageFromClient
#define SOAP_TYPE___ns1__getUnreadMessageFromClient (187)
/* Wrapper: */
struct SOAP_CMAC __ns1__getUnreadMessageFromClient {
      public:
        /** Optional element 'ns2:getUnreadMessageFromClient' of XML schema type 'ns2:getUnreadMessageFromClient' */
        ns2__getUnreadMessageFromClient *ns2__getUnreadMessageFromClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getUnreadMessageFromClient */
        long soap_type() const { return SOAP_TYPE___ns1__getUnreadMessageFromClient; }
        /** Constructor with member initializations */
        __ns1__getUnreadMessageFromClient() : ns2__getUnreadMessageFromClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getUnreadMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__getUnreadMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:3950 */
#ifndef SOAP_TYPE___ns1__updateProductByInfo
#define SOAP_TYPE___ns1__updateProductByInfo (191)
/* Wrapper: */
struct SOAP_CMAC __ns1__updateProductByInfo {
      public:
        /** Optional element 'ns2:updateProductByInfo' of XML schema type 'ns2:updateProductByInfo' */
        ns2__updateProductByInfo *ns2__updateProductByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateProductByInfo */
        long soap_type() const { return SOAP_TYPE___ns1__updateProductByInfo; }
        /** Constructor with member initializations */
        __ns1__updateProductByInfo() : ns2__updateProductByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__updateProductByInfo * SOAP_FMAC2 soap_instantiate___ns1__updateProductByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4017 */
#ifndef SOAP_TYPE___ns1__getMessageFromClient
#define SOAP_TYPE___ns1__getMessageFromClient (195)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMessageFromClient {
      public:
        /** Optional element 'ns2:getMessageFromClient' of XML schema type 'ns2:getMessageFromClient' */
        ns2__getMessageFromClient *ns2__getMessageFromClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMessageFromClient */
        long soap_type() const { return SOAP_TYPE___ns1__getMessageFromClient; }
        /** Constructor with member initializations */
        __ns1__getMessageFromClient() : ns2__getMessageFromClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__getMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4084 */
#ifndef SOAP_TYPE___ns1__addOrder
#define SOAP_TYPE___ns1__addOrder (199)
/* Wrapper: */
struct SOAP_CMAC __ns1__addOrder {
      public:
        /** Optional element 'ns2:addOrder' of XML schema type 'ns2:addOrder' */
        ns2__addOrder *ns2__addOrder_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__addOrder */
        long soap_type() const { return SOAP_TYPE___ns1__addOrder; }
        /** Constructor with member initializations */
        __ns1__addOrder() : ns2__addOrder_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__addOrder * SOAP_FMAC2 soap_instantiate___ns1__addOrder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4151 */
#ifndef SOAP_TYPE___ns1__deleteShopByNameAndPwd
#define SOAP_TYPE___ns1__deleteShopByNameAndPwd (203)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteShopByNameAndPwd {
      public:
        /** Optional element 'ns2:deleteShopByNameAndPwd' of XML schema type 'ns2:deleteShopByNameAndPwd' */
        ns2__deleteShopByNameAndPwd *ns2__deleteShopByNameAndPwd_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteShopByNameAndPwd */
        long soap_type() const { return SOAP_TYPE___ns1__deleteShopByNameAndPwd; }
        /** Constructor with member initializations */
        __ns1__deleteShopByNameAndPwd() : ns2__deleteShopByNameAndPwd_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteShopByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__deleteShopByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4218 */
#ifndef SOAP_TYPE___ns1__getProductList
#define SOAP_TYPE___ns1__getProductList (207)
/* Wrapper: */
struct SOAP_CMAC __ns1__getProductList {
      public:
        /** Optional element 'ns2:getProductList' of XML schema type 'ns2:getProductList' */
        ns2__getProductList *ns2__getProductList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getProductList */
        long soap_type() const { return SOAP_TYPE___ns1__getProductList; }
        /** Constructor with member initializations */
        __ns1__getProductList() : ns2__getProductList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getProductList * SOAP_FMAC2 soap_instantiate___ns1__getProductList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4285 */
#ifndef SOAP_TYPE___ns1__getOrderListHistory
#define SOAP_TYPE___ns1__getOrderListHistory (211)
/* Wrapper: */
struct SOAP_CMAC __ns1__getOrderListHistory {
      public:
        /** Optional element 'ns2:getOrderListHistory' of XML schema type 'ns2:getOrderListHistory' */
        ns2__getOrderListHistory *ns2__getOrderListHistory_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getOrderListHistory */
        long soap_type() const { return SOAP_TYPE___ns1__getOrderListHistory; }
        /** Constructor with member initializations */
        __ns1__getOrderListHistory() : ns2__getOrderListHistory_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getOrderListHistory * SOAP_FMAC2 soap_instantiate___ns1__getOrderListHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4352 */
#ifndef SOAP_TYPE___ns1__getReadMessageFromClient
#define SOAP_TYPE___ns1__getReadMessageFromClient (215)
/* Wrapper: */
struct SOAP_CMAC __ns1__getReadMessageFromClient {
      public:
        /** Optional element 'ns2:getReadMessageFromClient' of XML schema type 'ns2:getReadMessageFromClient' */
        ns2__getReadMessageFromClient *ns2__getReadMessageFromClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getReadMessageFromClient */
        long soap_type() const { return SOAP_TYPE___ns1__getReadMessageFromClient; }
        /** Constructor with member initializations */
        __ns1__getReadMessageFromClient() : ns2__getReadMessageFromClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getReadMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__getReadMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4419 */
#ifndef SOAP_TYPE___ns1__updateHistory
#define SOAP_TYPE___ns1__updateHistory (219)
/* Wrapper: */
struct SOAP_CMAC __ns1__updateHistory {
      public:
        /** Optional element 'ns2:updateHistory' of XML schema type 'ns2:updateHistory' */
        ns2__updateHistory *ns2__updateHistory_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateHistory */
        long soap_type() const { return SOAP_TYPE___ns1__updateHistory; }
        /** Constructor with member initializations */
        __ns1__updateHistory() : ns2__updateHistory_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__updateHistory * SOAP_FMAC2 soap_instantiate___ns1__updateHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4486 */
#ifndef SOAP_TYPE___ns1__InsertMessage
#define SOAP_TYPE___ns1__InsertMessage (223)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsertMessage {
      public:
        /** Optional element 'ns2:InsertMessage' of XML schema type 'ns2:InsertMessage' */
        ns2__InsertMessage *ns2__InsertMessage_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsertMessage */
        long soap_type() const { return SOAP_TYPE___ns1__InsertMessage; }
        /** Constructor with member initializations */
        __ns1__InsertMessage() : ns2__InsertMessage_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsertMessage * SOAP_FMAC2 soap_instantiate___ns1__InsertMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4553 */
#ifndef SOAP_TYPE___ns1__getShopLikeList
#define SOAP_TYPE___ns1__getShopLikeList (227)
/* Wrapper: */
struct SOAP_CMAC __ns1__getShopLikeList {
      public:
        /** Optional element 'ns2:getShopLikeList' of XML schema type 'ns2:getShopLikeList' */
        ns2__getShopLikeList *ns2__getShopLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getShopLikeList */
        long soap_type() const { return SOAP_TYPE___ns1__getShopLikeList; }
        /** Constructor with member initializations */
        __ns1__getShopLikeList() : ns2__getShopLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getShopLikeList * SOAP_FMAC2 soap_instantiate___ns1__getShopLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4620 */
#ifndef SOAP_TYPE___ns1__getMessageFromShop
#define SOAP_TYPE___ns1__getMessageFromShop (231)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMessageFromShop {
      public:
        /** Optional element 'ns2:getMessageFromShop' of XML schema type 'ns2:getMessageFromShop' */
        ns2__getMessageFromShop *ns2__getMessageFromShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMessageFromShop */
        long soap_type() const { return SOAP_TYPE___ns1__getMessageFromShop; }
        /** Constructor with member initializations */
        __ns1__getMessageFromShop() : ns2__getMessageFromShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__getMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4687 */
#ifndef SOAP_TYPE___ns1__deleteMessageFromShop
#define SOAP_TYPE___ns1__deleteMessageFromShop (235)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteMessageFromShop {
      public:
        /** Optional element 'ns2:deleteMessageFromShop' of XML schema type 'ns2:deleteMessageFromShop' */
        ns2__deleteMessageFromShop *ns2__deleteMessageFromShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteMessageFromShop */
        long soap_type() const { return SOAP_TYPE___ns1__deleteMessageFromShop; }
        /** Constructor with member initializations */
        __ns1__deleteMessageFromShop() : ns2__deleteMessageFromShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__deleteMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4754 */
#ifndef SOAP_TYPE___ns1__getOrderLikeList
#define SOAP_TYPE___ns1__getOrderLikeList (239)
/* Wrapper: */
struct SOAP_CMAC __ns1__getOrderLikeList {
      public:
        /** Optional element 'ns2:getOrderLikeList' of XML schema type 'ns2:getOrderLikeList' */
        ns2__getOrderLikeList *ns2__getOrderLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getOrderLikeList */
        long soap_type() const { return SOAP_TYPE___ns1__getOrderLikeList; }
        /** Constructor with member initializations */
        __ns1__getOrderLikeList() : ns2__getOrderLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getOrderLikeList * SOAP_FMAC2 soap_instantiate___ns1__getOrderLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4821 */
#ifndef SOAP_TYPE___ns1__getUnreadMessageFromShop
#define SOAP_TYPE___ns1__getUnreadMessageFromShop (243)
/* Wrapper: */
struct SOAP_CMAC __ns1__getUnreadMessageFromShop {
      public:
        /** Optional element 'ns2:getUnreadMessageFromShop' of XML schema type 'ns2:getUnreadMessageFromShop' */
        ns2__getUnreadMessageFromShop *ns2__getUnreadMessageFromShop_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getUnreadMessageFromShop */
        long soap_type() const { return SOAP_TYPE___ns1__getUnreadMessageFromShop; }
        /** Constructor with member initializations */
        __ns1__getUnreadMessageFromShop() : ns2__getUnreadMessageFromShop_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getUnreadMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__getUnreadMessageFromShop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4888 */
#ifndef SOAP_TYPE___ns1__getClientLikeList
#define SOAP_TYPE___ns1__getClientLikeList (247)
/* Wrapper: */
struct SOAP_CMAC __ns1__getClientLikeList {
      public:
        /** Optional element 'ns2:getClientLikeList' of XML schema type 'ns2:getClientLikeList' */
        ns2__getClientLikeList *ns2__getClientLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getClientLikeList */
        long soap_type() const { return SOAP_TYPE___ns1__getClientLikeList; }
        /** Constructor with member initializations */
        __ns1__getClientLikeList() : ns2__getClientLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getClientLikeList * SOAP_FMAC2 soap_instantiate___ns1__getClientLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:4955 */
#ifndef SOAP_TYPE___ns1__getShopList
#define SOAP_TYPE___ns1__getShopList (251)
/* Wrapper: */
struct SOAP_CMAC __ns1__getShopList {
      public:
        /** Optional element 'ns2:getShopList' of XML schema type 'ns2:getShopList' */
        ns2__getShopList *ns2__getShopList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getShopList */
        long soap_type() const { return SOAP_TYPE___ns1__getShopList; }
        /** Constructor with member initializations */
        __ns1__getShopList() : ns2__getShopList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getShopList * SOAP_FMAC2 soap_instantiate___ns1__getShopList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5022 */
#ifndef SOAP_TYPE___ns1__getOrderListByInfo
#define SOAP_TYPE___ns1__getOrderListByInfo (255)
/* Wrapper: */
struct SOAP_CMAC __ns1__getOrderListByInfo {
      public:
        /** Optional element 'ns2:getOrderListByInfo' of XML schema type 'ns2:getOrderListByInfo' */
        ns2__getOrderListByInfo *ns2__getOrderListByInfo_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getOrderListByInfo */
        long soap_type() const { return SOAP_TYPE___ns1__getOrderListByInfo; }
        /** Constructor with member initializations */
        __ns1__getOrderListByInfo() : ns2__getOrderListByInfo_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getOrderListByInfo * SOAP_FMAC2 soap_instantiate___ns1__getOrderListByInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5089 */
#ifndef SOAP_TYPE___ns1__addProductType
#define SOAP_TYPE___ns1__addProductType (259)
/* Wrapper: */
struct SOAP_CMAC __ns1__addProductType {
      public:
        /** Optional element 'ns2:addProductType' of XML schema type 'ns2:addProductType' */
        ns2__addProductType *ns2__addProductType_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__addProductType */
        long soap_type() const { return SOAP_TYPE___ns1__addProductType; }
        /** Constructor with member initializations */
        __ns1__addProductType() : ns2__addProductType_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__addProductType * SOAP_FMAC2 soap_instantiate___ns1__addProductType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5156 */
#ifndef SOAP_TYPE___ns1__deleteMessageFromClient
#define SOAP_TYPE___ns1__deleteMessageFromClient (263)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteMessageFromClient {
      public:
        /** Optional element 'ns2:deleteMessageFromClient' of XML schema type 'ns2:deleteMessageFromClient' */
        ns2__deleteMessageFromClient *ns2__deleteMessageFromClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteMessageFromClient */
        long soap_type() const { return SOAP_TYPE___ns1__deleteMessageFromClient; }
        /** Constructor with member initializations */
        __ns1__deleteMessageFromClient() : ns2__deleteMessageFromClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__deleteMessageFromClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5223 */
#ifndef SOAP_TYPE___ns1__getProductLikeList
#define SOAP_TYPE___ns1__getProductLikeList (267)
/* Wrapper: */
struct SOAP_CMAC __ns1__getProductLikeList {
      public:
        /** Optional element 'ns2:getProductLikeList' of XML schema type 'ns2:getProductLikeList' */
        ns2__getProductLikeList *ns2__getProductLikeList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getProductLikeList */
        long soap_type() const { return SOAP_TYPE___ns1__getProductLikeList; }
        /** Constructor with member initializations */
        __ns1__getProductLikeList() : ns2__getProductLikeList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getProductLikeList * SOAP_FMAC2 soap_instantiate___ns1__getProductLikeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5290 */
#ifndef SOAP_TYPE___ns1__getClientByNameAndPwd
#define SOAP_TYPE___ns1__getClientByNameAndPwd (271)
/* Wrapper: */
struct SOAP_CMAC __ns1__getClientByNameAndPwd {
      public:
        /** Optional element 'ns2:getClientByNameAndPwd' of XML schema type 'ns2:getClientByNameAndPwd' */
        ns2__getClientByNameAndPwd *ns2__getClientByNameAndPwd_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getClientByNameAndPwd */
        long soap_type() const { return SOAP_TYPE___ns1__getClientByNameAndPwd; }
        /** Constructor with member initializations */
        __ns1__getClientByNameAndPwd() : ns2__getClientByNameAndPwd_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__getClientByNameAndPwd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5357 */
#ifndef SOAP_TYPE___ns1__deleteShoppingCart
#define SOAP_TYPE___ns1__deleteShoppingCart (275)
/* Wrapper: */
struct SOAP_CMAC __ns1__deleteShoppingCart {
      public:
        /** Optional element 'ns2:deleteShoppingCart' of XML schema type 'ns2:deleteShoppingCart' */
        ns2__deleteShoppingCart *ns2__deleteShoppingCart_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteShoppingCart */
        long soap_type() const { return SOAP_TYPE___ns1__deleteShoppingCart; }
        /** Constructor with member initializations */
        __ns1__deleteShoppingCart() : ns2__deleteShoppingCart_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__deleteShoppingCart * SOAP_FMAC2 soap_instantiate___ns1__deleteShoppingCart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5424 */
#ifndef SOAP_TYPE___ns1__InsertClient
#define SOAP_TYPE___ns1__InsertClient (279)
/* Wrapper: */
struct SOAP_CMAC __ns1__InsertClient {
      public:
        /** Optional element 'ns2:InsertClient' of XML schema type 'ns2:InsertClient' */
        ns2__InsertClient *ns2__InsertClient_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsertClient */
        long soap_type() const { return SOAP_TYPE___ns1__InsertClient; }
        /** Constructor with member initializations */
        __ns1__InsertClient() : ns2__InsertClient_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__InsertClient * SOAP_FMAC2 soap_instantiate___ns1__InsertClient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap_head.h:5649 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (280)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap_head.h:5649 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (281)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap_head.h:5649 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (283)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap_head.h:5649 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (286)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap_head.h:5649 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (287)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* soap_head.h:153 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
typedef std::string xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (102)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (100)
#endif

/* ns2__InsertClientResponse has binding name 'ns2__InsertClientResponse' for type 'ns2:InsertClientResponse' */
#ifndef SOAP_TYPE_ns2__InsertClientResponse
#define SOAP_TYPE_ns2__InsertClientResponse (97)
#endif

/* ns2__InsertClient has binding name 'ns2__InsertClient' for type 'ns2:InsertClient' */
#ifndef SOAP_TYPE_ns2__InsertClient
#define SOAP_TYPE_ns2__InsertClient (96)
#endif

/* ns2__deleteShoppingCartResponse has binding name 'ns2__deleteShoppingCartResponse' for type 'ns2:deleteShoppingCartResponse' */
#ifndef SOAP_TYPE_ns2__deleteShoppingCartResponse
#define SOAP_TYPE_ns2__deleteShoppingCartResponse (95)
#endif

/* ns2__deleteShoppingCart has binding name 'ns2__deleteShoppingCart' for type 'ns2:deleteShoppingCart' */
#ifndef SOAP_TYPE_ns2__deleteShoppingCart
#define SOAP_TYPE_ns2__deleteShoppingCart (94)
#endif

/* ns2__getClientByNameAndPwdResponse has binding name 'ns2__getClientByNameAndPwdResponse' for type 'ns2:getClientByNameAndPwdResponse' */
#ifndef SOAP_TYPE_ns2__getClientByNameAndPwdResponse
#define SOAP_TYPE_ns2__getClientByNameAndPwdResponse (93)
#endif

/* ns2__getClientByNameAndPwd has binding name 'ns2__getClientByNameAndPwd' for type 'ns2:getClientByNameAndPwd' */
#ifndef SOAP_TYPE_ns2__getClientByNameAndPwd
#define SOAP_TYPE_ns2__getClientByNameAndPwd (92)
#endif

/* ns2__getProductLikeListResponse has binding name 'ns2__getProductLikeListResponse' for type 'ns2:getProductLikeListResponse' */
#ifndef SOAP_TYPE_ns2__getProductLikeListResponse
#define SOAP_TYPE_ns2__getProductLikeListResponse (91)
#endif

/* ns2__getProductLikeList has binding name 'ns2__getProductLikeList' for type 'ns2:getProductLikeList' */
#ifndef SOAP_TYPE_ns2__getProductLikeList
#define SOAP_TYPE_ns2__getProductLikeList (90)
#endif

/* ns2__deleteMessageFromClientResponse has binding name 'ns2__deleteMessageFromClientResponse' for type 'ns2:deleteMessageFromClientResponse' */
#ifndef SOAP_TYPE_ns2__deleteMessageFromClientResponse
#define SOAP_TYPE_ns2__deleteMessageFromClientResponse (89)
#endif

/* ns2__deleteMessageFromClient has binding name 'ns2__deleteMessageFromClient' for type 'ns2:deleteMessageFromClient' */
#ifndef SOAP_TYPE_ns2__deleteMessageFromClient
#define SOAP_TYPE_ns2__deleteMessageFromClient (88)
#endif

/* ns2__addProductTypeResponse has binding name 'ns2__addProductTypeResponse' for type 'ns2:addProductTypeResponse' */
#ifndef SOAP_TYPE_ns2__addProductTypeResponse
#define SOAP_TYPE_ns2__addProductTypeResponse (87)
#endif

/* ns2__addProductType has binding name 'ns2__addProductType' for type 'ns2:addProductType' */
#ifndef SOAP_TYPE_ns2__addProductType
#define SOAP_TYPE_ns2__addProductType (86)
#endif

/* ns2__getOrderListByInfoResponse has binding name 'ns2__getOrderListByInfoResponse' for type 'ns2:getOrderListByInfoResponse' */
#ifndef SOAP_TYPE_ns2__getOrderListByInfoResponse
#define SOAP_TYPE_ns2__getOrderListByInfoResponse (85)
#endif

/* ns2__getOrderListByInfo has binding name 'ns2__getOrderListByInfo' for type 'ns2:getOrderListByInfo' */
#ifndef SOAP_TYPE_ns2__getOrderListByInfo
#define SOAP_TYPE_ns2__getOrderListByInfo (84)
#endif

/* ns2__getShopListResponse has binding name 'ns2__getShopListResponse' for type 'ns2:getShopListResponse' */
#ifndef SOAP_TYPE_ns2__getShopListResponse
#define SOAP_TYPE_ns2__getShopListResponse (83)
#endif

/* ns2__getShopList has binding name 'ns2__getShopList' for type 'ns2:getShopList' */
#ifndef SOAP_TYPE_ns2__getShopList
#define SOAP_TYPE_ns2__getShopList (82)
#endif

/* ns2__getClientLikeListResponse has binding name 'ns2__getClientLikeListResponse' for type 'ns2:getClientLikeListResponse' */
#ifndef SOAP_TYPE_ns2__getClientLikeListResponse
#define SOAP_TYPE_ns2__getClientLikeListResponse (81)
#endif

/* ns2__getClientLikeList has binding name 'ns2__getClientLikeList' for type 'ns2:getClientLikeList' */
#ifndef SOAP_TYPE_ns2__getClientLikeList
#define SOAP_TYPE_ns2__getClientLikeList (80)
#endif

/* ns2__getUnreadMessageFromShopResponse has binding name 'ns2__getUnreadMessageFromShopResponse' for type 'ns2:getUnreadMessageFromShopResponse' */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromShopResponse
#define SOAP_TYPE_ns2__getUnreadMessageFromShopResponse (79)
#endif

/* ns2__getUnreadMessageFromShop has binding name 'ns2__getUnreadMessageFromShop' for type 'ns2:getUnreadMessageFromShop' */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromShop
#define SOAP_TYPE_ns2__getUnreadMessageFromShop (78)
#endif

/* ns2__getOrderLikeListResponse has binding name 'ns2__getOrderLikeListResponse' for type 'ns2:getOrderLikeListResponse' */
#ifndef SOAP_TYPE_ns2__getOrderLikeListResponse
#define SOAP_TYPE_ns2__getOrderLikeListResponse (77)
#endif

/* ns2__getOrderLikeList has binding name 'ns2__getOrderLikeList' for type 'ns2:getOrderLikeList' */
#ifndef SOAP_TYPE_ns2__getOrderLikeList
#define SOAP_TYPE_ns2__getOrderLikeList (76)
#endif

/* ns2__deleteMessageFromShopResponse has binding name 'ns2__deleteMessageFromShopResponse' for type 'ns2:deleteMessageFromShopResponse' */
#ifndef SOAP_TYPE_ns2__deleteMessageFromShopResponse
#define SOAP_TYPE_ns2__deleteMessageFromShopResponse (75)
#endif

/* ns2__deleteMessageFromShop has binding name 'ns2__deleteMessageFromShop' for type 'ns2:deleteMessageFromShop' */
#ifndef SOAP_TYPE_ns2__deleteMessageFromShop
#define SOAP_TYPE_ns2__deleteMessageFromShop (74)
#endif

/* ns2__getMessageFromShopResponse has binding name 'ns2__getMessageFromShopResponse' for type 'ns2:getMessageFromShopResponse' */
#ifndef SOAP_TYPE_ns2__getMessageFromShopResponse
#define SOAP_TYPE_ns2__getMessageFromShopResponse (73)
#endif

/* ns2__getMessageFromShop has binding name 'ns2__getMessageFromShop' for type 'ns2:getMessageFromShop' */
#ifndef SOAP_TYPE_ns2__getMessageFromShop
#define SOAP_TYPE_ns2__getMessageFromShop (72)
#endif

/* ns2__getShopLikeListResponse has binding name 'ns2__getShopLikeListResponse' for type 'ns2:getShopLikeListResponse' */
#ifndef SOAP_TYPE_ns2__getShopLikeListResponse
#define SOAP_TYPE_ns2__getShopLikeListResponse (71)
#endif

/* ns2__getShopLikeList has binding name 'ns2__getShopLikeList' for type 'ns2:getShopLikeList' */
#ifndef SOAP_TYPE_ns2__getShopLikeList
#define SOAP_TYPE_ns2__getShopLikeList (70)
#endif

/* ns2__InsertMessageResponse has binding name 'ns2__InsertMessageResponse' for type 'ns2:InsertMessageResponse' */
#ifndef SOAP_TYPE_ns2__InsertMessageResponse
#define SOAP_TYPE_ns2__InsertMessageResponse (69)
#endif

/* ns2__InsertMessage has binding name 'ns2__InsertMessage' for type 'ns2:InsertMessage' */
#ifndef SOAP_TYPE_ns2__InsertMessage
#define SOAP_TYPE_ns2__InsertMessage (68)
#endif

/* ns2__updateHistoryResponse has binding name 'ns2__updateHistoryResponse' for type 'ns2:updateHistoryResponse' */
#ifndef SOAP_TYPE_ns2__updateHistoryResponse
#define SOAP_TYPE_ns2__updateHistoryResponse (67)
#endif

/* ns2__updateHistory has binding name 'ns2__updateHistory' for type 'ns2:updateHistory' */
#ifndef SOAP_TYPE_ns2__updateHistory
#define SOAP_TYPE_ns2__updateHistory (66)
#endif

/* ns2__getReadMessageFromClientResponse has binding name 'ns2__getReadMessageFromClientResponse' for type 'ns2:getReadMessageFromClientResponse' */
#ifndef SOAP_TYPE_ns2__getReadMessageFromClientResponse
#define SOAP_TYPE_ns2__getReadMessageFromClientResponse (65)
#endif

/* ns2__getReadMessageFromClient has binding name 'ns2__getReadMessageFromClient' for type 'ns2:getReadMessageFromClient' */
#ifndef SOAP_TYPE_ns2__getReadMessageFromClient
#define SOAP_TYPE_ns2__getReadMessageFromClient (64)
#endif

/* ns2__getOrderListHistoryResponse has binding name 'ns2__getOrderListHistoryResponse' for type 'ns2:getOrderListHistoryResponse' */
#ifndef SOAP_TYPE_ns2__getOrderListHistoryResponse
#define SOAP_TYPE_ns2__getOrderListHistoryResponse (63)
#endif

/* ns2__getOrderListHistory has binding name 'ns2__getOrderListHistory' for type 'ns2:getOrderListHistory' */
#ifndef SOAP_TYPE_ns2__getOrderListHistory
#define SOAP_TYPE_ns2__getOrderListHistory (62)
#endif

/* ns2__getProductListResponse has binding name 'ns2__getProductListResponse' for type 'ns2:getProductListResponse' */
#ifndef SOAP_TYPE_ns2__getProductListResponse
#define SOAP_TYPE_ns2__getProductListResponse (61)
#endif

/* ns2__getProductList has binding name 'ns2__getProductList' for type 'ns2:getProductList' */
#ifndef SOAP_TYPE_ns2__getProductList
#define SOAP_TYPE_ns2__getProductList (60)
#endif

/* ns2__deleteShopByNameAndPwdResponse has binding name 'ns2__deleteShopByNameAndPwdResponse' for type 'ns2:deleteShopByNameAndPwdResponse' */
#ifndef SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse
#define SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse (59)
#endif

/* ns2__deleteShopByNameAndPwd has binding name 'ns2__deleteShopByNameAndPwd' for type 'ns2:deleteShopByNameAndPwd' */
#ifndef SOAP_TYPE_ns2__deleteShopByNameAndPwd
#define SOAP_TYPE_ns2__deleteShopByNameAndPwd (58)
#endif

/* ns2__addOrderResponse has binding name 'ns2__addOrderResponse' for type 'ns2:addOrderResponse' */
#ifndef SOAP_TYPE_ns2__addOrderResponse
#define SOAP_TYPE_ns2__addOrderResponse (57)
#endif

/* ns2__addOrder has binding name 'ns2__addOrder' for type 'ns2:addOrder' */
#ifndef SOAP_TYPE_ns2__addOrder
#define SOAP_TYPE_ns2__addOrder (56)
#endif

/* ns2__getMessageFromClientResponse has binding name 'ns2__getMessageFromClientResponse' for type 'ns2:getMessageFromClientResponse' */
#ifndef SOAP_TYPE_ns2__getMessageFromClientResponse
#define SOAP_TYPE_ns2__getMessageFromClientResponse (55)
#endif

/* ns2__getMessageFromClient has binding name 'ns2__getMessageFromClient' for type 'ns2:getMessageFromClient' */
#ifndef SOAP_TYPE_ns2__getMessageFromClient
#define SOAP_TYPE_ns2__getMessageFromClient (54)
#endif

/* ns2__updateProductByInfoResponse has binding name 'ns2__updateProductByInfoResponse' for type 'ns2:updateProductByInfoResponse' */
#ifndef SOAP_TYPE_ns2__updateProductByInfoResponse
#define SOAP_TYPE_ns2__updateProductByInfoResponse (53)
#endif

/* ns2__updateProductByInfo has binding name 'ns2__updateProductByInfo' for type 'ns2:updateProductByInfo' */
#ifndef SOAP_TYPE_ns2__updateProductByInfo
#define SOAP_TYPE_ns2__updateProductByInfo (52)
#endif

/* ns2__getUnreadMessageFromClientResponse has binding name 'ns2__getUnreadMessageFromClientResponse' for type 'ns2:getUnreadMessageFromClientResponse' */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromClientResponse
#define SOAP_TYPE_ns2__getUnreadMessageFromClientResponse (51)
#endif

/* ns2__getUnreadMessageFromClient has binding name 'ns2__getUnreadMessageFromClient' for type 'ns2:getUnreadMessageFromClient' */
#ifndef SOAP_TYPE_ns2__getUnreadMessageFromClient
#define SOAP_TYPE_ns2__getUnreadMessageFromClient (50)
#endif

/* ns2__updateMessageFromClientResponse has binding name 'ns2__updateMessageFromClientResponse' for type 'ns2:updateMessageFromClientResponse' */
#ifndef SOAP_TYPE_ns2__updateMessageFromClientResponse
#define SOAP_TYPE_ns2__updateMessageFromClientResponse (49)
#endif

/* ns2__updateMessageFromClient has binding name 'ns2__updateMessageFromClient' for type 'ns2:updateMessageFromClient' */
#ifndef SOAP_TYPE_ns2__updateMessageFromClient
#define SOAP_TYPE_ns2__updateMessageFromClient (48)
#endif

/* ns2__purchaseProductResponse has binding name 'ns2__purchaseProductResponse' for type 'ns2:purchaseProductResponse' */
#ifndef SOAP_TYPE_ns2__purchaseProductResponse
#define SOAP_TYPE_ns2__purchaseProductResponse (47)
#endif

/* ns2__purchaseProduct has binding name 'ns2__purchaseProduct' for type 'ns2:purchaseProduct' */
#ifndef SOAP_TYPE_ns2__purchaseProduct
#define SOAP_TYPE_ns2__purchaseProduct (46)
#endif

/* ns2__getClientListResponse has binding name 'ns2__getClientListResponse' for type 'ns2:getClientListResponse' */
#ifndef SOAP_TYPE_ns2__getClientListResponse
#define SOAP_TYPE_ns2__getClientListResponse (45)
#endif

/* ns2__getClientList has binding name 'ns2__getClientList' for type 'ns2:getClientList' */
#ifndef SOAP_TYPE_ns2__getClientList
#define SOAP_TYPE_ns2__getClientList (44)
#endif

/* ns2__productType has binding name 'ns2__productType' for type 'ns2:productType' */
#ifndef SOAP_TYPE_ns2__productType
#define SOAP_TYPE_ns2__productType (43)
#endif

/* ns2__getProductTypeByProNameResponse has binding name 'ns2__getProductTypeByProNameResponse' for type 'ns2:getProductTypeByProNameResponse' */
#ifndef SOAP_TYPE_ns2__getProductTypeByProNameResponse
#define SOAP_TYPE_ns2__getProductTypeByProNameResponse (42)
#endif

/* ns2__getProductTypeByProName has binding name 'ns2__getProductTypeByProName' for type 'ns2:getProductTypeByProName' */
#ifndef SOAP_TYPE_ns2__getProductTypeByProName
#define SOAP_TYPE_ns2__getProductTypeByProName (41)
#endif

/* ns2__updateMessageFromShopResponse has binding name 'ns2__updateMessageFromShopResponse' for type 'ns2:updateMessageFromShopResponse' */
#ifndef SOAP_TYPE_ns2__updateMessageFromShopResponse
#define SOAP_TYPE_ns2__updateMessageFromShopResponse (40)
#endif

/* ns2__updateMessageFromShop has binding name 'ns2__updateMessageFromShop' for type 'ns2:updateMessageFromShop' */
#ifndef SOAP_TYPE_ns2__updateMessageFromShop
#define SOAP_TYPE_ns2__updateMessageFromShop (39)
#endif

/* ns2__InsertShopResponse has binding name 'ns2__InsertShopResponse' for type 'ns2:InsertShopResponse' */
#ifndef SOAP_TYPE_ns2__InsertShopResponse
#define SOAP_TYPE_ns2__InsertShopResponse (38)
#endif

/* ns2__InsertShop has binding name 'ns2__InsertShop' for type 'ns2:InsertShop' */
#ifndef SOAP_TYPE_ns2__InsertShop
#define SOAP_TYPE_ns2__InsertShop (37)
#endif

/* ns2__deleteClientByNameAndPwdResponse has binding name 'ns2__deleteClientByNameAndPwdResponse' for type 'ns2:deleteClientByNameAndPwdResponse' */
#ifndef SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse
#define SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse (36)
#endif

/* ns2__deleteClientByNameAndPwd has binding name 'ns2__deleteClientByNameAndPwd' for type 'ns2:deleteClientByNameAndPwd' */
#ifndef SOAP_TYPE_ns2__deleteClientByNameAndPwd
#define SOAP_TYPE_ns2__deleteClientByNameAndPwd (35)
#endif

/* ns2__deleteProductByInfoResponse has binding name 'ns2__deleteProductByInfoResponse' for type 'ns2:deleteProductByInfoResponse' */
#ifndef SOAP_TYPE_ns2__deleteProductByInfoResponse
#define SOAP_TYPE_ns2__deleteProductByInfoResponse (34)
#endif

/* ns2__deleteProductByInfo has binding name 'ns2__deleteProductByInfo' for type 'ns2:deleteProductByInfo' */
#ifndef SOAP_TYPE_ns2__deleteProductByInfo
#define SOAP_TYPE_ns2__deleteProductByInfo (33)
#endif

/* ns2__updateClientResponse has binding name 'ns2__updateClientResponse' for type 'ns2:updateClientResponse' */
#ifndef SOAP_TYPE_ns2__updateClientResponse
#define SOAP_TYPE_ns2__updateClientResponse (32)
#endif

/* ns2__updateClient has binding name 'ns2__updateClient' for type 'ns2:updateClient' */
#ifndef SOAP_TYPE_ns2__updateClient
#define SOAP_TYPE_ns2__updateClient (31)
#endif

/* ns2__message has binding name 'ns2__message' for type 'ns2:message' */
#ifndef SOAP_TYPE_ns2__message
#define SOAP_TYPE_ns2__message (30)
#endif

/* ns2__getReadMessageFromShopResponse has binding name 'ns2__getReadMessageFromShopResponse' for type 'ns2:getReadMessageFromShopResponse' */
#ifndef SOAP_TYPE_ns2__getReadMessageFromShopResponse
#define SOAP_TYPE_ns2__getReadMessageFromShopResponse (29)
#endif

/* ns2__client has binding name 'ns2__client' for type 'ns2:client' */
#ifndef SOAP_TYPE_ns2__client
#define SOAP_TYPE_ns2__client (28)
#endif

/* ns2__getReadMessageFromShop has binding name 'ns2__getReadMessageFromShop' for type 'ns2:getReadMessageFromShop' */
#ifndef SOAP_TYPE_ns2__getReadMessageFromShop
#define SOAP_TYPE_ns2__getReadMessageFromShop (27)
#endif

/* ns2__getProductListByInfoResponse has binding name 'ns2__getProductListByInfoResponse' for type 'ns2:getProductListByInfoResponse' */
#ifndef SOAP_TYPE_ns2__getProductListByInfoResponse
#define SOAP_TYPE_ns2__getProductListByInfoResponse (26)
#endif

/* ns2__getProductListByInfo has binding name 'ns2__getProductListByInfo' for type 'ns2:getProductListByInfo' */
#ifndef SOAP_TYPE_ns2__getProductListByInfo
#define SOAP_TYPE_ns2__getProductListByInfo (25)
#endif

/* ns2__updateShopResponse has binding name 'ns2__updateShopResponse' for type 'ns2:updateShopResponse' */
#ifndef SOAP_TYPE_ns2__updateShopResponse
#define SOAP_TYPE_ns2__updateShopResponse (24)
#endif

/* ns2__updateShop has binding name 'ns2__updateShop' for type 'ns2:updateShop' */
#ifndef SOAP_TYPE_ns2__updateShop
#define SOAP_TYPE_ns2__updateShop (23)
#endif

/* ns2__shop has binding name 'ns2__shop' for type 'ns2:shop' */
#ifndef SOAP_TYPE_ns2__shop
#define SOAP_TYPE_ns2__shop (22)
#endif

/* ns2__getShopByNameAndPwdResponse has binding name 'ns2__getShopByNameAndPwdResponse' for type 'ns2:getShopByNameAndPwdResponse' */
#ifndef SOAP_TYPE_ns2__getShopByNameAndPwdResponse
#define SOAP_TYPE_ns2__getShopByNameAndPwdResponse (21)
#endif

/* ns2__getShopByNameAndPwd has binding name 'ns2__getShopByNameAndPwd' for type 'ns2:getShopByNameAndPwd' */
#ifndef SOAP_TYPE_ns2__getShopByNameAndPwd
#define SOAP_TYPE_ns2__getShopByNameAndPwd (20)
#endif

/* ns2__getOrderListResponse has binding name 'ns2__getOrderListResponse' for type 'ns2:getOrderListResponse' */
#ifndef SOAP_TYPE_ns2__getOrderListResponse
#define SOAP_TYPE_ns2__getOrderListResponse (19)
#endif

/* ns2__order has binding name 'ns2__order' for type 'ns2:order' */
#ifndef SOAP_TYPE_ns2__order
#define SOAP_TYPE_ns2__order (18)
#endif

/* ns2__getOrderList has binding name 'ns2__getOrderList' for type 'ns2:getOrderList' */
#ifndef SOAP_TYPE_ns2__getOrderList
#define SOAP_TYPE_ns2__getOrderList (17)
#endif

/* ns2__deleteProductTypeByNameResponse has binding name 'ns2__deleteProductTypeByNameResponse' for type 'ns2:deleteProductTypeByNameResponse' */
#ifndef SOAP_TYPE_ns2__deleteProductTypeByNameResponse
#define SOAP_TYPE_ns2__deleteProductTypeByNameResponse (16)
#endif

/* ns2__deleteProductTypeByName has binding name 'ns2__deleteProductTypeByName' for type 'ns2:deleteProductTypeByName' */
#ifndef SOAP_TYPE_ns2__deleteProductTypeByName
#define SOAP_TYPE_ns2__deleteProductTypeByName (15)
#endif

/* ns2__addProductResponse has binding name 'ns2__addProductResponse' for type 'ns2:addProductResponse' */
#ifndef SOAP_TYPE_ns2__addProductResponse
#define SOAP_TYPE_ns2__addProductResponse (14)
#endif

/* ns2__addProduct has binding name 'ns2__addProduct' for type 'ns2:addProduct' */
#ifndef SOAP_TYPE_ns2__addProduct
#define SOAP_TYPE_ns2__addProduct (13)
#endif

/* ns2__product has binding name 'ns2__product' for type 'ns2:product' */
#ifndef SOAP_TYPE_ns2__product
#define SOAP_TYPE_ns2__product (12)
#endif

/* ns2__selectProductForUpdateResponse has binding name 'ns2__selectProductForUpdateResponse' for type 'ns2:selectProductForUpdateResponse' */
#ifndef SOAP_TYPE_ns2__selectProductForUpdateResponse
#define SOAP_TYPE_ns2__selectProductForUpdateResponse (11)
#endif

/* ns2__selectProductForUpdate has binding name 'ns2__selectProductForUpdate' for type 'ns2:selectProductForUpdate' */
#ifndef SOAP_TYPE_ns2__selectProductForUpdate
#define SOAP_TYPE_ns2__selectProductForUpdate (10)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (287)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (286)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (283)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (281)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (280)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (289)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (288)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (282)
#endif

/* ns2__InsertClient * has binding name 'PointerTons2__InsertClient' for type 'ns2:InsertClient' */
#ifndef SOAP_TYPE_PointerTons2__InsertClient
#define SOAP_TYPE_PointerTons2__InsertClient (276)
#endif

/* ns2__deleteShoppingCart * has binding name 'PointerTons2__deleteShoppingCart' for type 'ns2:deleteShoppingCart' */
#ifndef SOAP_TYPE_PointerTons2__deleteShoppingCart
#define SOAP_TYPE_PointerTons2__deleteShoppingCart (272)
#endif

/* ns2__getClientByNameAndPwd * has binding name 'PointerTons2__getClientByNameAndPwd' for type 'ns2:getClientByNameAndPwd' */
#ifndef SOAP_TYPE_PointerTons2__getClientByNameAndPwd
#define SOAP_TYPE_PointerTons2__getClientByNameAndPwd (268)
#endif

/* ns2__getProductLikeList * has binding name 'PointerTons2__getProductLikeList' for type 'ns2:getProductLikeList' */
#ifndef SOAP_TYPE_PointerTons2__getProductLikeList
#define SOAP_TYPE_PointerTons2__getProductLikeList (264)
#endif

/* ns2__deleteMessageFromClient * has binding name 'PointerTons2__deleteMessageFromClient' for type 'ns2:deleteMessageFromClient' */
#ifndef SOAP_TYPE_PointerTons2__deleteMessageFromClient
#define SOAP_TYPE_PointerTons2__deleteMessageFromClient (260)
#endif

/* ns2__addProductType * has binding name 'PointerTons2__addProductType' for type 'ns2:addProductType' */
#ifndef SOAP_TYPE_PointerTons2__addProductType
#define SOAP_TYPE_PointerTons2__addProductType (256)
#endif

/* ns2__getOrderListByInfo * has binding name 'PointerTons2__getOrderListByInfo' for type 'ns2:getOrderListByInfo' */
#ifndef SOAP_TYPE_PointerTons2__getOrderListByInfo
#define SOAP_TYPE_PointerTons2__getOrderListByInfo (252)
#endif

/* ns2__getShopList * has binding name 'PointerTons2__getShopList' for type 'ns2:getShopList' */
#ifndef SOAP_TYPE_PointerTons2__getShopList
#define SOAP_TYPE_PointerTons2__getShopList (248)
#endif

/* ns2__getClientLikeList * has binding name 'PointerTons2__getClientLikeList' for type 'ns2:getClientLikeList' */
#ifndef SOAP_TYPE_PointerTons2__getClientLikeList
#define SOAP_TYPE_PointerTons2__getClientLikeList (244)
#endif

/* ns2__getUnreadMessageFromShop * has binding name 'PointerTons2__getUnreadMessageFromShop' for type 'ns2:getUnreadMessageFromShop' */
#ifndef SOAP_TYPE_PointerTons2__getUnreadMessageFromShop
#define SOAP_TYPE_PointerTons2__getUnreadMessageFromShop (240)
#endif

/* ns2__getOrderLikeList * has binding name 'PointerTons2__getOrderLikeList' for type 'ns2:getOrderLikeList' */
#ifndef SOAP_TYPE_PointerTons2__getOrderLikeList
#define SOAP_TYPE_PointerTons2__getOrderLikeList (236)
#endif

/* ns2__deleteMessageFromShop * has binding name 'PointerTons2__deleteMessageFromShop' for type 'ns2:deleteMessageFromShop' */
#ifndef SOAP_TYPE_PointerTons2__deleteMessageFromShop
#define SOAP_TYPE_PointerTons2__deleteMessageFromShop (232)
#endif

/* ns2__getMessageFromShop * has binding name 'PointerTons2__getMessageFromShop' for type 'ns2:getMessageFromShop' */
#ifndef SOAP_TYPE_PointerTons2__getMessageFromShop
#define SOAP_TYPE_PointerTons2__getMessageFromShop (228)
#endif

/* ns2__getShopLikeList * has binding name 'PointerTons2__getShopLikeList' for type 'ns2:getShopLikeList' */
#ifndef SOAP_TYPE_PointerTons2__getShopLikeList
#define SOAP_TYPE_PointerTons2__getShopLikeList (224)
#endif

/* ns2__InsertMessage * has binding name 'PointerTons2__InsertMessage' for type 'ns2:InsertMessage' */
#ifndef SOAP_TYPE_PointerTons2__InsertMessage
#define SOAP_TYPE_PointerTons2__InsertMessage (220)
#endif

/* ns2__updateHistory * has binding name 'PointerTons2__updateHistory' for type 'ns2:updateHistory' */
#ifndef SOAP_TYPE_PointerTons2__updateHistory
#define SOAP_TYPE_PointerTons2__updateHistory (216)
#endif

/* ns2__getReadMessageFromClient * has binding name 'PointerTons2__getReadMessageFromClient' for type 'ns2:getReadMessageFromClient' */
#ifndef SOAP_TYPE_PointerTons2__getReadMessageFromClient
#define SOAP_TYPE_PointerTons2__getReadMessageFromClient (212)
#endif

/* ns2__getOrderListHistory * has binding name 'PointerTons2__getOrderListHistory' for type 'ns2:getOrderListHistory' */
#ifndef SOAP_TYPE_PointerTons2__getOrderListHistory
#define SOAP_TYPE_PointerTons2__getOrderListHistory (208)
#endif

/* ns2__getProductList * has binding name 'PointerTons2__getProductList' for type 'ns2:getProductList' */
#ifndef SOAP_TYPE_PointerTons2__getProductList
#define SOAP_TYPE_PointerTons2__getProductList (204)
#endif

/* ns2__deleteShopByNameAndPwd * has binding name 'PointerTons2__deleteShopByNameAndPwd' for type 'ns2:deleteShopByNameAndPwd' */
#ifndef SOAP_TYPE_PointerTons2__deleteShopByNameAndPwd
#define SOAP_TYPE_PointerTons2__deleteShopByNameAndPwd (200)
#endif

/* ns2__addOrder * has binding name 'PointerTons2__addOrder' for type 'ns2:addOrder' */
#ifndef SOAP_TYPE_PointerTons2__addOrder
#define SOAP_TYPE_PointerTons2__addOrder (196)
#endif

/* ns2__getMessageFromClient * has binding name 'PointerTons2__getMessageFromClient' for type 'ns2:getMessageFromClient' */
#ifndef SOAP_TYPE_PointerTons2__getMessageFromClient
#define SOAP_TYPE_PointerTons2__getMessageFromClient (192)
#endif

/* ns2__updateProductByInfo * has binding name 'PointerTons2__updateProductByInfo' for type 'ns2:updateProductByInfo' */
#ifndef SOAP_TYPE_PointerTons2__updateProductByInfo
#define SOAP_TYPE_PointerTons2__updateProductByInfo (188)
#endif

/* ns2__getUnreadMessageFromClient * has binding name 'PointerTons2__getUnreadMessageFromClient' for type 'ns2:getUnreadMessageFromClient' */
#ifndef SOAP_TYPE_PointerTons2__getUnreadMessageFromClient
#define SOAP_TYPE_PointerTons2__getUnreadMessageFromClient (184)
#endif

/* ns2__updateMessageFromClient * has binding name 'PointerTons2__updateMessageFromClient' for type 'ns2:updateMessageFromClient' */
#ifndef SOAP_TYPE_PointerTons2__updateMessageFromClient
#define SOAP_TYPE_PointerTons2__updateMessageFromClient (180)
#endif

/* ns2__purchaseProduct * has binding name 'PointerTons2__purchaseProduct' for type 'ns2:purchaseProduct' */
#ifndef SOAP_TYPE_PointerTons2__purchaseProduct
#define SOAP_TYPE_PointerTons2__purchaseProduct (176)
#endif

/* ns2__getClientList * has binding name 'PointerTons2__getClientList' for type 'ns2:getClientList' */
#ifndef SOAP_TYPE_PointerTons2__getClientList
#define SOAP_TYPE_PointerTons2__getClientList (172)
#endif

/* ns2__getProductTypeByProName * has binding name 'PointerTons2__getProductTypeByProName' for type 'ns2:getProductTypeByProName' */
#ifndef SOAP_TYPE_PointerTons2__getProductTypeByProName
#define SOAP_TYPE_PointerTons2__getProductTypeByProName (168)
#endif

/* ns2__updateMessageFromShop * has binding name 'PointerTons2__updateMessageFromShop' for type 'ns2:updateMessageFromShop' */
#ifndef SOAP_TYPE_PointerTons2__updateMessageFromShop
#define SOAP_TYPE_PointerTons2__updateMessageFromShop (164)
#endif

/* ns2__InsertShop * has binding name 'PointerTons2__InsertShop' for type 'ns2:InsertShop' */
#ifndef SOAP_TYPE_PointerTons2__InsertShop
#define SOAP_TYPE_PointerTons2__InsertShop (160)
#endif

/* ns2__deleteClientByNameAndPwd * has binding name 'PointerTons2__deleteClientByNameAndPwd' for type 'ns2:deleteClientByNameAndPwd' */
#ifndef SOAP_TYPE_PointerTons2__deleteClientByNameAndPwd
#define SOAP_TYPE_PointerTons2__deleteClientByNameAndPwd (156)
#endif

/* ns2__deleteProductByInfo * has binding name 'PointerTons2__deleteProductByInfo' for type 'ns2:deleteProductByInfo' */
#ifndef SOAP_TYPE_PointerTons2__deleteProductByInfo
#define SOAP_TYPE_PointerTons2__deleteProductByInfo (152)
#endif

/* ns2__updateClient * has binding name 'PointerTons2__updateClient' for type 'ns2:updateClient' */
#ifndef SOAP_TYPE_PointerTons2__updateClient
#define SOAP_TYPE_PointerTons2__updateClient (148)
#endif

/* ns2__getReadMessageFromShop * has binding name 'PointerTons2__getReadMessageFromShop' for type 'ns2:getReadMessageFromShop' */
#ifndef SOAP_TYPE_PointerTons2__getReadMessageFromShop
#define SOAP_TYPE_PointerTons2__getReadMessageFromShop (144)
#endif

/* ns2__getProductListByInfo * has binding name 'PointerTons2__getProductListByInfo' for type 'ns2:getProductListByInfo' */
#ifndef SOAP_TYPE_PointerTons2__getProductListByInfo
#define SOAP_TYPE_PointerTons2__getProductListByInfo (140)
#endif

/* ns2__updateShop * has binding name 'PointerTons2__updateShop' for type 'ns2:updateShop' */
#ifndef SOAP_TYPE_PointerTons2__updateShop
#define SOAP_TYPE_PointerTons2__updateShop (136)
#endif

/* ns2__getShopByNameAndPwd * has binding name 'PointerTons2__getShopByNameAndPwd' for type 'ns2:getShopByNameAndPwd' */
#ifndef SOAP_TYPE_PointerTons2__getShopByNameAndPwd
#define SOAP_TYPE_PointerTons2__getShopByNameAndPwd (132)
#endif

/* ns2__getOrderList * has binding name 'PointerTons2__getOrderList' for type 'ns2:getOrderList' */
#ifndef SOAP_TYPE_PointerTons2__getOrderList
#define SOAP_TYPE_PointerTons2__getOrderList (128)
#endif

/* ns2__deleteProductTypeByName * has binding name 'PointerTons2__deleteProductTypeByName' for type 'ns2:deleteProductTypeByName' */
#ifndef SOAP_TYPE_PointerTons2__deleteProductTypeByName
#define SOAP_TYPE_PointerTons2__deleteProductTypeByName (124)
#endif

/* ns2__addProduct * has binding name 'PointerTons2__addProduct' for type 'ns2:addProduct' */
#ifndef SOAP_TYPE_PointerTons2__addProduct
#define SOAP_TYPE_PointerTons2__addProduct (120)
#endif

/* ns2__selectProductForUpdate * has binding name 'PointerTons2__selectProductForUpdate' for type 'ns2:selectProductForUpdate' */
#ifndef SOAP_TYPE_PointerTons2__selectProductForUpdate
#define SOAP_TYPE_PointerTons2__selectProductForUpdate (116)
#endif

/* ns2__productType * has binding name 'PointerTons2__productType' for type 'ns2:productType' */
#ifndef SOAP_TYPE_PointerTons2__productType
#define SOAP_TYPE_PointerTons2__productType (112)
#endif

/* ns2__message * has binding name 'PointerTons2__message' for type 'ns2:message' */
#ifndef SOAP_TYPE_PointerTons2__message
#define SOAP_TYPE_PointerTons2__message (110)
#endif

/* ns2__client * has binding name 'PointerTons2__client' for type 'ns2:client' */
#ifndef SOAP_TYPE_PointerTons2__client
#define SOAP_TYPE_PointerTons2__client (109)
#endif

/* ns2__shop * has binding name 'PointerTons2__shop' for type 'ns2:shop' */
#ifndef SOAP_TYPE_PointerTons2__shop
#define SOAP_TYPE_PointerTons2__shop (107)
#endif

/* std::string * has binding name 'PointerToxsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_PointerToxsd__decimal
#define SOAP_TYPE_PointerToxsd__decimal (105)
#endif

/* ns2__order * has binding name 'PointerTons2__order' for type 'ns2:order' */
#ifndef SOAP_TYPE_PointerTons2__order
#define SOAP_TYPE_PointerTons2__order (104)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (103)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (101)
#endif

/* ns2__product * has binding name 'PointerTons2__product' for type 'ns2:product' */
#ifndef SOAP_TYPE_PointerTons2__product
#define SOAP_TYPE_PointerTons2__product (99)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns2__shop *>  has binding name 'std__vectorTemplateOfPointerTons2__shop' for type 'ns2:shop' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop (115)
#endif

/* std::vector<ns2__client *>  has binding name 'std__vectorTemplateOfPointerTons2__client' for type 'ns2:client' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__client
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__client (114)
#endif

/* std::vector<ns2__productType *>  has binding name 'std__vectorTemplateOfPointerTons2__productType' for type 'ns2:productType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType (113)
#endif

/* std::vector<ns2__message *>  has binding name 'std__vectorTemplateOfPointerTons2__message' for type 'ns2:message' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__message
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__message (111)
#endif

/* std::vector<ns2__product *>  has binding name 'std__vectorTemplateOfPointerTons2__product' for type 'ns2:product' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__product
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__product (108)
#endif

/* std::vector<ns2__order *>  has binding name 'std__vectorTemplateOfPointerTons2__order' for type 'ns2:order' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__order
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__order (106)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
