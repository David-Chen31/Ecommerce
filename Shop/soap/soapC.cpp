/* soapC.cpp
   Generated by gSOAP 2.8.135 for soap_head.h

gSOAP XML Web services tools
Copyright (C) 2000,2024, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.135 2025-01-05 12:46:22 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	if (!soap->fault)
		return NULL;
	if (soap->version == 2)
		return soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode ? soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value : NULL;
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns2__InsertClientResponse:
		return soap_in_ns2__InsertClientResponse(soap, tag, NULL, "ns2:InsertClientResponse");
	case SOAP_TYPE_ns2__InsertClient:
		return soap_in_ns2__InsertClient(soap, tag, NULL, "ns2:InsertClient");
	case SOAP_TYPE_ns2__deleteShoppingCartResponse:
		return soap_in_ns2__deleteShoppingCartResponse(soap, tag, NULL, "ns2:deleteShoppingCartResponse");
	case SOAP_TYPE_ns2__deleteShoppingCart:
		return soap_in_ns2__deleteShoppingCart(soap, tag, NULL, "ns2:deleteShoppingCart");
	case SOAP_TYPE_ns2__getClientByNameAndPwdResponse:
		return soap_in_ns2__getClientByNameAndPwdResponse(soap, tag, NULL, "ns2:getClientByNameAndPwdResponse");
	case SOAP_TYPE_ns2__getClientByNameAndPwd:
		return soap_in_ns2__getClientByNameAndPwd(soap, tag, NULL, "ns2:getClientByNameAndPwd");
	case SOAP_TYPE_ns2__getProductLikeListResponse:
		return soap_in_ns2__getProductLikeListResponse(soap, tag, NULL, "ns2:getProductLikeListResponse");
	case SOAP_TYPE_ns2__getProductLikeList:
		return soap_in_ns2__getProductLikeList(soap, tag, NULL, "ns2:getProductLikeList");
	case SOAP_TYPE_ns2__deleteMessageFromClientResponse:
		return soap_in_ns2__deleteMessageFromClientResponse(soap, tag, NULL, "ns2:deleteMessageFromClientResponse");
	case SOAP_TYPE_ns2__deleteMessageFromClient:
		return soap_in_ns2__deleteMessageFromClient(soap, tag, NULL, "ns2:deleteMessageFromClient");
	case SOAP_TYPE_ns2__addProductTypeResponse:
		return soap_in_ns2__addProductTypeResponse(soap, tag, NULL, "ns2:addProductTypeResponse");
	case SOAP_TYPE_ns2__addProductType:
		return soap_in_ns2__addProductType(soap, tag, NULL, "ns2:addProductType");
	case SOAP_TYPE_ns2__getOrderListByInfoResponse:
		return soap_in_ns2__getOrderListByInfoResponse(soap, tag, NULL, "ns2:getOrderListByInfoResponse");
	case SOAP_TYPE_ns2__getOrderListByInfo:
		return soap_in_ns2__getOrderListByInfo(soap, tag, NULL, "ns2:getOrderListByInfo");
	case SOAP_TYPE_ns2__getShopListResponse:
		return soap_in_ns2__getShopListResponse(soap, tag, NULL, "ns2:getShopListResponse");
	case SOAP_TYPE_ns2__getShopList:
		return soap_in_ns2__getShopList(soap, tag, NULL, "ns2:getShopList");
	case SOAP_TYPE_ns2__getClientLikeListResponse:
		return soap_in_ns2__getClientLikeListResponse(soap, tag, NULL, "ns2:getClientLikeListResponse");
	case SOAP_TYPE_ns2__getClientLikeList:
		return soap_in_ns2__getClientLikeList(soap, tag, NULL, "ns2:getClientLikeList");
	case SOAP_TYPE_ns2__getUnreadMessageFromShopResponse:
		return soap_in_ns2__getUnreadMessageFromShopResponse(soap, tag, NULL, "ns2:getUnreadMessageFromShopResponse");
	case SOAP_TYPE_ns2__getUnreadMessageFromShop:
		return soap_in_ns2__getUnreadMessageFromShop(soap, tag, NULL, "ns2:getUnreadMessageFromShop");
	case SOAP_TYPE_ns2__getOrderLikeListResponse:
		return soap_in_ns2__getOrderLikeListResponse(soap, tag, NULL, "ns2:getOrderLikeListResponse");
	case SOAP_TYPE_ns2__getOrderLikeList:
		return soap_in_ns2__getOrderLikeList(soap, tag, NULL, "ns2:getOrderLikeList");
	case SOAP_TYPE_ns2__deleteMessageFromShopResponse:
		return soap_in_ns2__deleteMessageFromShopResponse(soap, tag, NULL, "ns2:deleteMessageFromShopResponse");
	case SOAP_TYPE_ns2__deleteMessageFromShop:
		return soap_in_ns2__deleteMessageFromShop(soap, tag, NULL, "ns2:deleteMessageFromShop");
	case SOAP_TYPE_ns2__getMessageFromShopResponse:
		return soap_in_ns2__getMessageFromShopResponse(soap, tag, NULL, "ns2:getMessageFromShopResponse");
	case SOAP_TYPE_ns2__getMessageFromShop:
		return soap_in_ns2__getMessageFromShop(soap, tag, NULL, "ns2:getMessageFromShop");
	case SOAP_TYPE_ns2__getShopLikeListResponse:
		return soap_in_ns2__getShopLikeListResponse(soap, tag, NULL, "ns2:getShopLikeListResponse");
	case SOAP_TYPE_ns2__getShopLikeList:
		return soap_in_ns2__getShopLikeList(soap, tag, NULL, "ns2:getShopLikeList");
	case SOAP_TYPE_ns2__InsertMessageResponse:
		return soap_in_ns2__InsertMessageResponse(soap, tag, NULL, "ns2:InsertMessageResponse");
	case SOAP_TYPE_ns2__InsertMessage:
		return soap_in_ns2__InsertMessage(soap, tag, NULL, "ns2:InsertMessage");
	case SOAP_TYPE_ns2__updateHistoryResponse:
		return soap_in_ns2__updateHistoryResponse(soap, tag, NULL, "ns2:updateHistoryResponse");
	case SOAP_TYPE_ns2__updateHistory:
		return soap_in_ns2__updateHistory(soap, tag, NULL, "ns2:updateHistory");
	case SOAP_TYPE_ns2__getReadMessageFromClientResponse:
		return soap_in_ns2__getReadMessageFromClientResponse(soap, tag, NULL, "ns2:getReadMessageFromClientResponse");
	case SOAP_TYPE_ns2__getReadMessageFromClient:
		return soap_in_ns2__getReadMessageFromClient(soap, tag, NULL, "ns2:getReadMessageFromClient");
	case SOAP_TYPE_ns2__getOrderListHistoryResponse:
		return soap_in_ns2__getOrderListHistoryResponse(soap, tag, NULL, "ns2:getOrderListHistoryResponse");
	case SOAP_TYPE_ns2__getOrderListHistory:
		return soap_in_ns2__getOrderListHistory(soap, tag, NULL, "ns2:getOrderListHistory");
	case SOAP_TYPE_ns2__getProductListResponse:
		return soap_in_ns2__getProductListResponse(soap, tag, NULL, "ns2:getProductListResponse");
	case SOAP_TYPE_ns2__getProductList:
		return soap_in_ns2__getProductList(soap, tag, NULL, "ns2:getProductList");
	case SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse:
		return soap_in_ns2__deleteShopByNameAndPwdResponse(soap, tag, NULL, "ns2:deleteShopByNameAndPwdResponse");
	case SOAP_TYPE_ns2__deleteShopByNameAndPwd:
		return soap_in_ns2__deleteShopByNameAndPwd(soap, tag, NULL, "ns2:deleteShopByNameAndPwd");
	case SOAP_TYPE_ns2__addOrderResponse:
		return soap_in_ns2__addOrderResponse(soap, tag, NULL, "ns2:addOrderResponse");
	case SOAP_TYPE_ns2__addOrder:
		return soap_in_ns2__addOrder(soap, tag, NULL, "ns2:addOrder");
	case SOAP_TYPE_ns2__getMessageFromClientResponse:
		return soap_in_ns2__getMessageFromClientResponse(soap, tag, NULL, "ns2:getMessageFromClientResponse");
	case SOAP_TYPE_ns2__getMessageFromClient:
		return soap_in_ns2__getMessageFromClient(soap, tag, NULL, "ns2:getMessageFromClient");
	case SOAP_TYPE_ns2__updateProductByInfoResponse:
		return soap_in_ns2__updateProductByInfoResponse(soap, tag, NULL, "ns2:updateProductByInfoResponse");
	case SOAP_TYPE_ns2__updateProductByInfo:
		return soap_in_ns2__updateProductByInfo(soap, tag, NULL, "ns2:updateProductByInfo");
	case SOAP_TYPE_ns2__getUnreadMessageFromClientResponse:
		return soap_in_ns2__getUnreadMessageFromClientResponse(soap, tag, NULL, "ns2:getUnreadMessageFromClientResponse");
	case SOAP_TYPE_ns2__getUnreadMessageFromClient:
		return soap_in_ns2__getUnreadMessageFromClient(soap, tag, NULL, "ns2:getUnreadMessageFromClient");
	case SOAP_TYPE_ns2__updateMessageFromClientResponse:
		return soap_in_ns2__updateMessageFromClientResponse(soap, tag, NULL, "ns2:updateMessageFromClientResponse");
	case SOAP_TYPE_ns2__updateMessageFromClient:
		return soap_in_ns2__updateMessageFromClient(soap, tag, NULL, "ns2:updateMessageFromClient");
	case SOAP_TYPE_ns2__purchaseProductResponse:
		return soap_in_ns2__purchaseProductResponse(soap, tag, NULL, "ns2:purchaseProductResponse");
	case SOAP_TYPE_ns2__purchaseProduct:
		return soap_in_ns2__purchaseProduct(soap, tag, NULL, "ns2:purchaseProduct");
	case SOAP_TYPE_ns2__getClientListResponse:
		return soap_in_ns2__getClientListResponse(soap, tag, NULL, "ns2:getClientListResponse");
	case SOAP_TYPE_ns2__getClientList:
		return soap_in_ns2__getClientList(soap, tag, NULL, "ns2:getClientList");
	case SOAP_TYPE_ns2__productType:
		return soap_in_ns2__productType(soap, tag, NULL, "ns2:productType");
	case SOAP_TYPE_ns2__getProductTypeByProNameResponse:
		return soap_in_ns2__getProductTypeByProNameResponse(soap, tag, NULL, "ns2:getProductTypeByProNameResponse");
	case SOAP_TYPE_ns2__getProductTypeByProName:
		return soap_in_ns2__getProductTypeByProName(soap, tag, NULL, "ns2:getProductTypeByProName");
	case SOAP_TYPE_ns2__updateMessageFromShopResponse:
		return soap_in_ns2__updateMessageFromShopResponse(soap, tag, NULL, "ns2:updateMessageFromShopResponse");
	case SOAP_TYPE_ns2__updateMessageFromShop:
		return soap_in_ns2__updateMessageFromShop(soap, tag, NULL, "ns2:updateMessageFromShop");
	case SOAP_TYPE_ns2__InsertShopResponse:
		return soap_in_ns2__InsertShopResponse(soap, tag, NULL, "ns2:InsertShopResponse");
	case SOAP_TYPE_ns2__InsertShop:
		return soap_in_ns2__InsertShop(soap, tag, NULL, "ns2:InsertShop");
	case SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse:
		return soap_in_ns2__deleteClientByNameAndPwdResponse(soap, tag, NULL, "ns2:deleteClientByNameAndPwdResponse");
	case SOAP_TYPE_ns2__deleteClientByNameAndPwd:
		return soap_in_ns2__deleteClientByNameAndPwd(soap, tag, NULL, "ns2:deleteClientByNameAndPwd");
	case SOAP_TYPE_ns2__deleteProductByInfoResponse:
		return soap_in_ns2__deleteProductByInfoResponse(soap, tag, NULL, "ns2:deleteProductByInfoResponse");
	case SOAP_TYPE_ns2__deleteProductByInfo:
		return soap_in_ns2__deleteProductByInfo(soap, tag, NULL, "ns2:deleteProductByInfo");
	case SOAP_TYPE_ns2__updateClientResponse:
		return soap_in_ns2__updateClientResponse(soap, tag, NULL, "ns2:updateClientResponse");
	case SOAP_TYPE_ns2__updateClient:
		return soap_in_ns2__updateClient(soap, tag, NULL, "ns2:updateClient");
	case SOAP_TYPE_ns2__message:
		return soap_in_ns2__message(soap, tag, NULL, "ns2:message");
	case SOAP_TYPE_ns2__getReadMessageFromShopResponse:
		return soap_in_ns2__getReadMessageFromShopResponse(soap, tag, NULL, "ns2:getReadMessageFromShopResponse");
	case SOAP_TYPE_ns2__client:
		return soap_in_ns2__client(soap, tag, NULL, "ns2:client");
	case SOAP_TYPE_ns2__getReadMessageFromShop:
		return soap_in_ns2__getReadMessageFromShop(soap, tag, NULL, "ns2:getReadMessageFromShop");
	case SOAP_TYPE_ns2__getProductListByInfoResponse:
		return soap_in_ns2__getProductListByInfoResponse(soap, tag, NULL, "ns2:getProductListByInfoResponse");
	case SOAP_TYPE_ns2__getProductListByInfo:
		return soap_in_ns2__getProductListByInfo(soap, tag, NULL, "ns2:getProductListByInfo");
	case SOAP_TYPE_ns2__updateShopResponse:
		return soap_in_ns2__updateShopResponse(soap, tag, NULL, "ns2:updateShopResponse");
	case SOAP_TYPE_ns2__updateShop:
		return soap_in_ns2__updateShop(soap, tag, NULL, "ns2:updateShop");
	case SOAP_TYPE_ns2__shop:
		return soap_in_ns2__shop(soap, tag, NULL, "ns2:shop");
	case SOAP_TYPE_ns2__getShopByNameAndPwdResponse:
		return soap_in_ns2__getShopByNameAndPwdResponse(soap, tag, NULL, "ns2:getShopByNameAndPwdResponse");
	case SOAP_TYPE_ns2__getShopByNameAndPwd:
		return soap_in_ns2__getShopByNameAndPwd(soap, tag, NULL, "ns2:getShopByNameAndPwd");
	case SOAP_TYPE_ns2__getOrderListResponse:
		return soap_in_ns2__getOrderListResponse(soap, tag, NULL, "ns2:getOrderListResponse");
	case SOAP_TYPE_ns2__order:
		return soap_in_ns2__order(soap, tag, NULL, "ns2:order");
	case SOAP_TYPE_ns2__getOrderList:
		return soap_in_ns2__getOrderList(soap, tag, NULL, "ns2:getOrderList");
	case SOAP_TYPE_ns2__deleteProductTypeByNameResponse:
		return soap_in_ns2__deleteProductTypeByNameResponse(soap, tag, NULL, "ns2:deleteProductTypeByNameResponse");
	case SOAP_TYPE_ns2__deleteProductTypeByName:
		return soap_in_ns2__deleteProductTypeByName(soap, tag, NULL, "ns2:deleteProductTypeByName");
	case SOAP_TYPE_ns2__addProductResponse:
		return soap_in_ns2__addProductResponse(soap, tag, NULL, "ns2:addProductResponse");
	case SOAP_TYPE_ns2__addProduct:
		return soap_in_ns2__addProduct(soap, tag, NULL, "ns2:addProduct");
	case SOAP_TYPE_ns2__product:
		return soap_in_ns2__product(soap, tag, NULL, "ns2:product");
	case SOAP_TYPE_ns2__selectProductForUpdateResponse:
		return soap_in_ns2__selectProductForUpdateResponse(soap, tag, NULL, "ns2:selectProductForUpdateResponse");
	case SOAP_TYPE_ns2__selectProductForUpdate:
		return soap_in_ns2__selectProductForUpdate(soap, tag, NULL, "ns2:selectProductForUpdate");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__InsertClient:
		return soap_in_PointerTons2__InsertClient(soap, tag, NULL, "ns2:InsertClient");
	case SOAP_TYPE_PointerTons2__deleteShoppingCart:
		return soap_in_PointerTons2__deleteShoppingCart(soap, tag, NULL, "ns2:deleteShoppingCart");
	case SOAP_TYPE_PointerTons2__getClientByNameAndPwd:
		return soap_in_PointerTons2__getClientByNameAndPwd(soap, tag, NULL, "ns2:getClientByNameAndPwd");
	case SOAP_TYPE_PointerTons2__getProductLikeList:
		return soap_in_PointerTons2__getProductLikeList(soap, tag, NULL, "ns2:getProductLikeList");
	case SOAP_TYPE_PointerTons2__deleteMessageFromClient:
		return soap_in_PointerTons2__deleteMessageFromClient(soap, tag, NULL, "ns2:deleteMessageFromClient");
	case SOAP_TYPE_PointerTons2__addProductType:
		return soap_in_PointerTons2__addProductType(soap, tag, NULL, "ns2:addProductType");
	case SOAP_TYPE_PointerTons2__getOrderListByInfo:
		return soap_in_PointerTons2__getOrderListByInfo(soap, tag, NULL, "ns2:getOrderListByInfo");
	case SOAP_TYPE_PointerTons2__getShopList:
		return soap_in_PointerTons2__getShopList(soap, tag, NULL, "ns2:getShopList");
	case SOAP_TYPE_PointerTons2__getClientLikeList:
		return soap_in_PointerTons2__getClientLikeList(soap, tag, NULL, "ns2:getClientLikeList");
	case SOAP_TYPE_PointerTons2__getUnreadMessageFromShop:
		return soap_in_PointerTons2__getUnreadMessageFromShop(soap, tag, NULL, "ns2:getUnreadMessageFromShop");
	case SOAP_TYPE_PointerTons2__getOrderLikeList:
		return soap_in_PointerTons2__getOrderLikeList(soap, tag, NULL, "ns2:getOrderLikeList");
	case SOAP_TYPE_PointerTons2__deleteMessageFromShop:
		return soap_in_PointerTons2__deleteMessageFromShop(soap, tag, NULL, "ns2:deleteMessageFromShop");
	case SOAP_TYPE_PointerTons2__getMessageFromShop:
		return soap_in_PointerTons2__getMessageFromShop(soap, tag, NULL, "ns2:getMessageFromShop");
	case SOAP_TYPE_PointerTons2__getShopLikeList:
		return soap_in_PointerTons2__getShopLikeList(soap, tag, NULL, "ns2:getShopLikeList");
	case SOAP_TYPE_PointerTons2__InsertMessage:
		return soap_in_PointerTons2__InsertMessage(soap, tag, NULL, "ns2:InsertMessage");
	case SOAP_TYPE_PointerTons2__updateHistory:
		return soap_in_PointerTons2__updateHistory(soap, tag, NULL, "ns2:updateHistory");
	case SOAP_TYPE_PointerTons2__getReadMessageFromClient:
		return soap_in_PointerTons2__getReadMessageFromClient(soap, tag, NULL, "ns2:getReadMessageFromClient");
	case SOAP_TYPE_PointerTons2__getOrderListHistory:
		return soap_in_PointerTons2__getOrderListHistory(soap, tag, NULL, "ns2:getOrderListHistory");
	case SOAP_TYPE_PointerTons2__getProductList:
		return soap_in_PointerTons2__getProductList(soap, tag, NULL, "ns2:getProductList");
	case SOAP_TYPE_PointerTons2__deleteShopByNameAndPwd:
		return soap_in_PointerTons2__deleteShopByNameAndPwd(soap, tag, NULL, "ns2:deleteShopByNameAndPwd");
	case SOAP_TYPE_PointerTons2__addOrder:
		return soap_in_PointerTons2__addOrder(soap, tag, NULL, "ns2:addOrder");
	case SOAP_TYPE_PointerTons2__getMessageFromClient:
		return soap_in_PointerTons2__getMessageFromClient(soap, tag, NULL, "ns2:getMessageFromClient");
	case SOAP_TYPE_PointerTons2__updateProductByInfo:
		return soap_in_PointerTons2__updateProductByInfo(soap, tag, NULL, "ns2:updateProductByInfo");
	case SOAP_TYPE_PointerTons2__getUnreadMessageFromClient:
		return soap_in_PointerTons2__getUnreadMessageFromClient(soap, tag, NULL, "ns2:getUnreadMessageFromClient");
	case SOAP_TYPE_PointerTons2__updateMessageFromClient:
		return soap_in_PointerTons2__updateMessageFromClient(soap, tag, NULL, "ns2:updateMessageFromClient");
	case SOAP_TYPE_PointerTons2__purchaseProduct:
		return soap_in_PointerTons2__purchaseProduct(soap, tag, NULL, "ns2:purchaseProduct");
	case SOAP_TYPE_PointerTons2__getClientList:
		return soap_in_PointerTons2__getClientList(soap, tag, NULL, "ns2:getClientList");
	case SOAP_TYPE_PointerTons2__getProductTypeByProName:
		return soap_in_PointerTons2__getProductTypeByProName(soap, tag, NULL, "ns2:getProductTypeByProName");
	case SOAP_TYPE_PointerTons2__updateMessageFromShop:
		return soap_in_PointerTons2__updateMessageFromShop(soap, tag, NULL, "ns2:updateMessageFromShop");
	case SOAP_TYPE_PointerTons2__InsertShop:
		return soap_in_PointerTons2__InsertShop(soap, tag, NULL, "ns2:InsertShop");
	case SOAP_TYPE_PointerTons2__deleteClientByNameAndPwd:
		return soap_in_PointerTons2__deleteClientByNameAndPwd(soap, tag, NULL, "ns2:deleteClientByNameAndPwd");
	case SOAP_TYPE_PointerTons2__deleteProductByInfo:
		return soap_in_PointerTons2__deleteProductByInfo(soap, tag, NULL, "ns2:deleteProductByInfo");
	case SOAP_TYPE_PointerTons2__updateClient:
		return soap_in_PointerTons2__updateClient(soap, tag, NULL, "ns2:updateClient");
	case SOAP_TYPE_PointerTons2__getReadMessageFromShop:
		return soap_in_PointerTons2__getReadMessageFromShop(soap, tag, NULL, "ns2:getReadMessageFromShop");
	case SOAP_TYPE_PointerTons2__getProductListByInfo:
		return soap_in_PointerTons2__getProductListByInfo(soap, tag, NULL, "ns2:getProductListByInfo");
	case SOAP_TYPE_PointerTons2__updateShop:
		return soap_in_PointerTons2__updateShop(soap, tag, NULL, "ns2:updateShop");
	case SOAP_TYPE_PointerTons2__getShopByNameAndPwd:
		return soap_in_PointerTons2__getShopByNameAndPwd(soap, tag, NULL, "ns2:getShopByNameAndPwd");
	case SOAP_TYPE_PointerTons2__getOrderList:
		return soap_in_PointerTons2__getOrderList(soap, tag, NULL, "ns2:getOrderList");
	case SOAP_TYPE_PointerTons2__deleteProductTypeByName:
		return soap_in_PointerTons2__deleteProductTypeByName(soap, tag, NULL, "ns2:deleteProductTypeByName");
	case SOAP_TYPE_PointerTons2__addProduct:
		return soap_in_PointerTons2__addProduct(soap, tag, NULL, "ns2:addProduct");
	case SOAP_TYPE_PointerTons2__selectProductForUpdate:
		return soap_in_PointerTons2__selectProductForUpdate(soap, tag, NULL, "ns2:selectProductForUpdate");
	case SOAP_TYPE_PointerTons2__productType:
		return soap_in_PointerTons2__productType(soap, tag, NULL, "ns2:productType");
	case SOAP_TYPE_PointerTons2__message:
		return soap_in_PointerTons2__message(soap, tag, NULL, "ns2:message");
	case SOAP_TYPE_PointerTons2__client:
		return soap_in_PointerTons2__client(soap, tag, NULL, "ns2:client");
	case SOAP_TYPE_PointerTons2__shop:
		return soap_in_PointerTons2__shop(soap, tag, NULL, "ns2:shop");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__order:
		return soap_in_PointerTons2__order(soap, tag, NULL, "ns2:order");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons2__product:
		return soap_in_PointerTons2__product(soap, tag, NULL, "ns2:product");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:InsertClientResponse"))
		{	*type = SOAP_TYPE_ns2__InsertClientResponse;
			return soap_in_ns2__InsertClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InsertClient"))
		{	*type = SOAP_TYPE_ns2__InsertClient;
			return soap_in_ns2__InsertClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteShoppingCartResponse"))
		{	*type = SOAP_TYPE_ns2__deleteShoppingCartResponse;
			return soap_in_ns2__deleteShoppingCartResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteShoppingCart"))
		{	*type = SOAP_TYPE_ns2__deleteShoppingCart;
			return soap_in_ns2__deleteShoppingCart(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClientByNameAndPwdResponse"))
		{	*type = SOAP_TYPE_ns2__getClientByNameAndPwdResponse;
			return soap_in_ns2__getClientByNameAndPwdResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClientByNameAndPwd"))
		{	*type = SOAP_TYPE_ns2__getClientByNameAndPwd;
			return soap_in_ns2__getClientByNameAndPwd(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductLikeListResponse"))
		{	*type = SOAP_TYPE_ns2__getProductLikeListResponse;
			return soap_in_ns2__getProductLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductLikeList"))
		{	*type = SOAP_TYPE_ns2__getProductLikeList;
			return soap_in_ns2__getProductLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteMessageFromClientResponse"))
		{	*type = SOAP_TYPE_ns2__deleteMessageFromClientResponse;
			return soap_in_ns2__deleteMessageFromClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteMessageFromClient"))
		{	*type = SOAP_TYPE_ns2__deleteMessageFromClient;
			return soap_in_ns2__deleteMessageFromClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addProductTypeResponse"))
		{	*type = SOAP_TYPE_ns2__addProductTypeResponse;
			return soap_in_ns2__addProductTypeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addProductType"))
		{	*type = SOAP_TYPE_ns2__addProductType;
			return soap_in_ns2__addProductType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderListByInfoResponse"))
		{	*type = SOAP_TYPE_ns2__getOrderListByInfoResponse;
			return soap_in_ns2__getOrderListByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderListByInfo"))
		{	*type = SOAP_TYPE_ns2__getOrderListByInfo;
			return soap_in_ns2__getOrderListByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getShopListResponse"))
		{	*type = SOAP_TYPE_ns2__getShopListResponse;
			return soap_in_ns2__getShopListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getShopList"))
		{	*type = SOAP_TYPE_ns2__getShopList;
			return soap_in_ns2__getShopList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClientLikeListResponse"))
		{	*type = SOAP_TYPE_ns2__getClientLikeListResponse;
			return soap_in_ns2__getClientLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClientLikeList"))
		{	*type = SOAP_TYPE_ns2__getClientLikeList;
			return soap_in_ns2__getClientLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getUnreadMessageFromShopResponse"))
		{	*type = SOAP_TYPE_ns2__getUnreadMessageFromShopResponse;
			return soap_in_ns2__getUnreadMessageFromShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getUnreadMessageFromShop"))
		{	*type = SOAP_TYPE_ns2__getUnreadMessageFromShop;
			return soap_in_ns2__getUnreadMessageFromShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderLikeListResponse"))
		{	*type = SOAP_TYPE_ns2__getOrderLikeListResponse;
			return soap_in_ns2__getOrderLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderLikeList"))
		{	*type = SOAP_TYPE_ns2__getOrderLikeList;
			return soap_in_ns2__getOrderLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteMessageFromShopResponse"))
		{	*type = SOAP_TYPE_ns2__deleteMessageFromShopResponse;
			return soap_in_ns2__deleteMessageFromShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteMessageFromShop"))
		{	*type = SOAP_TYPE_ns2__deleteMessageFromShop;
			return soap_in_ns2__deleteMessageFromShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMessageFromShopResponse"))
		{	*type = SOAP_TYPE_ns2__getMessageFromShopResponse;
			return soap_in_ns2__getMessageFromShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMessageFromShop"))
		{	*type = SOAP_TYPE_ns2__getMessageFromShop;
			return soap_in_ns2__getMessageFromShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getShopLikeListResponse"))
		{	*type = SOAP_TYPE_ns2__getShopLikeListResponse;
			return soap_in_ns2__getShopLikeListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getShopLikeList"))
		{	*type = SOAP_TYPE_ns2__getShopLikeList;
			return soap_in_ns2__getShopLikeList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InsertMessageResponse"))
		{	*type = SOAP_TYPE_ns2__InsertMessageResponse;
			return soap_in_ns2__InsertMessageResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InsertMessage"))
		{	*type = SOAP_TYPE_ns2__InsertMessage;
			return soap_in_ns2__InsertMessage(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateHistoryResponse"))
		{	*type = SOAP_TYPE_ns2__updateHistoryResponse;
			return soap_in_ns2__updateHistoryResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateHistory"))
		{	*type = SOAP_TYPE_ns2__updateHistory;
			return soap_in_ns2__updateHistory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getReadMessageFromClientResponse"))
		{	*type = SOAP_TYPE_ns2__getReadMessageFromClientResponse;
			return soap_in_ns2__getReadMessageFromClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getReadMessageFromClient"))
		{	*type = SOAP_TYPE_ns2__getReadMessageFromClient;
			return soap_in_ns2__getReadMessageFromClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderListHistoryResponse"))
		{	*type = SOAP_TYPE_ns2__getOrderListHistoryResponse;
			return soap_in_ns2__getOrderListHistoryResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderListHistory"))
		{	*type = SOAP_TYPE_ns2__getOrderListHistory;
			return soap_in_ns2__getOrderListHistory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductListResponse"))
		{	*type = SOAP_TYPE_ns2__getProductListResponse;
			return soap_in_ns2__getProductListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductList"))
		{	*type = SOAP_TYPE_ns2__getProductList;
			return soap_in_ns2__getProductList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteShopByNameAndPwdResponse"))
		{	*type = SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse;
			return soap_in_ns2__deleteShopByNameAndPwdResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteShopByNameAndPwd"))
		{	*type = SOAP_TYPE_ns2__deleteShopByNameAndPwd;
			return soap_in_ns2__deleteShopByNameAndPwd(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addOrderResponse"))
		{	*type = SOAP_TYPE_ns2__addOrderResponse;
			return soap_in_ns2__addOrderResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addOrder"))
		{	*type = SOAP_TYPE_ns2__addOrder;
			return soap_in_ns2__addOrder(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMessageFromClientResponse"))
		{	*type = SOAP_TYPE_ns2__getMessageFromClientResponse;
			return soap_in_ns2__getMessageFromClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getMessageFromClient"))
		{	*type = SOAP_TYPE_ns2__getMessageFromClient;
			return soap_in_ns2__getMessageFromClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateProductByInfoResponse"))
		{	*type = SOAP_TYPE_ns2__updateProductByInfoResponse;
			return soap_in_ns2__updateProductByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateProductByInfo"))
		{	*type = SOAP_TYPE_ns2__updateProductByInfo;
			return soap_in_ns2__updateProductByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getUnreadMessageFromClientResponse"))
		{	*type = SOAP_TYPE_ns2__getUnreadMessageFromClientResponse;
			return soap_in_ns2__getUnreadMessageFromClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getUnreadMessageFromClient"))
		{	*type = SOAP_TYPE_ns2__getUnreadMessageFromClient;
			return soap_in_ns2__getUnreadMessageFromClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateMessageFromClientResponse"))
		{	*type = SOAP_TYPE_ns2__updateMessageFromClientResponse;
			return soap_in_ns2__updateMessageFromClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateMessageFromClient"))
		{	*type = SOAP_TYPE_ns2__updateMessageFromClient;
			return soap_in_ns2__updateMessageFromClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:purchaseProductResponse"))
		{	*type = SOAP_TYPE_ns2__purchaseProductResponse;
			return soap_in_ns2__purchaseProductResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:purchaseProduct"))
		{	*type = SOAP_TYPE_ns2__purchaseProduct;
			return soap_in_ns2__purchaseProduct(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClientListResponse"))
		{	*type = SOAP_TYPE_ns2__getClientListResponse;
			return soap_in_ns2__getClientListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getClientList"))
		{	*type = SOAP_TYPE_ns2__getClientList;
			return soap_in_ns2__getClientList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:productType"))
		{	*type = SOAP_TYPE_ns2__productType;
			return soap_in_ns2__productType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductTypeByProNameResponse"))
		{	*type = SOAP_TYPE_ns2__getProductTypeByProNameResponse;
			return soap_in_ns2__getProductTypeByProNameResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductTypeByProName"))
		{	*type = SOAP_TYPE_ns2__getProductTypeByProName;
			return soap_in_ns2__getProductTypeByProName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateMessageFromShopResponse"))
		{	*type = SOAP_TYPE_ns2__updateMessageFromShopResponse;
			return soap_in_ns2__updateMessageFromShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateMessageFromShop"))
		{	*type = SOAP_TYPE_ns2__updateMessageFromShop;
			return soap_in_ns2__updateMessageFromShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InsertShopResponse"))
		{	*type = SOAP_TYPE_ns2__InsertShopResponse;
			return soap_in_ns2__InsertShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InsertShop"))
		{	*type = SOAP_TYPE_ns2__InsertShop;
			return soap_in_ns2__InsertShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteClientByNameAndPwdResponse"))
		{	*type = SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse;
			return soap_in_ns2__deleteClientByNameAndPwdResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteClientByNameAndPwd"))
		{	*type = SOAP_TYPE_ns2__deleteClientByNameAndPwd;
			return soap_in_ns2__deleteClientByNameAndPwd(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteProductByInfoResponse"))
		{	*type = SOAP_TYPE_ns2__deleteProductByInfoResponse;
			return soap_in_ns2__deleteProductByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteProductByInfo"))
		{	*type = SOAP_TYPE_ns2__deleteProductByInfo;
			return soap_in_ns2__deleteProductByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateClientResponse"))
		{	*type = SOAP_TYPE_ns2__updateClientResponse;
			return soap_in_ns2__updateClientResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateClient"))
		{	*type = SOAP_TYPE_ns2__updateClient;
			return soap_in_ns2__updateClient(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:message"))
		{	*type = SOAP_TYPE_ns2__message;
			return soap_in_ns2__message(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getReadMessageFromShopResponse"))
		{	*type = SOAP_TYPE_ns2__getReadMessageFromShopResponse;
			return soap_in_ns2__getReadMessageFromShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:client"))
		{	*type = SOAP_TYPE_ns2__client;
			return soap_in_ns2__client(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getReadMessageFromShop"))
		{	*type = SOAP_TYPE_ns2__getReadMessageFromShop;
			return soap_in_ns2__getReadMessageFromShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductListByInfoResponse"))
		{	*type = SOAP_TYPE_ns2__getProductListByInfoResponse;
			return soap_in_ns2__getProductListByInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getProductListByInfo"))
		{	*type = SOAP_TYPE_ns2__getProductListByInfo;
			return soap_in_ns2__getProductListByInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateShopResponse"))
		{	*type = SOAP_TYPE_ns2__updateShopResponse;
			return soap_in_ns2__updateShopResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:updateShop"))
		{	*type = SOAP_TYPE_ns2__updateShop;
			return soap_in_ns2__updateShop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:shop"))
		{	*type = SOAP_TYPE_ns2__shop;
			return soap_in_ns2__shop(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getShopByNameAndPwdResponse"))
		{	*type = SOAP_TYPE_ns2__getShopByNameAndPwdResponse;
			return soap_in_ns2__getShopByNameAndPwdResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getShopByNameAndPwd"))
		{	*type = SOAP_TYPE_ns2__getShopByNameAndPwd;
			return soap_in_ns2__getShopByNameAndPwd(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderListResponse"))
		{	*type = SOAP_TYPE_ns2__getOrderListResponse;
			return soap_in_ns2__getOrderListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:order"))
		{	*type = SOAP_TYPE_ns2__order;
			return soap_in_ns2__order(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getOrderList"))
		{	*type = SOAP_TYPE_ns2__getOrderList;
			return soap_in_ns2__getOrderList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteProductTypeByNameResponse"))
		{	*type = SOAP_TYPE_ns2__deleteProductTypeByNameResponse;
			return soap_in_ns2__deleteProductTypeByNameResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:deleteProductTypeByName"))
		{	*type = SOAP_TYPE_ns2__deleteProductTypeByName;
			return soap_in_ns2__deleteProductTypeByName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addProductResponse"))
		{	*type = SOAP_TYPE_ns2__addProductResponse;
			return soap_in_ns2__addProductResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:addProduct"))
		{	*type = SOAP_TYPE_ns2__addProduct;
			return soap_in_ns2__addProduct(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:product"))
		{	*type = SOAP_TYPE_ns2__product;
			return soap_in_ns2__product(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:selectProductForUpdateResponse"))
		{	*type = SOAP_TYPE_ns2__selectProductForUpdateResponse;
			return soap_in_ns2__selectProductForUpdateResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:selectProductForUpdate"))
		{	*type = SOAP_TYPE_ns2__selectProductForUpdate;
			return soap_in_ns2__selectProductForUpdate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns2__InsertClientResponse:
		return ((ns2__InsertClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:InsertClientResponse");
	case SOAP_TYPE_ns2__InsertClient:
		return ((ns2__InsertClient *)ptr)->soap_out(soap, tag, id, "ns2:InsertClient");
	case SOAP_TYPE_ns2__deleteShoppingCartResponse:
		return ((ns2__deleteShoppingCartResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteShoppingCartResponse");
	case SOAP_TYPE_ns2__deleteShoppingCart:
		return ((ns2__deleteShoppingCart *)ptr)->soap_out(soap, tag, id, "ns2:deleteShoppingCart");
	case SOAP_TYPE_ns2__getClientByNameAndPwdResponse:
		return ((ns2__getClientByNameAndPwdResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClientByNameAndPwdResponse");
	case SOAP_TYPE_ns2__getClientByNameAndPwd:
		return ((ns2__getClientByNameAndPwd *)ptr)->soap_out(soap, tag, id, "ns2:getClientByNameAndPwd");
	case SOAP_TYPE_ns2__getProductLikeListResponse:
		return ((ns2__getProductLikeListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getProductLikeListResponse");
	case SOAP_TYPE_ns2__getProductLikeList:
		return ((ns2__getProductLikeList *)ptr)->soap_out(soap, tag, id, "ns2:getProductLikeList");
	case SOAP_TYPE_ns2__deleteMessageFromClientResponse:
		return ((ns2__deleteMessageFromClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteMessageFromClientResponse");
	case SOAP_TYPE_ns2__deleteMessageFromClient:
		return ((ns2__deleteMessageFromClient *)ptr)->soap_out(soap, tag, id, "ns2:deleteMessageFromClient");
	case SOAP_TYPE_ns2__addProductTypeResponse:
		return ((ns2__addProductTypeResponse *)ptr)->soap_out(soap, tag, id, "ns2:addProductTypeResponse");
	case SOAP_TYPE_ns2__addProductType:
		return ((ns2__addProductType *)ptr)->soap_out(soap, tag, id, "ns2:addProductType");
	case SOAP_TYPE_ns2__getOrderListByInfoResponse:
		return ((ns2__getOrderListByInfoResponse *)ptr)->soap_out(soap, tag, id, "ns2:getOrderListByInfoResponse");
	case SOAP_TYPE_ns2__getOrderListByInfo:
		return ((ns2__getOrderListByInfo *)ptr)->soap_out(soap, tag, id, "ns2:getOrderListByInfo");
	case SOAP_TYPE_ns2__getShopListResponse:
		return ((ns2__getShopListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getShopListResponse");
	case SOAP_TYPE_ns2__getShopList:
		return ((ns2__getShopList *)ptr)->soap_out(soap, tag, id, "ns2:getShopList");
	case SOAP_TYPE_ns2__getClientLikeListResponse:
		return ((ns2__getClientLikeListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClientLikeListResponse");
	case SOAP_TYPE_ns2__getClientLikeList:
		return ((ns2__getClientLikeList *)ptr)->soap_out(soap, tag, id, "ns2:getClientLikeList");
	case SOAP_TYPE_ns2__getUnreadMessageFromShopResponse:
		return ((ns2__getUnreadMessageFromShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:getUnreadMessageFromShopResponse");
	case SOAP_TYPE_ns2__getUnreadMessageFromShop:
		return ((ns2__getUnreadMessageFromShop *)ptr)->soap_out(soap, tag, id, "ns2:getUnreadMessageFromShop");
	case SOAP_TYPE_ns2__getOrderLikeListResponse:
		return ((ns2__getOrderLikeListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getOrderLikeListResponse");
	case SOAP_TYPE_ns2__getOrderLikeList:
		return ((ns2__getOrderLikeList *)ptr)->soap_out(soap, tag, id, "ns2:getOrderLikeList");
	case SOAP_TYPE_ns2__deleteMessageFromShopResponse:
		return ((ns2__deleteMessageFromShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteMessageFromShopResponse");
	case SOAP_TYPE_ns2__deleteMessageFromShop:
		return ((ns2__deleteMessageFromShop *)ptr)->soap_out(soap, tag, id, "ns2:deleteMessageFromShop");
	case SOAP_TYPE_ns2__getMessageFromShopResponse:
		return ((ns2__getMessageFromShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:getMessageFromShopResponse");
	case SOAP_TYPE_ns2__getMessageFromShop:
		return ((ns2__getMessageFromShop *)ptr)->soap_out(soap, tag, id, "ns2:getMessageFromShop");
	case SOAP_TYPE_ns2__getShopLikeListResponse:
		return ((ns2__getShopLikeListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getShopLikeListResponse");
	case SOAP_TYPE_ns2__getShopLikeList:
		return ((ns2__getShopLikeList *)ptr)->soap_out(soap, tag, id, "ns2:getShopLikeList");
	case SOAP_TYPE_ns2__InsertMessageResponse:
		return ((ns2__InsertMessageResponse *)ptr)->soap_out(soap, tag, id, "ns2:InsertMessageResponse");
	case SOAP_TYPE_ns2__InsertMessage:
		return ((ns2__InsertMessage *)ptr)->soap_out(soap, tag, id, "ns2:InsertMessage");
	case SOAP_TYPE_ns2__updateHistoryResponse:
		return ((ns2__updateHistoryResponse *)ptr)->soap_out(soap, tag, id, "ns2:updateHistoryResponse");
	case SOAP_TYPE_ns2__updateHistory:
		return ((ns2__updateHistory *)ptr)->soap_out(soap, tag, id, "ns2:updateHistory");
	case SOAP_TYPE_ns2__getReadMessageFromClientResponse:
		return ((ns2__getReadMessageFromClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:getReadMessageFromClientResponse");
	case SOAP_TYPE_ns2__getReadMessageFromClient:
		return ((ns2__getReadMessageFromClient *)ptr)->soap_out(soap, tag, id, "ns2:getReadMessageFromClient");
	case SOAP_TYPE_ns2__getOrderListHistoryResponse:
		return ((ns2__getOrderListHistoryResponse *)ptr)->soap_out(soap, tag, id, "ns2:getOrderListHistoryResponse");
	case SOAP_TYPE_ns2__getOrderListHistory:
		return ((ns2__getOrderListHistory *)ptr)->soap_out(soap, tag, id, "ns2:getOrderListHistory");
	case SOAP_TYPE_ns2__getProductListResponse:
		return ((ns2__getProductListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getProductListResponse");
	case SOAP_TYPE_ns2__getProductList:
		return ((ns2__getProductList *)ptr)->soap_out(soap, tag, id, "ns2:getProductList");
	case SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse:
		return ((ns2__deleteShopByNameAndPwdResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteShopByNameAndPwdResponse");
	case SOAP_TYPE_ns2__deleteShopByNameAndPwd:
		return ((ns2__deleteShopByNameAndPwd *)ptr)->soap_out(soap, tag, id, "ns2:deleteShopByNameAndPwd");
	case SOAP_TYPE_ns2__addOrderResponse:
		return ((ns2__addOrderResponse *)ptr)->soap_out(soap, tag, id, "ns2:addOrderResponse");
	case SOAP_TYPE_ns2__addOrder:
		return ((ns2__addOrder *)ptr)->soap_out(soap, tag, id, "ns2:addOrder");
	case SOAP_TYPE_ns2__getMessageFromClientResponse:
		return ((ns2__getMessageFromClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:getMessageFromClientResponse");
	case SOAP_TYPE_ns2__getMessageFromClient:
		return ((ns2__getMessageFromClient *)ptr)->soap_out(soap, tag, id, "ns2:getMessageFromClient");
	case SOAP_TYPE_ns2__updateProductByInfoResponse:
		return ((ns2__updateProductByInfoResponse *)ptr)->soap_out(soap, tag, id, "ns2:updateProductByInfoResponse");
	case SOAP_TYPE_ns2__updateProductByInfo:
		return ((ns2__updateProductByInfo *)ptr)->soap_out(soap, tag, id, "ns2:updateProductByInfo");
	case SOAP_TYPE_ns2__getUnreadMessageFromClientResponse:
		return ((ns2__getUnreadMessageFromClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:getUnreadMessageFromClientResponse");
	case SOAP_TYPE_ns2__getUnreadMessageFromClient:
		return ((ns2__getUnreadMessageFromClient *)ptr)->soap_out(soap, tag, id, "ns2:getUnreadMessageFromClient");
	case SOAP_TYPE_ns2__updateMessageFromClientResponse:
		return ((ns2__updateMessageFromClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:updateMessageFromClientResponse");
	case SOAP_TYPE_ns2__updateMessageFromClient:
		return ((ns2__updateMessageFromClient *)ptr)->soap_out(soap, tag, id, "ns2:updateMessageFromClient");
	case SOAP_TYPE_ns2__purchaseProductResponse:
		return ((ns2__purchaseProductResponse *)ptr)->soap_out(soap, tag, id, "ns2:purchaseProductResponse");
	case SOAP_TYPE_ns2__purchaseProduct:
		return ((ns2__purchaseProduct *)ptr)->soap_out(soap, tag, id, "ns2:purchaseProduct");
	case SOAP_TYPE_ns2__getClientListResponse:
		return ((ns2__getClientListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getClientListResponse");
	case SOAP_TYPE_ns2__getClientList:
		return ((ns2__getClientList *)ptr)->soap_out(soap, tag, id, "ns2:getClientList");
	case SOAP_TYPE_ns2__productType:
		return ((ns2__productType *)ptr)->soap_out(soap, tag, id, "ns2:productType");
	case SOAP_TYPE_ns2__getProductTypeByProNameResponse:
		return ((ns2__getProductTypeByProNameResponse *)ptr)->soap_out(soap, tag, id, "ns2:getProductTypeByProNameResponse");
	case SOAP_TYPE_ns2__getProductTypeByProName:
		return ((ns2__getProductTypeByProName *)ptr)->soap_out(soap, tag, id, "ns2:getProductTypeByProName");
	case SOAP_TYPE_ns2__updateMessageFromShopResponse:
		return ((ns2__updateMessageFromShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:updateMessageFromShopResponse");
	case SOAP_TYPE_ns2__updateMessageFromShop:
		return ((ns2__updateMessageFromShop *)ptr)->soap_out(soap, tag, id, "ns2:updateMessageFromShop");
	case SOAP_TYPE_ns2__InsertShopResponse:
		return ((ns2__InsertShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:InsertShopResponse");
	case SOAP_TYPE_ns2__InsertShop:
		return ((ns2__InsertShop *)ptr)->soap_out(soap, tag, id, "ns2:InsertShop");
	case SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse:
		return ((ns2__deleteClientByNameAndPwdResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteClientByNameAndPwdResponse");
	case SOAP_TYPE_ns2__deleteClientByNameAndPwd:
		return ((ns2__deleteClientByNameAndPwd *)ptr)->soap_out(soap, tag, id, "ns2:deleteClientByNameAndPwd");
	case SOAP_TYPE_ns2__deleteProductByInfoResponse:
		return ((ns2__deleteProductByInfoResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteProductByInfoResponse");
	case SOAP_TYPE_ns2__deleteProductByInfo:
		return ((ns2__deleteProductByInfo *)ptr)->soap_out(soap, tag, id, "ns2:deleteProductByInfo");
	case SOAP_TYPE_ns2__updateClientResponse:
		return ((ns2__updateClientResponse *)ptr)->soap_out(soap, tag, id, "ns2:updateClientResponse");
	case SOAP_TYPE_ns2__updateClient:
		return ((ns2__updateClient *)ptr)->soap_out(soap, tag, id, "ns2:updateClient");
	case SOAP_TYPE_ns2__message:
		return ((ns2__message *)ptr)->soap_out(soap, tag, id, "ns2:message");
	case SOAP_TYPE_ns2__getReadMessageFromShopResponse:
		return ((ns2__getReadMessageFromShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:getReadMessageFromShopResponse");
	case SOAP_TYPE_ns2__client:
		return ((ns2__client *)ptr)->soap_out(soap, tag, id, "ns2:client");
	case SOAP_TYPE_ns2__getReadMessageFromShop:
		return ((ns2__getReadMessageFromShop *)ptr)->soap_out(soap, tag, id, "ns2:getReadMessageFromShop");
	case SOAP_TYPE_ns2__getProductListByInfoResponse:
		return ((ns2__getProductListByInfoResponse *)ptr)->soap_out(soap, tag, id, "ns2:getProductListByInfoResponse");
	case SOAP_TYPE_ns2__getProductListByInfo:
		return ((ns2__getProductListByInfo *)ptr)->soap_out(soap, tag, id, "ns2:getProductListByInfo");
	case SOAP_TYPE_ns2__updateShopResponse:
		return ((ns2__updateShopResponse *)ptr)->soap_out(soap, tag, id, "ns2:updateShopResponse");
	case SOAP_TYPE_ns2__updateShop:
		return ((ns2__updateShop *)ptr)->soap_out(soap, tag, id, "ns2:updateShop");
	case SOAP_TYPE_ns2__shop:
		return ((ns2__shop *)ptr)->soap_out(soap, tag, id, "ns2:shop");
	case SOAP_TYPE_ns2__getShopByNameAndPwdResponse:
		return ((ns2__getShopByNameAndPwdResponse *)ptr)->soap_out(soap, tag, id, "ns2:getShopByNameAndPwdResponse");
	case SOAP_TYPE_ns2__getShopByNameAndPwd:
		return ((ns2__getShopByNameAndPwd *)ptr)->soap_out(soap, tag, id, "ns2:getShopByNameAndPwd");
	case SOAP_TYPE_ns2__getOrderListResponse:
		return ((ns2__getOrderListResponse *)ptr)->soap_out(soap, tag, id, "ns2:getOrderListResponse");
	case SOAP_TYPE_ns2__order:
		return ((ns2__order *)ptr)->soap_out(soap, tag, id, "ns2:order");
	case SOAP_TYPE_ns2__getOrderList:
		return ((ns2__getOrderList *)ptr)->soap_out(soap, tag, id, "ns2:getOrderList");
	case SOAP_TYPE_ns2__deleteProductTypeByNameResponse:
		return ((ns2__deleteProductTypeByNameResponse *)ptr)->soap_out(soap, tag, id, "ns2:deleteProductTypeByNameResponse");
	case SOAP_TYPE_ns2__deleteProductTypeByName:
		return ((ns2__deleteProductTypeByName *)ptr)->soap_out(soap, tag, id, "ns2:deleteProductTypeByName");
	case SOAP_TYPE_ns2__addProductResponse:
		return ((ns2__addProductResponse *)ptr)->soap_out(soap, tag, id, "ns2:addProductResponse");
	case SOAP_TYPE_ns2__addProduct:
		return ((ns2__addProduct *)ptr)->soap_out(soap, tag, id, "ns2:addProduct");
	case SOAP_TYPE_ns2__product:
		return ((ns2__product *)ptr)->soap_out(soap, tag, id, "ns2:product");
	case SOAP_TYPE_ns2__selectProductForUpdateResponse:
		return ((ns2__selectProductForUpdateResponse *)ptr)->soap_out(soap, tag, id, "ns2:selectProductForUpdateResponse");
	case SOAP_TYPE_ns2__selectProductForUpdate:
		return ((ns2__selectProductForUpdate *)ptr)->soap_out(soap, tag, id, "ns2:selectProductForUpdate");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__InsertClient:
		return soap_out_PointerTons2__InsertClient(soap, tag, id, (ns2__InsertClient *const*)ptr, "ns2:InsertClient");
	case SOAP_TYPE_PointerTons2__deleteShoppingCart:
		return soap_out_PointerTons2__deleteShoppingCart(soap, tag, id, (ns2__deleteShoppingCart *const*)ptr, "ns2:deleteShoppingCart");
	case SOAP_TYPE_PointerTons2__getClientByNameAndPwd:
		return soap_out_PointerTons2__getClientByNameAndPwd(soap, tag, id, (ns2__getClientByNameAndPwd *const*)ptr, "ns2:getClientByNameAndPwd");
	case SOAP_TYPE_PointerTons2__getProductLikeList:
		return soap_out_PointerTons2__getProductLikeList(soap, tag, id, (ns2__getProductLikeList *const*)ptr, "ns2:getProductLikeList");
	case SOAP_TYPE_PointerTons2__deleteMessageFromClient:
		return soap_out_PointerTons2__deleteMessageFromClient(soap, tag, id, (ns2__deleteMessageFromClient *const*)ptr, "ns2:deleteMessageFromClient");
	case SOAP_TYPE_PointerTons2__addProductType:
		return soap_out_PointerTons2__addProductType(soap, tag, id, (ns2__addProductType *const*)ptr, "ns2:addProductType");
	case SOAP_TYPE_PointerTons2__getOrderListByInfo:
		return soap_out_PointerTons2__getOrderListByInfo(soap, tag, id, (ns2__getOrderListByInfo *const*)ptr, "ns2:getOrderListByInfo");
	case SOAP_TYPE_PointerTons2__getShopList:
		return soap_out_PointerTons2__getShopList(soap, tag, id, (ns2__getShopList *const*)ptr, "ns2:getShopList");
	case SOAP_TYPE_PointerTons2__getClientLikeList:
		return soap_out_PointerTons2__getClientLikeList(soap, tag, id, (ns2__getClientLikeList *const*)ptr, "ns2:getClientLikeList");
	case SOAP_TYPE_PointerTons2__getUnreadMessageFromShop:
		return soap_out_PointerTons2__getUnreadMessageFromShop(soap, tag, id, (ns2__getUnreadMessageFromShop *const*)ptr, "ns2:getUnreadMessageFromShop");
	case SOAP_TYPE_PointerTons2__getOrderLikeList:
		return soap_out_PointerTons2__getOrderLikeList(soap, tag, id, (ns2__getOrderLikeList *const*)ptr, "ns2:getOrderLikeList");
	case SOAP_TYPE_PointerTons2__deleteMessageFromShop:
		return soap_out_PointerTons2__deleteMessageFromShop(soap, tag, id, (ns2__deleteMessageFromShop *const*)ptr, "ns2:deleteMessageFromShop");
	case SOAP_TYPE_PointerTons2__getMessageFromShop:
		return soap_out_PointerTons2__getMessageFromShop(soap, tag, id, (ns2__getMessageFromShop *const*)ptr, "ns2:getMessageFromShop");
	case SOAP_TYPE_PointerTons2__getShopLikeList:
		return soap_out_PointerTons2__getShopLikeList(soap, tag, id, (ns2__getShopLikeList *const*)ptr, "ns2:getShopLikeList");
	case SOAP_TYPE_PointerTons2__InsertMessage:
		return soap_out_PointerTons2__InsertMessage(soap, tag, id, (ns2__InsertMessage *const*)ptr, "ns2:InsertMessage");
	case SOAP_TYPE_PointerTons2__updateHistory:
		return soap_out_PointerTons2__updateHistory(soap, tag, id, (ns2__updateHistory *const*)ptr, "ns2:updateHistory");
	case SOAP_TYPE_PointerTons2__getReadMessageFromClient:
		return soap_out_PointerTons2__getReadMessageFromClient(soap, tag, id, (ns2__getReadMessageFromClient *const*)ptr, "ns2:getReadMessageFromClient");
	case SOAP_TYPE_PointerTons2__getOrderListHistory:
		return soap_out_PointerTons2__getOrderListHistory(soap, tag, id, (ns2__getOrderListHistory *const*)ptr, "ns2:getOrderListHistory");
	case SOAP_TYPE_PointerTons2__getProductList:
		return soap_out_PointerTons2__getProductList(soap, tag, id, (ns2__getProductList *const*)ptr, "ns2:getProductList");
	case SOAP_TYPE_PointerTons2__deleteShopByNameAndPwd:
		return soap_out_PointerTons2__deleteShopByNameAndPwd(soap, tag, id, (ns2__deleteShopByNameAndPwd *const*)ptr, "ns2:deleteShopByNameAndPwd");
	case SOAP_TYPE_PointerTons2__addOrder:
		return soap_out_PointerTons2__addOrder(soap, tag, id, (ns2__addOrder *const*)ptr, "ns2:addOrder");
	case SOAP_TYPE_PointerTons2__getMessageFromClient:
		return soap_out_PointerTons2__getMessageFromClient(soap, tag, id, (ns2__getMessageFromClient *const*)ptr, "ns2:getMessageFromClient");
	case SOAP_TYPE_PointerTons2__updateProductByInfo:
		return soap_out_PointerTons2__updateProductByInfo(soap, tag, id, (ns2__updateProductByInfo *const*)ptr, "ns2:updateProductByInfo");
	case SOAP_TYPE_PointerTons2__getUnreadMessageFromClient:
		return soap_out_PointerTons2__getUnreadMessageFromClient(soap, tag, id, (ns2__getUnreadMessageFromClient *const*)ptr, "ns2:getUnreadMessageFromClient");
	case SOAP_TYPE_PointerTons2__updateMessageFromClient:
		return soap_out_PointerTons2__updateMessageFromClient(soap, tag, id, (ns2__updateMessageFromClient *const*)ptr, "ns2:updateMessageFromClient");
	case SOAP_TYPE_PointerTons2__purchaseProduct:
		return soap_out_PointerTons2__purchaseProduct(soap, tag, id, (ns2__purchaseProduct *const*)ptr, "ns2:purchaseProduct");
	case SOAP_TYPE_PointerTons2__getClientList:
		return soap_out_PointerTons2__getClientList(soap, tag, id, (ns2__getClientList *const*)ptr, "ns2:getClientList");
	case SOAP_TYPE_PointerTons2__getProductTypeByProName:
		return soap_out_PointerTons2__getProductTypeByProName(soap, tag, id, (ns2__getProductTypeByProName *const*)ptr, "ns2:getProductTypeByProName");
	case SOAP_TYPE_PointerTons2__updateMessageFromShop:
		return soap_out_PointerTons2__updateMessageFromShop(soap, tag, id, (ns2__updateMessageFromShop *const*)ptr, "ns2:updateMessageFromShop");
	case SOAP_TYPE_PointerTons2__InsertShop:
		return soap_out_PointerTons2__InsertShop(soap, tag, id, (ns2__InsertShop *const*)ptr, "ns2:InsertShop");
	case SOAP_TYPE_PointerTons2__deleteClientByNameAndPwd:
		return soap_out_PointerTons2__deleteClientByNameAndPwd(soap, tag, id, (ns2__deleteClientByNameAndPwd *const*)ptr, "ns2:deleteClientByNameAndPwd");
	case SOAP_TYPE_PointerTons2__deleteProductByInfo:
		return soap_out_PointerTons2__deleteProductByInfo(soap, tag, id, (ns2__deleteProductByInfo *const*)ptr, "ns2:deleteProductByInfo");
	case SOAP_TYPE_PointerTons2__updateClient:
		return soap_out_PointerTons2__updateClient(soap, tag, id, (ns2__updateClient *const*)ptr, "ns2:updateClient");
	case SOAP_TYPE_PointerTons2__getReadMessageFromShop:
		return soap_out_PointerTons2__getReadMessageFromShop(soap, tag, id, (ns2__getReadMessageFromShop *const*)ptr, "ns2:getReadMessageFromShop");
	case SOAP_TYPE_PointerTons2__getProductListByInfo:
		return soap_out_PointerTons2__getProductListByInfo(soap, tag, id, (ns2__getProductListByInfo *const*)ptr, "ns2:getProductListByInfo");
	case SOAP_TYPE_PointerTons2__updateShop:
		return soap_out_PointerTons2__updateShop(soap, tag, id, (ns2__updateShop *const*)ptr, "ns2:updateShop");
	case SOAP_TYPE_PointerTons2__getShopByNameAndPwd:
		return soap_out_PointerTons2__getShopByNameAndPwd(soap, tag, id, (ns2__getShopByNameAndPwd *const*)ptr, "ns2:getShopByNameAndPwd");
	case SOAP_TYPE_PointerTons2__getOrderList:
		return soap_out_PointerTons2__getOrderList(soap, tag, id, (ns2__getOrderList *const*)ptr, "ns2:getOrderList");
	case SOAP_TYPE_PointerTons2__deleteProductTypeByName:
		return soap_out_PointerTons2__deleteProductTypeByName(soap, tag, id, (ns2__deleteProductTypeByName *const*)ptr, "ns2:deleteProductTypeByName");
	case SOAP_TYPE_PointerTons2__addProduct:
		return soap_out_PointerTons2__addProduct(soap, tag, id, (ns2__addProduct *const*)ptr, "ns2:addProduct");
	case SOAP_TYPE_PointerTons2__selectProductForUpdate:
		return soap_out_PointerTons2__selectProductForUpdate(soap, tag, id, (ns2__selectProductForUpdate *const*)ptr, "ns2:selectProductForUpdate");
	case SOAP_TYPE_PointerTons2__productType:
		return soap_out_PointerTons2__productType(soap, tag, id, (ns2__productType *const*)ptr, "ns2:productType");
	case SOAP_TYPE_PointerTons2__message:
		return soap_out_PointerTons2__message(soap, tag, id, (ns2__message *const*)ptr, "ns2:message");
	case SOAP_TYPE_PointerTons2__client:
		return soap_out_PointerTons2__client(soap, tag, id, (ns2__client *const*)ptr, "ns2:client");
	case SOAP_TYPE_PointerTons2__shop:
		return soap_out_PointerTons2__shop(soap, tag, id, (ns2__shop *const*)ptr, "ns2:shop");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTons2__order:
		return soap_out_PointerTons2__order(soap, tag, id, (ns2__order *const*)ptr, "ns2:order");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons2__product:
		return soap_out_PointerTons2__product(soap, tag, id, (ns2__product *const*)ptr, "ns2:product");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns2__InsertClientResponse:
		((ns2__InsertClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__InsertClient:
		((ns2__InsertClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteShoppingCartResponse:
		((ns2__deleteShoppingCartResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteShoppingCart:
		((ns2__deleteShoppingCart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClientByNameAndPwdResponse:
		((ns2__getClientByNameAndPwdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClientByNameAndPwd:
		((ns2__getClientByNameAndPwd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductLikeListResponse:
		((ns2__getProductLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductLikeList:
		((ns2__getProductLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromClientResponse:
		((ns2__deleteMessageFromClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromClient:
		((ns2__deleteMessageFromClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addProductTypeResponse:
		((ns2__addProductTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addProductType:
		((ns2__addProductType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderListByInfoResponse:
		((ns2__getOrderListByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderListByInfo:
		((ns2__getOrderListByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getShopListResponse:
		((ns2__getShopListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getShopList:
		((ns2__getShopList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClientLikeListResponse:
		((ns2__getClientLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClientLikeList:
		((ns2__getClientLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromShopResponse:
		((ns2__getUnreadMessageFromShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromShop:
		((ns2__getUnreadMessageFromShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderLikeListResponse:
		((ns2__getOrderLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderLikeList:
		((ns2__getOrderLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromShopResponse:
		((ns2__deleteMessageFromShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromShop:
		((ns2__deleteMessageFromShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMessageFromShopResponse:
		((ns2__getMessageFromShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMessageFromShop:
		((ns2__getMessageFromShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getShopLikeListResponse:
		((ns2__getShopLikeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getShopLikeList:
		((ns2__getShopLikeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__InsertMessageResponse:
		((ns2__InsertMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__InsertMessage:
		((ns2__InsertMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateHistoryResponse:
		((ns2__updateHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateHistory:
		((ns2__updateHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromClientResponse:
		((ns2__getReadMessageFromClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromClient:
		((ns2__getReadMessageFromClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderListHistoryResponse:
		((ns2__getOrderListHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderListHistory:
		((ns2__getOrderListHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductListResponse:
		((ns2__getProductListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductList:
		((ns2__getProductList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse:
		((ns2__deleteShopByNameAndPwdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteShopByNameAndPwd:
		((ns2__deleteShopByNameAndPwd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addOrderResponse:
		((ns2__addOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addOrder:
		((ns2__addOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMessageFromClientResponse:
		((ns2__getMessageFromClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getMessageFromClient:
		((ns2__getMessageFromClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateProductByInfoResponse:
		((ns2__updateProductByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateProductByInfo:
		((ns2__updateProductByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromClientResponse:
		((ns2__getUnreadMessageFromClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromClient:
		((ns2__getUnreadMessageFromClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateMessageFromClientResponse:
		((ns2__updateMessageFromClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateMessageFromClient:
		((ns2__updateMessageFromClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__purchaseProductResponse:
		((ns2__purchaseProductResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__purchaseProduct:
		((ns2__purchaseProduct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClientListResponse:
		((ns2__getClientListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getClientList:
		((ns2__getClientList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__productType:
		((ns2__productType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductTypeByProNameResponse:
		((ns2__getProductTypeByProNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductTypeByProName:
		((ns2__getProductTypeByProName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateMessageFromShopResponse:
		((ns2__updateMessageFromShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateMessageFromShop:
		((ns2__updateMessageFromShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__InsertShopResponse:
		((ns2__InsertShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__InsertShop:
		((ns2__InsertShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse:
		((ns2__deleteClientByNameAndPwdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteClientByNameAndPwd:
		((ns2__deleteClientByNameAndPwd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteProductByInfoResponse:
		((ns2__deleteProductByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteProductByInfo:
		((ns2__deleteProductByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateClientResponse:
		((ns2__updateClientResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateClient:
		((ns2__updateClient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__message:
		((ns2__message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromShopResponse:
		((ns2__getReadMessageFromShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__client:
		((ns2__client *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromShop:
		((ns2__getReadMessageFromShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductListByInfoResponse:
		((ns2__getProductListByInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getProductListByInfo:
		((ns2__getProductListByInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateShopResponse:
		((ns2__updateShopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__updateShop:
		((ns2__updateShop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__shop:
		((ns2__shop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getShopByNameAndPwdResponse:
		((ns2__getShopByNameAndPwdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getShopByNameAndPwd:
		((ns2__getShopByNameAndPwd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderListResponse:
		((ns2__getOrderListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__order:
		((ns2__order *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__getOrderList:
		((ns2__getOrderList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteProductTypeByNameResponse:
		((ns2__deleteProductTypeByNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__deleteProductTypeByName:
		((ns2__deleteProductTypeByName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addProductResponse:
		((ns2__addProductResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__addProduct:
		((ns2__addProduct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__product:
		((ns2__product *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__selectProductForUpdateResponse:
		((ns2__selectProductForUpdateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__selectProductForUpdate:
		((ns2__selectProductForUpdate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__InsertClient:
		soap_serialize___ns1__InsertClient(soap, (const struct __ns1__InsertClient *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteShoppingCart:
		soap_serialize___ns1__deleteShoppingCart(soap, (const struct __ns1__deleteShoppingCart *)ptr);
		break;
	case SOAP_TYPE___ns1__getClientByNameAndPwd:
		soap_serialize___ns1__getClientByNameAndPwd(soap, (const struct __ns1__getClientByNameAndPwd *)ptr);
		break;
	case SOAP_TYPE___ns1__getProductLikeList:
		soap_serialize___ns1__getProductLikeList(soap, (const struct __ns1__getProductLikeList *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteMessageFromClient:
		soap_serialize___ns1__deleteMessageFromClient(soap, (const struct __ns1__deleteMessageFromClient *)ptr);
		break;
	case SOAP_TYPE___ns1__addProductType:
		soap_serialize___ns1__addProductType(soap, (const struct __ns1__addProductType *)ptr);
		break;
	case SOAP_TYPE___ns1__getOrderListByInfo:
		soap_serialize___ns1__getOrderListByInfo(soap, (const struct __ns1__getOrderListByInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__getShopList:
		soap_serialize___ns1__getShopList(soap, (const struct __ns1__getShopList *)ptr);
		break;
	case SOAP_TYPE___ns1__getClientLikeList:
		soap_serialize___ns1__getClientLikeList(soap, (const struct __ns1__getClientLikeList *)ptr);
		break;
	case SOAP_TYPE___ns1__getUnreadMessageFromShop:
		soap_serialize___ns1__getUnreadMessageFromShop(soap, (const struct __ns1__getUnreadMessageFromShop *)ptr);
		break;
	case SOAP_TYPE___ns1__getOrderLikeList:
		soap_serialize___ns1__getOrderLikeList(soap, (const struct __ns1__getOrderLikeList *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteMessageFromShop:
		soap_serialize___ns1__deleteMessageFromShop(soap, (const struct __ns1__deleteMessageFromShop *)ptr);
		break;
	case SOAP_TYPE___ns1__getMessageFromShop:
		soap_serialize___ns1__getMessageFromShop(soap, (const struct __ns1__getMessageFromShop *)ptr);
		break;
	case SOAP_TYPE___ns1__getShopLikeList:
		soap_serialize___ns1__getShopLikeList(soap, (const struct __ns1__getShopLikeList *)ptr);
		break;
	case SOAP_TYPE___ns1__InsertMessage:
		soap_serialize___ns1__InsertMessage(soap, (const struct __ns1__InsertMessage *)ptr);
		break;
	case SOAP_TYPE___ns1__updateHistory:
		soap_serialize___ns1__updateHistory(soap, (const struct __ns1__updateHistory *)ptr);
		break;
	case SOAP_TYPE___ns1__getReadMessageFromClient:
		soap_serialize___ns1__getReadMessageFromClient(soap, (const struct __ns1__getReadMessageFromClient *)ptr);
		break;
	case SOAP_TYPE___ns1__getOrderListHistory:
		soap_serialize___ns1__getOrderListHistory(soap, (const struct __ns1__getOrderListHistory *)ptr);
		break;
	case SOAP_TYPE___ns1__getProductList:
		soap_serialize___ns1__getProductList(soap, (const struct __ns1__getProductList *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteShopByNameAndPwd:
		soap_serialize___ns1__deleteShopByNameAndPwd(soap, (const struct __ns1__deleteShopByNameAndPwd *)ptr);
		break;
	case SOAP_TYPE___ns1__addOrder:
		soap_serialize___ns1__addOrder(soap, (const struct __ns1__addOrder *)ptr);
		break;
	case SOAP_TYPE___ns1__getMessageFromClient:
		soap_serialize___ns1__getMessageFromClient(soap, (const struct __ns1__getMessageFromClient *)ptr);
		break;
	case SOAP_TYPE___ns1__updateProductByInfo:
		soap_serialize___ns1__updateProductByInfo(soap, (const struct __ns1__updateProductByInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__getUnreadMessageFromClient:
		soap_serialize___ns1__getUnreadMessageFromClient(soap, (const struct __ns1__getUnreadMessageFromClient *)ptr);
		break;
	case SOAP_TYPE___ns1__updateMessageFromClient:
		soap_serialize___ns1__updateMessageFromClient(soap, (const struct __ns1__updateMessageFromClient *)ptr);
		break;
	case SOAP_TYPE___ns1__purchaseProduct:
		soap_serialize___ns1__purchaseProduct(soap, (const struct __ns1__purchaseProduct *)ptr);
		break;
	case SOAP_TYPE___ns1__getClientList:
		soap_serialize___ns1__getClientList(soap, (const struct __ns1__getClientList *)ptr);
		break;
	case SOAP_TYPE___ns1__getProductTypeByProName:
		soap_serialize___ns1__getProductTypeByProName(soap, (const struct __ns1__getProductTypeByProName *)ptr);
		break;
	case SOAP_TYPE___ns1__updateMessageFromShop:
		soap_serialize___ns1__updateMessageFromShop(soap, (const struct __ns1__updateMessageFromShop *)ptr);
		break;
	case SOAP_TYPE___ns1__InsertShop:
		soap_serialize___ns1__InsertShop(soap, (const struct __ns1__InsertShop *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteClientByNameAndPwd:
		soap_serialize___ns1__deleteClientByNameAndPwd(soap, (const struct __ns1__deleteClientByNameAndPwd *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteProductByInfo:
		soap_serialize___ns1__deleteProductByInfo(soap, (const struct __ns1__deleteProductByInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__updateClient:
		soap_serialize___ns1__updateClient(soap, (const struct __ns1__updateClient *)ptr);
		break;
	case SOAP_TYPE___ns1__getReadMessageFromShop:
		soap_serialize___ns1__getReadMessageFromShop(soap, (const struct __ns1__getReadMessageFromShop *)ptr);
		break;
	case SOAP_TYPE___ns1__getProductListByInfo:
		soap_serialize___ns1__getProductListByInfo(soap, (const struct __ns1__getProductListByInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__updateShop:
		soap_serialize___ns1__updateShop(soap, (const struct __ns1__updateShop *)ptr);
		break;
	case SOAP_TYPE___ns1__getShopByNameAndPwd:
		soap_serialize___ns1__getShopByNameAndPwd(soap, (const struct __ns1__getShopByNameAndPwd *)ptr);
		break;
	case SOAP_TYPE___ns1__getOrderList:
		soap_serialize___ns1__getOrderList(soap, (const struct __ns1__getOrderList *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteProductTypeByName:
		soap_serialize___ns1__deleteProductTypeByName(soap, (const struct __ns1__deleteProductTypeByName *)ptr);
		break;
	case SOAP_TYPE___ns1__addProduct:
		soap_serialize___ns1__addProduct(soap, (const struct __ns1__addProduct *)ptr);
		break;
	case SOAP_TYPE___ns1__selectProductForUpdate:
		soap_serialize___ns1__selectProductForUpdate(soap, (const struct __ns1__selectProductForUpdate *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__InsertClient:
		soap_serialize_PointerTons2__InsertClient(soap, (ns2__InsertClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteShoppingCart:
		soap_serialize_PointerTons2__deleteShoppingCart(soap, (ns2__deleteShoppingCart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClientByNameAndPwd:
		soap_serialize_PointerTons2__getClientByNameAndPwd(soap, (ns2__getClientByNameAndPwd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getProductLikeList:
		soap_serialize_PointerTons2__getProductLikeList(soap, (ns2__getProductLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteMessageFromClient:
		soap_serialize_PointerTons2__deleteMessageFromClient(soap, (ns2__deleteMessageFromClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__addProductType:
		soap_serialize_PointerTons2__addProductType(soap, (ns2__addProductType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getOrderListByInfo:
		soap_serialize_PointerTons2__getOrderListByInfo(soap, (ns2__getOrderListByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getShopList:
		soap_serialize_PointerTons2__getShopList(soap, (ns2__getShopList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClientLikeList:
		soap_serialize_PointerTons2__getClientLikeList(soap, (ns2__getClientLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getUnreadMessageFromShop:
		soap_serialize_PointerTons2__getUnreadMessageFromShop(soap, (ns2__getUnreadMessageFromShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getOrderLikeList:
		soap_serialize_PointerTons2__getOrderLikeList(soap, (ns2__getOrderLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteMessageFromShop:
		soap_serialize_PointerTons2__deleteMessageFromShop(soap, (ns2__deleteMessageFromShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMessageFromShop:
		soap_serialize_PointerTons2__getMessageFromShop(soap, (ns2__getMessageFromShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getShopLikeList:
		soap_serialize_PointerTons2__getShopLikeList(soap, (ns2__getShopLikeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__InsertMessage:
		soap_serialize_PointerTons2__InsertMessage(soap, (ns2__InsertMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__updateHistory:
		soap_serialize_PointerTons2__updateHistory(soap, (ns2__updateHistory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getReadMessageFromClient:
		soap_serialize_PointerTons2__getReadMessageFromClient(soap, (ns2__getReadMessageFromClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getOrderListHistory:
		soap_serialize_PointerTons2__getOrderListHistory(soap, (ns2__getOrderListHistory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getProductList:
		soap_serialize_PointerTons2__getProductList(soap, (ns2__getProductList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteShopByNameAndPwd:
		soap_serialize_PointerTons2__deleteShopByNameAndPwd(soap, (ns2__deleteShopByNameAndPwd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__addOrder:
		soap_serialize_PointerTons2__addOrder(soap, (ns2__addOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getMessageFromClient:
		soap_serialize_PointerTons2__getMessageFromClient(soap, (ns2__getMessageFromClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__updateProductByInfo:
		soap_serialize_PointerTons2__updateProductByInfo(soap, (ns2__updateProductByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getUnreadMessageFromClient:
		soap_serialize_PointerTons2__getUnreadMessageFromClient(soap, (ns2__getUnreadMessageFromClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__updateMessageFromClient:
		soap_serialize_PointerTons2__updateMessageFromClient(soap, (ns2__updateMessageFromClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__purchaseProduct:
		soap_serialize_PointerTons2__purchaseProduct(soap, (ns2__purchaseProduct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getClientList:
		soap_serialize_PointerTons2__getClientList(soap, (ns2__getClientList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getProductTypeByProName:
		soap_serialize_PointerTons2__getProductTypeByProName(soap, (ns2__getProductTypeByProName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__updateMessageFromShop:
		soap_serialize_PointerTons2__updateMessageFromShop(soap, (ns2__updateMessageFromShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__InsertShop:
		soap_serialize_PointerTons2__InsertShop(soap, (ns2__InsertShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteClientByNameAndPwd:
		soap_serialize_PointerTons2__deleteClientByNameAndPwd(soap, (ns2__deleteClientByNameAndPwd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteProductByInfo:
		soap_serialize_PointerTons2__deleteProductByInfo(soap, (ns2__deleteProductByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__updateClient:
		soap_serialize_PointerTons2__updateClient(soap, (ns2__updateClient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getReadMessageFromShop:
		soap_serialize_PointerTons2__getReadMessageFromShop(soap, (ns2__getReadMessageFromShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getProductListByInfo:
		soap_serialize_PointerTons2__getProductListByInfo(soap, (ns2__getProductListByInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__updateShop:
		soap_serialize_PointerTons2__updateShop(soap, (ns2__updateShop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getShopByNameAndPwd:
		soap_serialize_PointerTons2__getShopByNameAndPwd(soap, (ns2__getShopByNameAndPwd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__getOrderList:
		soap_serialize_PointerTons2__getOrderList(soap, (ns2__getOrderList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__deleteProductTypeByName:
		soap_serialize_PointerTons2__deleteProductTypeByName(soap, (ns2__deleteProductTypeByName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__addProduct:
		soap_serialize_PointerTons2__addProduct(soap, (ns2__addProduct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__selectProductForUpdate:
		soap_serialize_PointerTons2__selectProductForUpdate(soap, (ns2__selectProductForUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__productType:
		soap_serialize_PointerTons2__productType(soap, (ns2__productType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__message:
		soap_serialize_PointerTons2__message(soap, (ns2__message *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__client:
		soap_serialize_PointerTons2__client(soap, (ns2__client *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__shop:
		soap_serialize_PointerTons2__shop(soap, (ns2__shop *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__order:
		soap_serialize_PointerTons2__order(soap, (ns2__order *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__product:
		soap_serialize_PointerTons2__product(soap, (ns2__product *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__selectProductForUpdate:
		return (void*)soap_instantiate_ns2__selectProductForUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__selectProductForUpdateResponse:
		return (void*)soap_instantiate_ns2__selectProductForUpdateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__product:
		return (void*)soap_instantiate_ns2__product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addProduct:
		return (void*)soap_instantiate_ns2__addProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addProductResponse:
		return (void*)soap_instantiate_ns2__addProductResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteProductTypeByName:
		return (void*)soap_instantiate_ns2__deleteProductTypeByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteProductTypeByNameResponse:
		return (void*)soap_instantiate_ns2__deleteProductTypeByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderList:
		return (void*)soap_instantiate_ns2__getOrderList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__order:
		return (void*)soap_instantiate_ns2__order(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderListResponse:
		return (void*)soap_instantiate_ns2__getOrderListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getShopByNameAndPwd:
		return (void*)soap_instantiate_ns2__getShopByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getShopByNameAndPwdResponse:
		return (void*)soap_instantiate_ns2__getShopByNameAndPwdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__shop:
		return (void*)soap_instantiate_ns2__shop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateShop:
		return (void*)soap_instantiate_ns2__updateShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateShopResponse:
		return (void*)soap_instantiate_ns2__updateShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductListByInfo:
		return (void*)soap_instantiate_ns2__getProductListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductListByInfoResponse:
		return (void*)soap_instantiate_ns2__getProductListByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getReadMessageFromShop:
		return (void*)soap_instantiate_ns2__getReadMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__client:
		return (void*)soap_instantiate_ns2__client(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getReadMessageFromShopResponse:
		return (void*)soap_instantiate_ns2__getReadMessageFromShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__message:
		return (void*)soap_instantiate_ns2__message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateClient:
		return (void*)soap_instantiate_ns2__updateClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateClientResponse:
		return (void*)soap_instantiate_ns2__updateClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteProductByInfo:
		return (void*)soap_instantiate_ns2__deleteProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteProductByInfoResponse:
		return (void*)soap_instantiate_ns2__deleteProductByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteClientByNameAndPwd:
		return (void*)soap_instantiate_ns2__deleteClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse:
		return (void*)soap_instantiate_ns2__deleteClientByNameAndPwdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InsertShop:
		return (void*)soap_instantiate_ns2__InsertShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InsertShopResponse:
		return (void*)soap_instantiate_ns2__InsertShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateMessageFromShop:
		return (void*)soap_instantiate_ns2__updateMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateMessageFromShopResponse:
		return (void*)soap_instantiate_ns2__updateMessageFromShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductTypeByProName:
		return (void*)soap_instantiate_ns2__getProductTypeByProName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductTypeByProNameResponse:
		return (void*)soap_instantiate_ns2__getProductTypeByProNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__productType:
		return (void*)soap_instantiate_ns2__productType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClientList:
		return (void*)soap_instantiate_ns2__getClientList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClientListResponse:
		return (void*)soap_instantiate_ns2__getClientListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__purchaseProduct:
		return (void*)soap_instantiate_ns2__purchaseProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__purchaseProductResponse:
		return (void*)soap_instantiate_ns2__purchaseProductResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateMessageFromClient:
		return (void*)soap_instantiate_ns2__updateMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateMessageFromClientResponse:
		return (void*)soap_instantiate_ns2__updateMessageFromClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getUnreadMessageFromClient:
		return (void*)soap_instantiate_ns2__getUnreadMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getUnreadMessageFromClientResponse:
		return (void*)soap_instantiate_ns2__getUnreadMessageFromClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateProductByInfo:
		return (void*)soap_instantiate_ns2__updateProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateProductByInfoResponse:
		return (void*)soap_instantiate_ns2__updateProductByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMessageFromClient:
		return (void*)soap_instantiate_ns2__getMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMessageFromClientResponse:
		return (void*)soap_instantiate_ns2__getMessageFromClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addOrder:
		return (void*)soap_instantiate_ns2__addOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addOrderResponse:
		return (void*)soap_instantiate_ns2__addOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteShopByNameAndPwd:
		return (void*)soap_instantiate_ns2__deleteShopByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse:
		return (void*)soap_instantiate_ns2__deleteShopByNameAndPwdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductList:
		return (void*)soap_instantiate_ns2__getProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductListResponse:
		return (void*)soap_instantiate_ns2__getProductListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderListHistory:
		return (void*)soap_instantiate_ns2__getOrderListHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderListHistoryResponse:
		return (void*)soap_instantiate_ns2__getOrderListHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getReadMessageFromClient:
		return (void*)soap_instantiate_ns2__getReadMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getReadMessageFromClientResponse:
		return (void*)soap_instantiate_ns2__getReadMessageFromClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateHistory:
		return (void*)soap_instantiate_ns2__updateHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__updateHistoryResponse:
		return (void*)soap_instantiate_ns2__updateHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InsertMessage:
		return (void*)soap_instantiate_ns2__InsertMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InsertMessageResponse:
		return (void*)soap_instantiate_ns2__InsertMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getShopLikeList:
		return (void*)soap_instantiate_ns2__getShopLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getShopLikeListResponse:
		return (void*)soap_instantiate_ns2__getShopLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMessageFromShop:
		return (void*)soap_instantiate_ns2__getMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getMessageFromShopResponse:
		return (void*)soap_instantiate_ns2__getMessageFromShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteMessageFromShop:
		return (void*)soap_instantiate_ns2__deleteMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteMessageFromShopResponse:
		return (void*)soap_instantiate_ns2__deleteMessageFromShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderLikeList:
		return (void*)soap_instantiate_ns2__getOrderLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderLikeListResponse:
		return (void*)soap_instantiate_ns2__getOrderLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getUnreadMessageFromShop:
		return (void*)soap_instantiate_ns2__getUnreadMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getUnreadMessageFromShopResponse:
		return (void*)soap_instantiate_ns2__getUnreadMessageFromShopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClientLikeList:
		return (void*)soap_instantiate_ns2__getClientLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClientLikeListResponse:
		return (void*)soap_instantiate_ns2__getClientLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getShopList:
		return (void*)soap_instantiate_ns2__getShopList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getShopListResponse:
		return (void*)soap_instantiate_ns2__getShopListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderListByInfo:
		return (void*)soap_instantiate_ns2__getOrderListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getOrderListByInfoResponse:
		return (void*)soap_instantiate_ns2__getOrderListByInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addProductType:
		return (void*)soap_instantiate_ns2__addProductType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__addProductTypeResponse:
		return (void*)soap_instantiate_ns2__addProductTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteMessageFromClient:
		return (void*)soap_instantiate_ns2__deleteMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteMessageFromClientResponse:
		return (void*)soap_instantiate_ns2__deleteMessageFromClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductLikeList:
		return (void*)soap_instantiate_ns2__getProductLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getProductLikeListResponse:
		return (void*)soap_instantiate_ns2__getProductLikeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClientByNameAndPwd:
		return (void*)soap_instantiate_ns2__getClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__getClientByNameAndPwdResponse:
		return (void*)soap_instantiate_ns2__getClientByNameAndPwdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteShoppingCart:
		return (void*)soap_instantiate_ns2__deleteShoppingCart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__deleteShoppingCartResponse:
		return (void*)soap_instantiate_ns2__deleteShoppingCartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InsertClient:
		return (void*)soap_instantiate_ns2__InsertClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InsertClientResponse:
		return (void*)soap_instantiate_ns2__InsertClientResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__selectProductForUpdate:
		return (void*)soap_instantiate___ns1__selectProductForUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addProduct:
		return (void*)soap_instantiate___ns1__addProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteProductTypeByName:
		return (void*)soap_instantiate___ns1__deleteProductTypeByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOrderList:
		return (void*)soap_instantiate___ns1__getOrderList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getShopByNameAndPwd:
		return (void*)soap_instantiate___ns1__getShopByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateShop:
		return (void*)soap_instantiate___ns1__updateShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProductListByInfo:
		return (void*)soap_instantiate___ns1__getProductListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getReadMessageFromShop:
		return (void*)soap_instantiate___ns1__getReadMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateClient:
		return (void*)soap_instantiate___ns1__updateClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteProductByInfo:
		return (void*)soap_instantiate___ns1__deleteProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteClientByNameAndPwd:
		return (void*)soap_instantiate___ns1__deleteClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsertShop:
		return (void*)soap_instantiate___ns1__InsertShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateMessageFromShop:
		return (void*)soap_instantiate___ns1__updateMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProductTypeByProName:
		return (void*)soap_instantiate___ns1__getProductTypeByProName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClientList:
		return (void*)soap_instantiate___ns1__getClientList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__purchaseProduct:
		return (void*)soap_instantiate___ns1__purchaseProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateMessageFromClient:
		return (void*)soap_instantiate___ns1__updateMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUnreadMessageFromClient:
		return (void*)soap_instantiate___ns1__getUnreadMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateProductByInfo:
		return (void*)soap_instantiate___ns1__updateProductByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMessageFromClient:
		return (void*)soap_instantiate___ns1__getMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addOrder:
		return (void*)soap_instantiate___ns1__addOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteShopByNameAndPwd:
		return (void*)soap_instantiate___ns1__deleteShopByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProductList:
		return (void*)soap_instantiate___ns1__getProductList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOrderListHistory:
		return (void*)soap_instantiate___ns1__getOrderListHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getReadMessageFromClient:
		return (void*)soap_instantiate___ns1__getReadMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateHistory:
		return (void*)soap_instantiate___ns1__updateHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsertMessage:
		return (void*)soap_instantiate___ns1__InsertMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getShopLikeList:
		return (void*)soap_instantiate___ns1__getShopLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMessageFromShop:
		return (void*)soap_instantiate___ns1__getMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteMessageFromShop:
		return (void*)soap_instantiate___ns1__deleteMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOrderLikeList:
		return (void*)soap_instantiate___ns1__getOrderLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUnreadMessageFromShop:
		return (void*)soap_instantiate___ns1__getUnreadMessageFromShop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClientLikeList:
		return (void*)soap_instantiate___ns1__getClientLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getShopList:
		return (void*)soap_instantiate___ns1__getShopList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOrderListByInfo:
		return (void*)soap_instantiate___ns1__getOrderListByInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addProductType:
		return (void*)soap_instantiate___ns1__addProductType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteMessageFromClient:
		return (void*)soap_instantiate___ns1__deleteMessageFromClient(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProductLikeList:
		return (void*)soap_instantiate___ns1__getProductLikeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getClientByNameAndPwd:
		return (void*)soap_instantiate___ns1__getClientByNameAndPwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteShoppingCart:
		return (void*)soap_instantiate___ns1__deleteShoppingCart(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsertClient:
		return (void*)soap_instantiate___ns1__InsertClient(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__shop(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__client:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__client(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__productType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__message:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__product:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__product(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__order:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__order(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns2__selectProductForUpdate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__selectProductForUpdate*>(p->ptr), ns2__selectProductForUpdate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__selectProductForUpdate*>(p->ptr), ns2__selectProductForUpdate);
		break;
	case SOAP_TYPE_ns2__selectProductForUpdateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__selectProductForUpdateResponse*>(p->ptr), ns2__selectProductForUpdateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__selectProductForUpdateResponse*>(p->ptr), ns2__selectProductForUpdateResponse);
		break;
	case SOAP_TYPE_ns2__product:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__product*>(p->ptr), ns2__product);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__product*>(p->ptr), ns2__product);
		break;
	case SOAP_TYPE_ns2__addProduct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__addProduct*>(p->ptr), ns2__addProduct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__addProduct*>(p->ptr), ns2__addProduct);
		break;
	case SOAP_TYPE_ns2__addProductResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__addProductResponse*>(p->ptr), ns2__addProductResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__addProductResponse*>(p->ptr), ns2__addProductResponse);
		break;
	case SOAP_TYPE_ns2__deleteProductTypeByName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteProductTypeByName*>(p->ptr), ns2__deleteProductTypeByName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteProductTypeByName*>(p->ptr), ns2__deleteProductTypeByName);
		break;
	case SOAP_TYPE_ns2__deleteProductTypeByNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteProductTypeByNameResponse*>(p->ptr), ns2__deleteProductTypeByNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteProductTypeByNameResponse*>(p->ptr), ns2__deleteProductTypeByNameResponse);
		break;
	case SOAP_TYPE_ns2__getOrderList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderList*>(p->ptr), ns2__getOrderList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderList*>(p->ptr), ns2__getOrderList);
		break;
	case SOAP_TYPE_ns2__order:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__order*>(p->ptr), ns2__order);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__order*>(p->ptr), ns2__order);
		break;
	case SOAP_TYPE_ns2__getOrderListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderListResponse*>(p->ptr), ns2__getOrderListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderListResponse*>(p->ptr), ns2__getOrderListResponse);
		break;
	case SOAP_TYPE_ns2__getShopByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getShopByNameAndPwd*>(p->ptr), ns2__getShopByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getShopByNameAndPwd*>(p->ptr), ns2__getShopByNameAndPwd);
		break;
	case SOAP_TYPE_ns2__getShopByNameAndPwdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getShopByNameAndPwdResponse*>(p->ptr), ns2__getShopByNameAndPwdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getShopByNameAndPwdResponse*>(p->ptr), ns2__getShopByNameAndPwdResponse);
		break;
	case SOAP_TYPE_ns2__shop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__shop*>(p->ptr), ns2__shop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__shop*>(p->ptr), ns2__shop);
		break;
	case SOAP_TYPE_ns2__updateShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateShop*>(p->ptr), ns2__updateShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateShop*>(p->ptr), ns2__updateShop);
		break;
	case SOAP_TYPE_ns2__updateShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateShopResponse*>(p->ptr), ns2__updateShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateShopResponse*>(p->ptr), ns2__updateShopResponse);
		break;
	case SOAP_TYPE_ns2__getProductListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductListByInfo*>(p->ptr), ns2__getProductListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductListByInfo*>(p->ptr), ns2__getProductListByInfo);
		break;
	case SOAP_TYPE_ns2__getProductListByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductListByInfoResponse*>(p->ptr), ns2__getProductListByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductListByInfoResponse*>(p->ptr), ns2__getProductListByInfoResponse);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getReadMessageFromShop*>(p->ptr), ns2__getReadMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getReadMessageFromShop*>(p->ptr), ns2__getReadMessageFromShop);
		break;
	case SOAP_TYPE_ns2__client:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__client*>(p->ptr), ns2__client);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__client*>(p->ptr), ns2__client);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getReadMessageFromShopResponse*>(p->ptr), ns2__getReadMessageFromShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getReadMessageFromShopResponse*>(p->ptr), ns2__getReadMessageFromShopResponse);
		break;
	case SOAP_TYPE_ns2__message:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__message*>(p->ptr), ns2__message);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__message*>(p->ptr), ns2__message);
		break;
	case SOAP_TYPE_ns2__updateClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateClient*>(p->ptr), ns2__updateClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateClient*>(p->ptr), ns2__updateClient);
		break;
	case SOAP_TYPE_ns2__updateClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateClientResponse*>(p->ptr), ns2__updateClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateClientResponse*>(p->ptr), ns2__updateClientResponse);
		break;
	case SOAP_TYPE_ns2__deleteProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteProductByInfo*>(p->ptr), ns2__deleteProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteProductByInfo*>(p->ptr), ns2__deleteProductByInfo);
		break;
	case SOAP_TYPE_ns2__deleteProductByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteProductByInfoResponse*>(p->ptr), ns2__deleteProductByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteProductByInfoResponse*>(p->ptr), ns2__deleteProductByInfoResponse);
		break;
	case SOAP_TYPE_ns2__deleteClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteClientByNameAndPwd*>(p->ptr), ns2__deleteClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteClientByNameAndPwd*>(p->ptr), ns2__deleteClientByNameAndPwd);
		break;
	case SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteClientByNameAndPwdResponse*>(p->ptr), ns2__deleteClientByNameAndPwdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteClientByNameAndPwdResponse*>(p->ptr), ns2__deleteClientByNameAndPwdResponse);
		break;
	case SOAP_TYPE_ns2__InsertShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__InsertShop*>(p->ptr), ns2__InsertShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__InsertShop*>(p->ptr), ns2__InsertShop);
		break;
	case SOAP_TYPE_ns2__InsertShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__InsertShopResponse*>(p->ptr), ns2__InsertShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__InsertShopResponse*>(p->ptr), ns2__InsertShopResponse);
		break;
	case SOAP_TYPE_ns2__updateMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateMessageFromShop*>(p->ptr), ns2__updateMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateMessageFromShop*>(p->ptr), ns2__updateMessageFromShop);
		break;
	case SOAP_TYPE_ns2__updateMessageFromShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateMessageFromShopResponse*>(p->ptr), ns2__updateMessageFromShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateMessageFromShopResponse*>(p->ptr), ns2__updateMessageFromShopResponse);
		break;
	case SOAP_TYPE_ns2__getProductTypeByProName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductTypeByProName*>(p->ptr), ns2__getProductTypeByProName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductTypeByProName*>(p->ptr), ns2__getProductTypeByProName);
		break;
	case SOAP_TYPE_ns2__getProductTypeByProNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductTypeByProNameResponse*>(p->ptr), ns2__getProductTypeByProNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductTypeByProNameResponse*>(p->ptr), ns2__getProductTypeByProNameResponse);
		break;
	case SOAP_TYPE_ns2__productType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__productType*>(p->ptr), ns2__productType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__productType*>(p->ptr), ns2__productType);
		break;
	case SOAP_TYPE_ns2__getClientList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getClientList*>(p->ptr), ns2__getClientList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getClientList*>(p->ptr), ns2__getClientList);
		break;
	case SOAP_TYPE_ns2__getClientListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getClientListResponse*>(p->ptr), ns2__getClientListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getClientListResponse*>(p->ptr), ns2__getClientListResponse);
		break;
	case SOAP_TYPE_ns2__purchaseProduct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__purchaseProduct*>(p->ptr), ns2__purchaseProduct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__purchaseProduct*>(p->ptr), ns2__purchaseProduct);
		break;
	case SOAP_TYPE_ns2__purchaseProductResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__purchaseProductResponse*>(p->ptr), ns2__purchaseProductResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__purchaseProductResponse*>(p->ptr), ns2__purchaseProductResponse);
		break;
	case SOAP_TYPE_ns2__updateMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateMessageFromClient*>(p->ptr), ns2__updateMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateMessageFromClient*>(p->ptr), ns2__updateMessageFromClient);
		break;
	case SOAP_TYPE_ns2__updateMessageFromClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateMessageFromClientResponse*>(p->ptr), ns2__updateMessageFromClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateMessageFromClientResponse*>(p->ptr), ns2__updateMessageFromClientResponse);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getUnreadMessageFromClient*>(p->ptr), ns2__getUnreadMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getUnreadMessageFromClient*>(p->ptr), ns2__getUnreadMessageFromClient);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getUnreadMessageFromClientResponse*>(p->ptr), ns2__getUnreadMessageFromClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getUnreadMessageFromClientResponse*>(p->ptr), ns2__getUnreadMessageFromClientResponse);
		break;
	case SOAP_TYPE_ns2__updateProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateProductByInfo*>(p->ptr), ns2__updateProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateProductByInfo*>(p->ptr), ns2__updateProductByInfo);
		break;
	case SOAP_TYPE_ns2__updateProductByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateProductByInfoResponse*>(p->ptr), ns2__updateProductByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateProductByInfoResponse*>(p->ptr), ns2__updateProductByInfoResponse);
		break;
	case SOAP_TYPE_ns2__getMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getMessageFromClient*>(p->ptr), ns2__getMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getMessageFromClient*>(p->ptr), ns2__getMessageFromClient);
		break;
	case SOAP_TYPE_ns2__getMessageFromClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getMessageFromClientResponse*>(p->ptr), ns2__getMessageFromClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getMessageFromClientResponse*>(p->ptr), ns2__getMessageFromClientResponse);
		break;
	case SOAP_TYPE_ns2__addOrder:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__addOrder*>(p->ptr), ns2__addOrder);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__addOrder*>(p->ptr), ns2__addOrder);
		break;
	case SOAP_TYPE_ns2__addOrderResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__addOrderResponse*>(p->ptr), ns2__addOrderResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__addOrderResponse*>(p->ptr), ns2__addOrderResponse);
		break;
	case SOAP_TYPE_ns2__deleteShopByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteShopByNameAndPwd*>(p->ptr), ns2__deleteShopByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteShopByNameAndPwd*>(p->ptr), ns2__deleteShopByNameAndPwd);
		break;
	case SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteShopByNameAndPwdResponse*>(p->ptr), ns2__deleteShopByNameAndPwdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteShopByNameAndPwdResponse*>(p->ptr), ns2__deleteShopByNameAndPwdResponse);
		break;
	case SOAP_TYPE_ns2__getProductList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductList*>(p->ptr), ns2__getProductList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductList*>(p->ptr), ns2__getProductList);
		break;
	case SOAP_TYPE_ns2__getProductListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductListResponse*>(p->ptr), ns2__getProductListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductListResponse*>(p->ptr), ns2__getProductListResponse);
		break;
	case SOAP_TYPE_ns2__getOrderListHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderListHistory*>(p->ptr), ns2__getOrderListHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderListHistory*>(p->ptr), ns2__getOrderListHistory);
		break;
	case SOAP_TYPE_ns2__getOrderListHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderListHistoryResponse*>(p->ptr), ns2__getOrderListHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderListHistoryResponse*>(p->ptr), ns2__getOrderListHistoryResponse);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getReadMessageFromClient*>(p->ptr), ns2__getReadMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getReadMessageFromClient*>(p->ptr), ns2__getReadMessageFromClient);
		break;
	case SOAP_TYPE_ns2__getReadMessageFromClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getReadMessageFromClientResponse*>(p->ptr), ns2__getReadMessageFromClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getReadMessageFromClientResponse*>(p->ptr), ns2__getReadMessageFromClientResponse);
		break;
	case SOAP_TYPE_ns2__updateHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateHistory*>(p->ptr), ns2__updateHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateHistory*>(p->ptr), ns2__updateHistory);
		break;
	case SOAP_TYPE_ns2__updateHistoryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__updateHistoryResponse*>(p->ptr), ns2__updateHistoryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__updateHistoryResponse*>(p->ptr), ns2__updateHistoryResponse);
		break;
	case SOAP_TYPE_ns2__InsertMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__InsertMessage*>(p->ptr), ns2__InsertMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__InsertMessage*>(p->ptr), ns2__InsertMessage);
		break;
	case SOAP_TYPE_ns2__InsertMessageResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__InsertMessageResponse*>(p->ptr), ns2__InsertMessageResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__InsertMessageResponse*>(p->ptr), ns2__InsertMessageResponse);
		break;
	case SOAP_TYPE_ns2__getShopLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getShopLikeList*>(p->ptr), ns2__getShopLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getShopLikeList*>(p->ptr), ns2__getShopLikeList);
		break;
	case SOAP_TYPE_ns2__getShopLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getShopLikeListResponse*>(p->ptr), ns2__getShopLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getShopLikeListResponse*>(p->ptr), ns2__getShopLikeListResponse);
		break;
	case SOAP_TYPE_ns2__getMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getMessageFromShop*>(p->ptr), ns2__getMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getMessageFromShop*>(p->ptr), ns2__getMessageFromShop);
		break;
	case SOAP_TYPE_ns2__getMessageFromShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getMessageFromShopResponse*>(p->ptr), ns2__getMessageFromShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getMessageFromShopResponse*>(p->ptr), ns2__getMessageFromShopResponse);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteMessageFromShop*>(p->ptr), ns2__deleteMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteMessageFromShop*>(p->ptr), ns2__deleteMessageFromShop);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteMessageFromShopResponse*>(p->ptr), ns2__deleteMessageFromShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteMessageFromShopResponse*>(p->ptr), ns2__deleteMessageFromShopResponse);
		break;
	case SOAP_TYPE_ns2__getOrderLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderLikeList*>(p->ptr), ns2__getOrderLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderLikeList*>(p->ptr), ns2__getOrderLikeList);
		break;
	case SOAP_TYPE_ns2__getOrderLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderLikeListResponse*>(p->ptr), ns2__getOrderLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderLikeListResponse*>(p->ptr), ns2__getOrderLikeListResponse);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getUnreadMessageFromShop*>(p->ptr), ns2__getUnreadMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getUnreadMessageFromShop*>(p->ptr), ns2__getUnreadMessageFromShop);
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromShopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getUnreadMessageFromShopResponse*>(p->ptr), ns2__getUnreadMessageFromShopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getUnreadMessageFromShopResponse*>(p->ptr), ns2__getUnreadMessageFromShopResponse);
		break;
	case SOAP_TYPE_ns2__getClientLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getClientLikeList*>(p->ptr), ns2__getClientLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getClientLikeList*>(p->ptr), ns2__getClientLikeList);
		break;
	case SOAP_TYPE_ns2__getClientLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getClientLikeListResponse*>(p->ptr), ns2__getClientLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getClientLikeListResponse*>(p->ptr), ns2__getClientLikeListResponse);
		break;
	case SOAP_TYPE_ns2__getShopList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getShopList*>(p->ptr), ns2__getShopList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getShopList*>(p->ptr), ns2__getShopList);
		break;
	case SOAP_TYPE_ns2__getShopListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getShopListResponse*>(p->ptr), ns2__getShopListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getShopListResponse*>(p->ptr), ns2__getShopListResponse);
		break;
	case SOAP_TYPE_ns2__getOrderListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderListByInfo*>(p->ptr), ns2__getOrderListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderListByInfo*>(p->ptr), ns2__getOrderListByInfo);
		break;
	case SOAP_TYPE_ns2__getOrderListByInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getOrderListByInfoResponse*>(p->ptr), ns2__getOrderListByInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getOrderListByInfoResponse*>(p->ptr), ns2__getOrderListByInfoResponse);
		break;
	case SOAP_TYPE_ns2__addProductType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__addProductType*>(p->ptr), ns2__addProductType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__addProductType*>(p->ptr), ns2__addProductType);
		break;
	case SOAP_TYPE_ns2__addProductTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__addProductTypeResponse*>(p->ptr), ns2__addProductTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__addProductTypeResponse*>(p->ptr), ns2__addProductTypeResponse);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteMessageFromClient*>(p->ptr), ns2__deleteMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteMessageFromClient*>(p->ptr), ns2__deleteMessageFromClient);
		break;
	case SOAP_TYPE_ns2__deleteMessageFromClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteMessageFromClientResponse*>(p->ptr), ns2__deleteMessageFromClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteMessageFromClientResponse*>(p->ptr), ns2__deleteMessageFromClientResponse);
		break;
	case SOAP_TYPE_ns2__getProductLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductLikeList*>(p->ptr), ns2__getProductLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductLikeList*>(p->ptr), ns2__getProductLikeList);
		break;
	case SOAP_TYPE_ns2__getProductLikeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getProductLikeListResponse*>(p->ptr), ns2__getProductLikeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getProductLikeListResponse*>(p->ptr), ns2__getProductLikeListResponse);
		break;
	case SOAP_TYPE_ns2__getClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getClientByNameAndPwd*>(p->ptr), ns2__getClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getClientByNameAndPwd*>(p->ptr), ns2__getClientByNameAndPwd);
		break;
	case SOAP_TYPE_ns2__getClientByNameAndPwdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__getClientByNameAndPwdResponse*>(p->ptr), ns2__getClientByNameAndPwdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__getClientByNameAndPwdResponse*>(p->ptr), ns2__getClientByNameAndPwdResponse);
		break;
	case SOAP_TYPE_ns2__deleteShoppingCart:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteShoppingCart*>(p->ptr), ns2__deleteShoppingCart);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteShoppingCart*>(p->ptr), ns2__deleteShoppingCart);
		break;
	case SOAP_TYPE_ns2__deleteShoppingCartResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__deleteShoppingCartResponse*>(p->ptr), ns2__deleteShoppingCartResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__deleteShoppingCartResponse*>(p->ptr), ns2__deleteShoppingCartResponse);
		break;
	case SOAP_TYPE_ns2__InsertClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__InsertClient*>(p->ptr), ns2__InsertClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__InsertClient*>(p->ptr), ns2__InsertClient);
		break;
	case SOAP_TYPE_ns2__InsertClientResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__InsertClientResponse*>(p->ptr), ns2__InsertClientResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__InsertClientResponse*>(p->ptr), ns2__InsertClientResponse);
		break;
	case SOAP_TYPE___ns1__selectProductForUpdate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__selectProductForUpdate*>(p->ptr), struct __ns1__selectProductForUpdate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__selectProductForUpdate*>(p->ptr), struct __ns1__selectProductForUpdate);
		break;
	case SOAP_TYPE___ns1__addProduct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__addProduct*>(p->ptr), struct __ns1__addProduct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__addProduct*>(p->ptr), struct __ns1__addProduct);
		break;
	case SOAP_TYPE___ns1__deleteProductTypeByName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteProductTypeByName*>(p->ptr), struct __ns1__deleteProductTypeByName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteProductTypeByName*>(p->ptr), struct __ns1__deleteProductTypeByName);
		break;
	case SOAP_TYPE___ns1__getOrderList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getOrderList*>(p->ptr), struct __ns1__getOrderList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getOrderList*>(p->ptr), struct __ns1__getOrderList);
		break;
	case SOAP_TYPE___ns1__getShopByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getShopByNameAndPwd*>(p->ptr), struct __ns1__getShopByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getShopByNameAndPwd*>(p->ptr), struct __ns1__getShopByNameAndPwd);
		break;
	case SOAP_TYPE___ns1__updateShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__updateShop*>(p->ptr), struct __ns1__updateShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__updateShop*>(p->ptr), struct __ns1__updateShop);
		break;
	case SOAP_TYPE___ns1__getProductListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getProductListByInfo*>(p->ptr), struct __ns1__getProductListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getProductListByInfo*>(p->ptr), struct __ns1__getProductListByInfo);
		break;
	case SOAP_TYPE___ns1__getReadMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getReadMessageFromShop*>(p->ptr), struct __ns1__getReadMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getReadMessageFromShop*>(p->ptr), struct __ns1__getReadMessageFromShop);
		break;
	case SOAP_TYPE___ns1__updateClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__updateClient*>(p->ptr), struct __ns1__updateClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__updateClient*>(p->ptr), struct __ns1__updateClient);
		break;
	case SOAP_TYPE___ns1__deleteProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteProductByInfo*>(p->ptr), struct __ns1__deleteProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteProductByInfo*>(p->ptr), struct __ns1__deleteProductByInfo);
		break;
	case SOAP_TYPE___ns1__deleteClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteClientByNameAndPwd*>(p->ptr), struct __ns1__deleteClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteClientByNameAndPwd*>(p->ptr), struct __ns1__deleteClientByNameAndPwd);
		break;
	case SOAP_TYPE___ns1__InsertShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InsertShop*>(p->ptr), struct __ns1__InsertShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InsertShop*>(p->ptr), struct __ns1__InsertShop);
		break;
	case SOAP_TYPE___ns1__updateMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__updateMessageFromShop*>(p->ptr), struct __ns1__updateMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__updateMessageFromShop*>(p->ptr), struct __ns1__updateMessageFromShop);
		break;
	case SOAP_TYPE___ns1__getProductTypeByProName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getProductTypeByProName*>(p->ptr), struct __ns1__getProductTypeByProName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getProductTypeByProName*>(p->ptr), struct __ns1__getProductTypeByProName);
		break;
	case SOAP_TYPE___ns1__getClientList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getClientList*>(p->ptr), struct __ns1__getClientList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getClientList*>(p->ptr), struct __ns1__getClientList);
		break;
	case SOAP_TYPE___ns1__purchaseProduct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__purchaseProduct*>(p->ptr), struct __ns1__purchaseProduct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__purchaseProduct*>(p->ptr), struct __ns1__purchaseProduct);
		break;
	case SOAP_TYPE___ns1__updateMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__updateMessageFromClient*>(p->ptr), struct __ns1__updateMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__updateMessageFromClient*>(p->ptr), struct __ns1__updateMessageFromClient);
		break;
	case SOAP_TYPE___ns1__getUnreadMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getUnreadMessageFromClient*>(p->ptr), struct __ns1__getUnreadMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getUnreadMessageFromClient*>(p->ptr), struct __ns1__getUnreadMessageFromClient);
		break;
	case SOAP_TYPE___ns1__updateProductByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__updateProductByInfo*>(p->ptr), struct __ns1__updateProductByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__updateProductByInfo*>(p->ptr), struct __ns1__updateProductByInfo);
		break;
	case SOAP_TYPE___ns1__getMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getMessageFromClient*>(p->ptr), struct __ns1__getMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getMessageFromClient*>(p->ptr), struct __ns1__getMessageFromClient);
		break;
	case SOAP_TYPE___ns1__addOrder:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__addOrder*>(p->ptr), struct __ns1__addOrder);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__addOrder*>(p->ptr), struct __ns1__addOrder);
		break;
	case SOAP_TYPE___ns1__deleteShopByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteShopByNameAndPwd*>(p->ptr), struct __ns1__deleteShopByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteShopByNameAndPwd*>(p->ptr), struct __ns1__deleteShopByNameAndPwd);
		break;
	case SOAP_TYPE___ns1__getProductList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getProductList*>(p->ptr), struct __ns1__getProductList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getProductList*>(p->ptr), struct __ns1__getProductList);
		break;
	case SOAP_TYPE___ns1__getOrderListHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getOrderListHistory*>(p->ptr), struct __ns1__getOrderListHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getOrderListHistory*>(p->ptr), struct __ns1__getOrderListHistory);
		break;
	case SOAP_TYPE___ns1__getReadMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getReadMessageFromClient*>(p->ptr), struct __ns1__getReadMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getReadMessageFromClient*>(p->ptr), struct __ns1__getReadMessageFromClient);
		break;
	case SOAP_TYPE___ns1__updateHistory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__updateHistory*>(p->ptr), struct __ns1__updateHistory);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__updateHistory*>(p->ptr), struct __ns1__updateHistory);
		break;
	case SOAP_TYPE___ns1__InsertMessage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InsertMessage*>(p->ptr), struct __ns1__InsertMessage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InsertMessage*>(p->ptr), struct __ns1__InsertMessage);
		break;
	case SOAP_TYPE___ns1__getShopLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getShopLikeList*>(p->ptr), struct __ns1__getShopLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getShopLikeList*>(p->ptr), struct __ns1__getShopLikeList);
		break;
	case SOAP_TYPE___ns1__getMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getMessageFromShop*>(p->ptr), struct __ns1__getMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getMessageFromShop*>(p->ptr), struct __ns1__getMessageFromShop);
		break;
	case SOAP_TYPE___ns1__deleteMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteMessageFromShop*>(p->ptr), struct __ns1__deleteMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteMessageFromShop*>(p->ptr), struct __ns1__deleteMessageFromShop);
		break;
	case SOAP_TYPE___ns1__getOrderLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getOrderLikeList*>(p->ptr), struct __ns1__getOrderLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getOrderLikeList*>(p->ptr), struct __ns1__getOrderLikeList);
		break;
	case SOAP_TYPE___ns1__getUnreadMessageFromShop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getUnreadMessageFromShop*>(p->ptr), struct __ns1__getUnreadMessageFromShop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getUnreadMessageFromShop*>(p->ptr), struct __ns1__getUnreadMessageFromShop);
		break;
	case SOAP_TYPE___ns1__getClientLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getClientLikeList*>(p->ptr), struct __ns1__getClientLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getClientLikeList*>(p->ptr), struct __ns1__getClientLikeList);
		break;
	case SOAP_TYPE___ns1__getShopList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getShopList*>(p->ptr), struct __ns1__getShopList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getShopList*>(p->ptr), struct __ns1__getShopList);
		break;
	case SOAP_TYPE___ns1__getOrderListByInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getOrderListByInfo*>(p->ptr), struct __ns1__getOrderListByInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getOrderListByInfo*>(p->ptr), struct __ns1__getOrderListByInfo);
		break;
	case SOAP_TYPE___ns1__addProductType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__addProductType*>(p->ptr), struct __ns1__addProductType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__addProductType*>(p->ptr), struct __ns1__addProductType);
		break;
	case SOAP_TYPE___ns1__deleteMessageFromClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteMessageFromClient*>(p->ptr), struct __ns1__deleteMessageFromClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteMessageFromClient*>(p->ptr), struct __ns1__deleteMessageFromClient);
		break;
	case SOAP_TYPE___ns1__getProductLikeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getProductLikeList*>(p->ptr), struct __ns1__getProductLikeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getProductLikeList*>(p->ptr), struct __ns1__getProductLikeList);
		break;
	case SOAP_TYPE___ns1__getClientByNameAndPwd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__getClientByNameAndPwd*>(p->ptr), struct __ns1__getClientByNameAndPwd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__getClientByNameAndPwd*>(p->ptr), struct __ns1__getClientByNameAndPwd);
		break;
	case SOAP_TYPE___ns1__deleteShoppingCart:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__deleteShoppingCart*>(p->ptr), struct __ns1__deleteShoppingCart);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__deleteShoppingCart*>(p->ptr), struct __ns1__deleteShoppingCart);
		break;
	case SOAP_TYPE___ns1__InsertClient:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__InsertClient*>(p->ptr), struct __ns1__InsertClient);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__InsertClient*>(p->ptr), struct __ns1__InsertClient);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__shop *> *>(p->ptr), std::vector<ns2__shop *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__shop *> *>(p->ptr), std::vector<ns2__shop *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__client:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__client *> *>(p->ptr), std::vector<ns2__client *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__client *> *>(p->ptr), std::vector<ns2__client *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__productType *> *>(p->ptr), std::vector<ns2__productType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__productType *> *>(p->ptr), std::vector<ns2__productType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__message:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__message *> *>(p->ptr), std::vector<ns2__message *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__message *> *>(p->ptr), std::vector<ns2__message *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__product:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__product *> *>(p->ptr), std::vector<ns2__product *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__product *> *>(p->ptr), std::vector<ns2__product *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__order:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns2__order *> *>(p->ptr), std::vector<ns2__order *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns2__order *> *>(p->ptr), std::vector<ns2__order *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop:
		if (t == SOAP_TYPE_ns2__shop || soap_fbase(t, SOAP_TYPE_ns2__shop))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__shop *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__shop *> *)p)[index] = *(ns2__shop **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__client:
		if (t == SOAP_TYPE_ns2__client || soap_fbase(t, SOAP_TYPE_ns2__client))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__client *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__client *> *)p)[index] = *(ns2__client **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType:
		if (t == SOAP_TYPE_ns2__productType || soap_fbase(t, SOAP_TYPE_ns2__productType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__productType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__productType *> *)p)[index] = *(ns2__productType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__message:
		if (t == SOAP_TYPE_ns2__message || soap_fbase(t, SOAP_TYPE_ns2__message))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__message *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__message *> *)p)[index] = *(ns2__message **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__product:
		if (t == SOAP_TYPE_ns2__product || soap_fbase(t, SOAP_TYPE_ns2__product))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__product *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__product *> *)p)[index] = *(ns2__product **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__order:
		if (t == SOAP_TYPE_ns2__order || soap_fbase(t, SOAP_TYPE_ns2__order))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__order *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__order *> *)p)[index] = *(ns2__order **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns2__selectProductForUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__selectProductForUpdate type=%d location=%p object=%p\n", t, p, q));
		*(ns2__selectProductForUpdate*)p = *(ns2__selectProductForUpdate*)q;
		break;
	case SOAP_TYPE_ns2__selectProductForUpdateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__selectProductForUpdateResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__selectProductForUpdateResponse*)p = *(ns2__selectProductForUpdateResponse*)q;
		break;
	case SOAP_TYPE_ns2__product:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__product type=%d location=%p object=%p\n", t, p, q));
		*(ns2__product*)p = *(ns2__product*)q;
		break;
	case SOAP_TYPE_ns2__addProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__addProduct type=%d location=%p object=%p\n", t, p, q));
		*(ns2__addProduct*)p = *(ns2__addProduct*)q;
		break;
	case SOAP_TYPE_ns2__addProductResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__addProductResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__addProductResponse*)p = *(ns2__addProductResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteProductTypeByName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteProductTypeByName type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteProductTypeByName*)p = *(ns2__deleteProductTypeByName*)q;
		break;
	case SOAP_TYPE_ns2__deleteProductTypeByNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteProductTypeByNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteProductTypeByNameResponse*)p = *(ns2__deleteProductTypeByNameResponse*)q;
		break;
	case SOAP_TYPE_ns2__getOrderList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderList*)p = *(ns2__getOrderList*)q;
		break;
	case SOAP_TYPE_ns2__order:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__order type=%d location=%p object=%p\n", t, p, q));
		*(ns2__order*)p = *(ns2__order*)q;
		break;
	case SOAP_TYPE_ns2__getOrderListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderListResponse*)p = *(ns2__getOrderListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getShopByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getShopByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getShopByNameAndPwd*)p = *(ns2__getShopByNameAndPwd*)q;
		break;
	case SOAP_TYPE_ns2__getShopByNameAndPwdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getShopByNameAndPwdResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getShopByNameAndPwdResponse*)p = *(ns2__getShopByNameAndPwdResponse*)q;
		break;
	case SOAP_TYPE_ns2__shop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__shop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__shop*)p = *(ns2__shop*)q;
		break;
	case SOAP_TYPE_ns2__updateShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateShop*)p = *(ns2__updateShop*)q;
		break;
	case SOAP_TYPE_ns2__updateShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateShopResponse*)p = *(ns2__updateShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__getProductListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductListByInfo*)p = *(ns2__getProductListByInfo*)q;
		break;
	case SOAP_TYPE_ns2__getProductListByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductListByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductListByInfoResponse*)p = *(ns2__getProductListByInfoResponse*)q;
		break;
	case SOAP_TYPE_ns2__getReadMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getReadMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getReadMessageFromShop*)p = *(ns2__getReadMessageFromShop*)q;
		break;
	case SOAP_TYPE_ns2__client:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__client type=%d location=%p object=%p\n", t, p, q));
		*(ns2__client*)p = *(ns2__client*)q;
		break;
	case SOAP_TYPE_ns2__getReadMessageFromShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getReadMessageFromShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getReadMessageFromShopResponse*)p = *(ns2__getReadMessageFromShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__message type=%d location=%p object=%p\n", t, p, q));
		*(ns2__message*)p = *(ns2__message*)q;
		break;
	case SOAP_TYPE_ns2__updateClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateClient*)p = *(ns2__updateClient*)q;
		break;
	case SOAP_TYPE_ns2__updateClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateClientResponse*)p = *(ns2__updateClientResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteProductByInfo*)p = *(ns2__deleteProductByInfo*)q;
		break;
	case SOAP_TYPE_ns2__deleteProductByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteProductByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteProductByInfoResponse*)p = *(ns2__deleteProductByInfoResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteClientByNameAndPwd*)p = *(ns2__deleteClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteClientByNameAndPwdResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteClientByNameAndPwdResponse*)p = *(ns2__deleteClientByNameAndPwdResponse*)q;
		break;
	case SOAP_TYPE_ns2__InsertShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InsertShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InsertShop*)p = *(ns2__InsertShop*)q;
		break;
	case SOAP_TYPE_ns2__InsertShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InsertShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InsertShopResponse*)p = *(ns2__InsertShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__updateMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateMessageFromShop*)p = *(ns2__updateMessageFromShop*)q;
		break;
	case SOAP_TYPE_ns2__updateMessageFromShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateMessageFromShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateMessageFromShopResponse*)p = *(ns2__updateMessageFromShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__getProductTypeByProName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductTypeByProName type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductTypeByProName*)p = *(ns2__getProductTypeByProName*)q;
		break;
	case SOAP_TYPE_ns2__getProductTypeByProNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductTypeByProNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductTypeByProNameResponse*)p = *(ns2__getProductTypeByProNameResponse*)q;
		break;
	case SOAP_TYPE_ns2__productType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__productType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__productType*)p = *(ns2__productType*)q;
		break;
	case SOAP_TYPE_ns2__getClientList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getClientList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getClientList*)p = *(ns2__getClientList*)q;
		break;
	case SOAP_TYPE_ns2__getClientListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getClientListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getClientListResponse*)p = *(ns2__getClientListResponse*)q;
		break;
	case SOAP_TYPE_ns2__purchaseProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__purchaseProduct type=%d location=%p object=%p\n", t, p, q));
		*(ns2__purchaseProduct*)p = *(ns2__purchaseProduct*)q;
		break;
	case SOAP_TYPE_ns2__purchaseProductResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__purchaseProductResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__purchaseProductResponse*)p = *(ns2__purchaseProductResponse*)q;
		break;
	case SOAP_TYPE_ns2__updateMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateMessageFromClient*)p = *(ns2__updateMessageFromClient*)q;
		break;
	case SOAP_TYPE_ns2__updateMessageFromClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateMessageFromClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateMessageFromClientResponse*)p = *(ns2__updateMessageFromClientResponse*)q;
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getUnreadMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getUnreadMessageFromClient*)p = *(ns2__getUnreadMessageFromClient*)q;
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getUnreadMessageFromClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getUnreadMessageFromClientResponse*)p = *(ns2__getUnreadMessageFromClientResponse*)q;
		break;
	case SOAP_TYPE_ns2__updateProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateProductByInfo*)p = *(ns2__updateProductByInfo*)q;
		break;
	case SOAP_TYPE_ns2__updateProductByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateProductByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateProductByInfoResponse*)p = *(ns2__updateProductByInfoResponse*)q;
		break;
	case SOAP_TYPE_ns2__getMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getMessageFromClient*)p = *(ns2__getMessageFromClient*)q;
		break;
	case SOAP_TYPE_ns2__getMessageFromClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getMessageFromClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getMessageFromClientResponse*)p = *(ns2__getMessageFromClientResponse*)q;
		break;
	case SOAP_TYPE_ns2__addOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__addOrder type=%d location=%p object=%p\n", t, p, q));
		*(ns2__addOrder*)p = *(ns2__addOrder*)q;
		break;
	case SOAP_TYPE_ns2__addOrderResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__addOrderResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__addOrderResponse*)p = *(ns2__addOrderResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteShopByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteShopByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteShopByNameAndPwd*)p = *(ns2__deleteShopByNameAndPwd*)q;
		break;
	case SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteShopByNameAndPwdResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteShopByNameAndPwdResponse*)p = *(ns2__deleteShopByNameAndPwdResponse*)q;
		break;
	case SOAP_TYPE_ns2__getProductList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductList*)p = *(ns2__getProductList*)q;
		break;
	case SOAP_TYPE_ns2__getProductListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductListResponse*)p = *(ns2__getProductListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getOrderListHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderListHistory type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderListHistory*)p = *(ns2__getOrderListHistory*)q;
		break;
	case SOAP_TYPE_ns2__getOrderListHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderListHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderListHistoryResponse*)p = *(ns2__getOrderListHistoryResponse*)q;
		break;
	case SOAP_TYPE_ns2__getReadMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getReadMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getReadMessageFromClient*)p = *(ns2__getReadMessageFromClient*)q;
		break;
	case SOAP_TYPE_ns2__getReadMessageFromClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getReadMessageFromClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getReadMessageFromClientResponse*)p = *(ns2__getReadMessageFromClientResponse*)q;
		break;
	case SOAP_TYPE_ns2__updateHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateHistory type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateHistory*)p = *(ns2__updateHistory*)q;
		break;
	case SOAP_TYPE_ns2__updateHistoryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__updateHistoryResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__updateHistoryResponse*)p = *(ns2__updateHistoryResponse*)q;
		break;
	case SOAP_TYPE_ns2__InsertMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InsertMessage type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InsertMessage*)p = *(ns2__InsertMessage*)q;
		break;
	case SOAP_TYPE_ns2__InsertMessageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InsertMessageResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InsertMessageResponse*)p = *(ns2__InsertMessageResponse*)q;
		break;
	case SOAP_TYPE_ns2__getShopLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getShopLikeList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getShopLikeList*)p = *(ns2__getShopLikeList*)q;
		break;
	case SOAP_TYPE_ns2__getShopLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getShopLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getShopLikeListResponse*)p = *(ns2__getShopLikeListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getMessageFromShop*)p = *(ns2__getMessageFromShop*)q;
		break;
	case SOAP_TYPE_ns2__getMessageFromShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getMessageFromShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getMessageFromShopResponse*)p = *(ns2__getMessageFromShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteMessageFromShop*)p = *(ns2__deleteMessageFromShop*)q;
		break;
	case SOAP_TYPE_ns2__deleteMessageFromShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteMessageFromShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteMessageFromShopResponse*)p = *(ns2__deleteMessageFromShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__getOrderLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderLikeList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderLikeList*)p = *(ns2__getOrderLikeList*)q;
		break;
	case SOAP_TYPE_ns2__getOrderLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderLikeListResponse*)p = *(ns2__getOrderLikeListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getUnreadMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getUnreadMessageFromShop*)p = *(ns2__getUnreadMessageFromShop*)q;
		break;
	case SOAP_TYPE_ns2__getUnreadMessageFromShopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getUnreadMessageFromShopResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getUnreadMessageFromShopResponse*)p = *(ns2__getUnreadMessageFromShopResponse*)q;
		break;
	case SOAP_TYPE_ns2__getClientLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getClientLikeList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getClientLikeList*)p = *(ns2__getClientLikeList*)q;
		break;
	case SOAP_TYPE_ns2__getClientLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getClientLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getClientLikeListResponse*)p = *(ns2__getClientLikeListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getShopList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getShopList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getShopList*)p = *(ns2__getShopList*)q;
		break;
	case SOAP_TYPE_ns2__getShopListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getShopListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getShopListResponse*)p = *(ns2__getShopListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getOrderListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderListByInfo*)p = *(ns2__getOrderListByInfo*)q;
		break;
	case SOAP_TYPE_ns2__getOrderListByInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getOrderListByInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getOrderListByInfoResponse*)p = *(ns2__getOrderListByInfoResponse*)q;
		break;
	case SOAP_TYPE_ns2__addProductType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__addProductType type=%d location=%p object=%p\n", t, p, q));
		*(ns2__addProductType*)p = *(ns2__addProductType*)q;
		break;
	case SOAP_TYPE_ns2__addProductTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__addProductTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__addProductTypeResponse*)p = *(ns2__addProductTypeResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteMessageFromClient*)p = *(ns2__deleteMessageFromClient*)q;
		break;
	case SOAP_TYPE_ns2__deleteMessageFromClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteMessageFromClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteMessageFromClientResponse*)p = *(ns2__deleteMessageFromClientResponse*)q;
		break;
	case SOAP_TYPE_ns2__getProductLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductLikeList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductLikeList*)p = *(ns2__getProductLikeList*)q;
		break;
	case SOAP_TYPE_ns2__getProductLikeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getProductLikeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getProductLikeListResponse*)p = *(ns2__getProductLikeListResponse*)q;
		break;
	case SOAP_TYPE_ns2__getClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getClientByNameAndPwd*)p = *(ns2__getClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE_ns2__getClientByNameAndPwdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__getClientByNameAndPwdResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__getClientByNameAndPwdResponse*)p = *(ns2__getClientByNameAndPwdResponse*)q;
		break;
	case SOAP_TYPE_ns2__deleteShoppingCart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteShoppingCart type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteShoppingCart*)p = *(ns2__deleteShoppingCart*)q;
		break;
	case SOAP_TYPE_ns2__deleteShoppingCartResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__deleteShoppingCartResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__deleteShoppingCartResponse*)p = *(ns2__deleteShoppingCartResponse*)q;
		break;
	case SOAP_TYPE_ns2__InsertClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InsertClient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InsertClient*)p = *(ns2__InsertClient*)q;
		break;
	case SOAP_TYPE_ns2__InsertClientResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InsertClientResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InsertClientResponse*)p = *(ns2__InsertClientResponse*)q;
		break;
	case SOAP_TYPE___ns1__selectProductForUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__selectProductForUpdate type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__selectProductForUpdate*)p = *(struct __ns1__selectProductForUpdate*)q;
		break;
	case SOAP_TYPE___ns1__addProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__addProduct type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__addProduct*)p = *(struct __ns1__addProduct*)q;
		break;
	case SOAP_TYPE___ns1__deleteProductTypeByName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteProductTypeByName type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteProductTypeByName*)p = *(struct __ns1__deleteProductTypeByName*)q;
		break;
	case SOAP_TYPE___ns1__getOrderList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getOrderList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getOrderList*)p = *(struct __ns1__getOrderList*)q;
		break;
	case SOAP_TYPE___ns1__getShopByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getShopByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getShopByNameAndPwd*)p = *(struct __ns1__getShopByNameAndPwd*)q;
		break;
	case SOAP_TYPE___ns1__updateShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateShop*)p = *(struct __ns1__updateShop*)q;
		break;
	case SOAP_TYPE___ns1__getProductListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getProductListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getProductListByInfo*)p = *(struct __ns1__getProductListByInfo*)q;
		break;
	case SOAP_TYPE___ns1__getReadMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getReadMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getReadMessageFromShop*)p = *(struct __ns1__getReadMessageFromShop*)q;
		break;
	case SOAP_TYPE___ns1__updateClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateClient*)p = *(struct __ns1__updateClient*)q;
		break;
	case SOAP_TYPE___ns1__deleteProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteProductByInfo*)p = *(struct __ns1__deleteProductByInfo*)q;
		break;
	case SOAP_TYPE___ns1__deleteClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteClientByNameAndPwd*)p = *(struct __ns1__deleteClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE___ns1__InsertShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsertShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsertShop*)p = *(struct __ns1__InsertShop*)q;
		break;
	case SOAP_TYPE___ns1__updateMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateMessageFromShop*)p = *(struct __ns1__updateMessageFromShop*)q;
		break;
	case SOAP_TYPE___ns1__getProductTypeByProName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getProductTypeByProName type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getProductTypeByProName*)p = *(struct __ns1__getProductTypeByProName*)q;
		break;
	case SOAP_TYPE___ns1__getClientList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getClientList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getClientList*)p = *(struct __ns1__getClientList*)q;
		break;
	case SOAP_TYPE___ns1__purchaseProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__purchaseProduct type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__purchaseProduct*)p = *(struct __ns1__purchaseProduct*)q;
		break;
	case SOAP_TYPE___ns1__updateMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateMessageFromClient*)p = *(struct __ns1__updateMessageFromClient*)q;
		break;
	case SOAP_TYPE___ns1__getUnreadMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getUnreadMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getUnreadMessageFromClient*)p = *(struct __ns1__getUnreadMessageFromClient*)q;
		break;
	case SOAP_TYPE___ns1__updateProductByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateProductByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateProductByInfo*)p = *(struct __ns1__updateProductByInfo*)q;
		break;
	case SOAP_TYPE___ns1__getMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMessageFromClient*)p = *(struct __ns1__getMessageFromClient*)q;
		break;
	case SOAP_TYPE___ns1__addOrder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__addOrder type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__addOrder*)p = *(struct __ns1__addOrder*)q;
		break;
	case SOAP_TYPE___ns1__deleteShopByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteShopByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteShopByNameAndPwd*)p = *(struct __ns1__deleteShopByNameAndPwd*)q;
		break;
	case SOAP_TYPE___ns1__getProductList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getProductList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getProductList*)p = *(struct __ns1__getProductList*)q;
		break;
	case SOAP_TYPE___ns1__getOrderListHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getOrderListHistory type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getOrderListHistory*)p = *(struct __ns1__getOrderListHistory*)q;
		break;
	case SOAP_TYPE___ns1__getReadMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getReadMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getReadMessageFromClient*)p = *(struct __ns1__getReadMessageFromClient*)q;
		break;
	case SOAP_TYPE___ns1__updateHistory:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateHistory type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateHistory*)p = *(struct __ns1__updateHistory*)q;
		break;
	case SOAP_TYPE___ns1__InsertMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsertMessage type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsertMessage*)p = *(struct __ns1__InsertMessage*)q;
		break;
	case SOAP_TYPE___ns1__getShopLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getShopLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getShopLikeList*)p = *(struct __ns1__getShopLikeList*)q;
		break;
	case SOAP_TYPE___ns1__getMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMessageFromShop*)p = *(struct __ns1__getMessageFromShop*)q;
		break;
	case SOAP_TYPE___ns1__deleteMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteMessageFromShop*)p = *(struct __ns1__deleteMessageFromShop*)q;
		break;
	case SOAP_TYPE___ns1__getOrderLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getOrderLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getOrderLikeList*)p = *(struct __ns1__getOrderLikeList*)q;
		break;
	case SOAP_TYPE___ns1__getUnreadMessageFromShop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getUnreadMessageFromShop type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getUnreadMessageFromShop*)p = *(struct __ns1__getUnreadMessageFromShop*)q;
		break;
	case SOAP_TYPE___ns1__getClientLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getClientLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getClientLikeList*)p = *(struct __ns1__getClientLikeList*)q;
		break;
	case SOAP_TYPE___ns1__getShopList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getShopList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getShopList*)p = *(struct __ns1__getShopList*)q;
		break;
	case SOAP_TYPE___ns1__getOrderListByInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getOrderListByInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getOrderListByInfo*)p = *(struct __ns1__getOrderListByInfo*)q;
		break;
	case SOAP_TYPE___ns1__addProductType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__addProductType type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__addProductType*)p = *(struct __ns1__addProductType*)q;
		break;
	case SOAP_TYPE___ns1__deleteMessageFromClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteMessageFromClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteMessageFromClient*)p = *(struct __ns1__deleteMessageFromClient*)q;
		break;
	case SOAP_TYPE___ns1__getProductLikeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getProductLikeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getProductLikeList*)p = *(struct __ns1__getProductLikeList*)q;
		break;
	case SOAP_TYPE___ns1__getClientByNameAndPwd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getClientByNameAndPwd type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getClientByNameAndPwd*)p = *(struct __ns1__getClientByNameAndPwd*)q;
		break;
	case SOAP_TYPE___ns1__deleteShoppingCart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteShoppingCart type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteShoppingCart*)p = *(struct __ns1__deleteShoppingCart*)q;
		break;
	case SOAP_TYPE___ns1__InsertClient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsertClient type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsertClient*)p = *(struct __ns1__InsertClient*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InsertClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__InsertClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__InsertClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InsertClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InsertClientResponse(struct soap *soap, const char *tag, int id, const ns2__InsertClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InsertClientResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InsertClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__InsertClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InsertClientResponse * SOAP_FMAC4 soap_in_ns2__InsertClientResponse(struct soap *soap, const char *tag, ns2__InsertClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InsertClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InsertClientResponse, sizeof(ns2__InsertClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InsertClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InsertClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InsertClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InsertClientResponse, SOAP_TYPE_ns2__InsertClientResponse, sizeof(ns2__InsertClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InsertClientResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InsertClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InsertClientResponse *p;
	size_t k = sizeof(ns2__InsertClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__InsertClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__InsertClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__InsertClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InsertClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__InsertClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__InsertClientResponse(soap, tag ? tag : "ns2:InsertClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InsertClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InsertClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InsertClientResponse * SOAP_FMAC4 soap_get_ns2__InsertClientResponse(struct soap *soap, ns2__InsertClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InsertClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InsertClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__InsertClient::arg0 = NULL;
}

void ns2__InsertClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__client(soap, &this->ns2__InsertClient::arg0);
#endif
}

int ns2__InsertClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InsertClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InsertClient(struct soap *soap, const char *tag, int id, const ns2__InsertClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InsertClient), type))
		return soap->error;
	if (soap_out_PointerTons2__client(soap, "arg0", -1, &a->ns2__InsertClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InsertClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__InsertClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InsertClient * SOAP_FMAC4 soap_in_ns2__InsertClient(struct soap *soap, const char *tag, ns2__InsertClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InsertClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InsertClient, sizeof(ns2__InsertClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InsertClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InsertClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__client(soap, "arg0", &a->ns2__InsertClient::arg0, "ns2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InsertClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InsertClient, SOAP_TYPE_ns2__InsertClient, sizeof(ns2__InsertClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InsertClient * SOAP_FMAC2 soap_instantiate_ns2__InsertClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InsertClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InsertClient *p;
	size_t k = sizeof(ns2__InsertClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__InsertClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__InsertClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__InsertClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InsertClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__InsertClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__InsertClient(soap, tag ? tag : "ns2:InsertClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InsertClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InsertClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InsertClient * SOAP_FMAC4 soap_get_ns2__InsertClient(struct soap *soap, ns2__InsertClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InsertClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteShoppingCartResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteShoppingCartResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteShoppingCartResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteShoppingCartResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteShoppingCartResponse(struct soap *soap, const char *tag, int id, const ns2__deleteShoppingCartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteShoppingCartResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteShoppingCartResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteShoppingCartResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteShoppingCartResponse * SOAP_FMAC4 soap_in_ns2__deleteShoppingCartResponse(struct soap *soap, const char *tag, ns2__deleteShoppingCartResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteShoppingCartResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteShoppingCartResponse, sizeof(ns2__deleteShoppingCartResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteShoppingCartResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteShoppingCartResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteShoppingCartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteShoppingCartResponse, SOAP_TYPE_ns2__deleteShoppingCartResponse, sizeof(ns2__deleteShoppingCartResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteShoppingCartResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteShoppingCartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteShoppingCartResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteShoppingCartResponse *p;
	size_t k = sizeof(ns2__deleteShoppingCartResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteShoppingCartResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteShoppingCartResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteShoppingCartResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteShoppingCartResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteShoppingCartResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteShoppingCartResponse(soap, tag ? tag : "ns2:deleteShoppingCartResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteShoppingCartResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteShoppingCartResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteShoppingCartResponse * SOAP_FMAC4 soap_get_ns2__deleteShoppingCartResponse(struct soap *soap, ns2__deleteShoppingCartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteShoppingCartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteShoppingCart::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteShoppingCart::arg0 = NULL;
}

void ns2__deleteShoppingCart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__order(soap, &this->ns2__deleteShoppingCart::arg0);
#endif
}

int ns2__deleteShoppingCart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteShoppingCart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteShoppingCart(struct soap *soap, const char *tag, int id, const ns2__deleteShoppingCart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteShoppingCart), type))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg0", -1, &a->ns2__deleteShoppingCart::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteShoppingCart::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteShoppingCart(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteShoppingCart * SOAP_FMAC4 soap_in_ns2__deleteShoppingCart(struct soap *soap, const char *tag, ns2__deleteShoppingCart *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteShoppingCart*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteShoppingCart, sizeof(ns2__deleteShoppingCart), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteShoppingCart)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteShoppingCart *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg0", &a->ns2__deleteShoppingCart::arg0, "ns2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteShoppingCart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteShoppingCart, SOAP_TYPE_ns2__deleteShoppingCart, sizeof(ns2__deleteShoppingCart), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteShoppingCart * SOAP_FMAC2 soap_instantiate_ns2__deleteShoppingCart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteShoppingCart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteShoppingCart *p;
	size_t k = sizeof(ns2__deleteShoppingCart);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteShoppingCart, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteShoppingCart);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteShoppingCart, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteShoppingCart location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteShoppingCart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteShoppingCart(soap, tag ? tag : "ns2:deleteShoppingCart", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteShoppingCart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteShoppingCart(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteShoppingCart * SOAP_FMAC4 soap_get_ns2__deleteShoppingCart(struct soap *soap, ns2__deleteShoppingCart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getClientByNameAndPwdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClientByNameAndPwdResponse::return_ = NULL;
}

void ns2__getClientByNameAndPwdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__client(soap, &this->ns2__getClientByNameAndPwdResponse::return_);
#endif
}

int ns2__getClientByNameAndPwdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClientByNameAndPwdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClientByNameAndPwdResponse(struct soap *soap, const char *tag, int id, const ns2__getClientByNameAndPwdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClientByNameAndPwdResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__client(soap, "return", -1, &a->ns2__getClientByNameAndPwdResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getClientByNameAndPwdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getClientByNameAndPwdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClientByNameAndPwdResponse * SOAP_FMAC4 soap_in_ns2__getClientByNameAndPwdResponse(struct soap *soap, const char *tag, ns2__getClientByNameAndPwdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClientByNameAndPwdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClientByNameAndPwdResponse, sizeof(ns2__getClientByNameAndPwdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getClientByNameAndPwdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getClientByNameAndPwdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__client(soap, "return", &a->ns2__getClientByNameAndPwdResponse::return_, "ns2:client"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClientByNameAndPwdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClientByNameAndPwdResponse, SOAP_TYPE_ns2__getClientByNameAndPwdResponse, sizeof(ns2__getClientByNameAndPwdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientByNameAndPwdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClientByNameAndPwdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getClientByNameAndPwdResponse *p;
	size_t k = sizeof(ns2__getClientByNameAndPwdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getClientByNameAndPwdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getClientByNameAndPwdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getClientByNameAndPwdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getClientByNameAndPwdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getClientByNameAndPwdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getClientByNameAndPwdResponse(soap, tag ? tag : "ns2:getClientByNameAndPwdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClientByNameAndPwdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClientByNameAndPwdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClientByNameAndPwdResponse * SOAP_FMAC4 soap_get_ns2__getClientByNameAndPwdResponse(struct soap *soap, ns2__getClientByNameAndPwdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClientByNameAndPwdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getClientByNameAndPwd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClientByNameAndPwd::arg0 = NULL;
	this->ns2__getClientByNameAndPwd::arg1 = NULL;
}

void ns2__getClientByNameAndPwd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClientByNameAndPwd::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClientByNameAndPwd::arg1);
#endif
}

int ns2__getClientByNameAndPwd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClientByNameAndPwd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClientByNameAndPwd(struct soap *soap, const char *tag, int id, const ns2__getClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClientByNameAndPwd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getClientByNameAndPwd::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->ns2__getClientByNameAndPwd::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getClientByNameAndPwd::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getClientByNameAndPwd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClientByNameAndPwd * SOAP_FMAC4 soap_in_ns2__getClientByNameAndPwd(struct soap *soap, const char *tag, ns2__getClientByNameAndPwd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClientByNameAndPwd*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClientByNameAndPwd, sizeof(ns2__getClientByNameAndPwd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getClientByNameAndPwd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getClientByNameAndPwd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getClientByNameAndPwd::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->ns2__getClientByNameAndPwd::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClientByNameAndPwd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClientByNameAndPwd, SOAP_TYPE_ns2__getClientByNameAndPwd, sizeof(ns2__getClientByNameAndPwd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__getClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getClientByNameAndPwd *p;
	size_t k = sizeof(ns2__getClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getClientByNameAndPwd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getClientByNameAndPwd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getClientByNameAndPwd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getClientByNameAndPwd(soap, tag ? tag : "ns2:getClientByNameAndPwd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClientByNameAndPwd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClientByNameAndPwd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClientByNameAndPwd * SOAP_FMAC4 soap_get_ns2__getClientByNameAndPwd(struct soap *soap, ns2__getClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__product(soap, &this->ns2__getProductLikeListResponse::return_);
}

void ns2__getProductLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__product(soap, &this->ns2__getProductLikeListResponse::return_);
#endif
}

int ns2__getProductLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductLikeListResponse(struct soap *soap, const char *tag, int id, const ns2__getProductLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__product(soap, "return", -1, &a->ns2__getProductLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductLikeListResponse * SOAP_FMAC4 soap_in_ns2__getProductLikeListResponse(struct soap *soap, const char *tag, ns2__getProductLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductLikeListResponse, sizeof(ns2__getProductLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__product(soap, "return", &a->ns2__getProductLikeListResponse::return_, "ns2:product"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductLikeListResponse, SOAP_TYPE_ns2__getProductLikeListResponse, sizeof(ns2__getProductLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductLikeListResponse *p;
	size_t k = sizeof(ns2__getProductLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductLikeListResponse(soap, tag ? tag : "ns2:getProductLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductLikeListResponse * SOAP_FMAC4 soap_get_ns2__getProductLikeListResponse(struct soap *soap, ns2__getProductLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getProductLikeList::arg0 = NULL;
	this->ns2__getProductLikeList::arg1 = NULL;
}

void ns2__getProductLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getProductLikeList::arg0);
	soap_serialize_PointerTons2__product(soap, &this->ns2__getProductLikeList::arg1);
#endif
}

int ns2__getProductLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductLikeList(struct soap *soap, const char *tag, int id, const ns2__getProductLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getProductLikeList::arg0, ""))
		return soap->error;
	if (soap_out_PointerTons2__product(soap, "arg1", -1, &a->ns2__getProductLikeList::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductLikeList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductLikeList * SOAP_FMAC4 soap_in_ns2__getProductLikeList(struct soap *soap, const char *tag, ns2__getProductLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductLikeList, sizeof(ns2__getProductLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getProductLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__product(soap, "arg1", &a->ns2__getProductLikeList::arg1, "ns2:product"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductLikeList, SOAP_TYPE_ns2__getProductLikeList, sizeof(ns2__getProductLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductLikeList * SOAP_FMAC2 soap_instantiate_ns2__getProductLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductLikeList *p;
	size_t k = sizeof(ns2__getProductLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductLikeList(soap, tag ? tag : "ns2:getProductLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductLikeList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductLikeList * SOAP_FMAC4 soap_get_ns2__getProductLikeList(struct soap *soap, ns2__getProductLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteMessageFromClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteMessageFromClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteMessageFromClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteMessageFromClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteMessageFromClientResponse(struct soap *soap, const char *tag, int id, const ns2__deleteMessageFromClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteMessageFromClientResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteMessageFromClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteMessageFromClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteMessageFromClientResponse * SOAP_FMAC4 soap_in_ns2__deleteMessageFromClientResponse(struct soap *soap, const char *tag, ns2__deleteMessageFromClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteMessageFromClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteMessageFromClientResponse, sizeof(ns2__deleteMessageFromClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteMessageFromClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteMessageFromClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteMessageFromClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteMessageFromClientResponse, SOAP_TYPE_ns2__deleteMessageFromClientResponse, sizeof(ns2__deleteMessageFromClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteMessageFromClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteMessageFromClientResponse *p;
	size_t k = sizeof(ns2__deleteMessageFromClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteMessageFromClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteMessageFromClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteMessageFromClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteMessageFromClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteMessageFromClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteMessageFromClientResponse(soap, tag ? tag : "ns2:deleteMessageFromClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteMessageFromClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteMessageFromClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteMessageFromClientResponse * SOAP_FMAC4 soap_get_ns2__deleteMessageFromClientResponse(struct soap *soap, ns2__deleteMessageFromClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteMessageFromClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteMessageFromClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteMessageFromClient::arg0 = NULL;
	soap_default_int(soap, &this->ns2__deleteMessageFromClient::arg1);
}

void ns2__deleteMessageFromClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__message(soap, &this->ns2__deleteMessageFromClient::arg0);
#endif
}

int ns2__deleteMessageFromClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteMessageFromClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteMessageFromClient(struct soap *soap, const char *tag, int id, const ns2__deleteMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteMessageFromClient), type))
		return soap->error;
	if (soap_out_PointerTons2__message(soap, "arg0", -1, &a->ns2__deleteMessageFromClient::arg0, ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &a->ns2__deleteMessageFromClient::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteMessageFromClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteMessageFromClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteMessageFromClient * SOAP_FMAC4 soap_in_ns2__deleteMessageFromClient(struct soap *soap, const char *tag, ns2__deleteMessageFromClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteMessageFromClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteMessageFromClient, sizeof(ns2__deleteMessageFromClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteMessageFromClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteMessageFromClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__message(soap, "arg0", &a->ns2__deleteMessageFromClient::arg0, "ns2:message"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg1", &a->ns2__deleteMessageFromClient::arg1, "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__deleteMessageFromClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteMessageFromClient, SOAP_TYPE_ns2__deleteMessageFromClient, sizeof(ns2__deleteMessageFromClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteMessageFromClient *p;
	size_t k = sizeof(ns2__deleteMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteMessageFromClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteMessageFromClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteMessageFromClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteMessageFromClient(soap, tag ? tag : "ns2:deleteMessageFromClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteMessageFromClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteMessageFromClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteMessageFromClient * SOAP_FMAC4 soap_get_ns2__deleteMessageFromClient(struct soap *soap, ns2__deleteMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__addProductTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__addProductTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__addProductTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addProductTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addProductTypeResponse(struct soap *soap, const char *tag, int id, const ns2__addProductTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addProductTypeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__addProductTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__addProductTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addProductTypeResponse * SOAP_FMAC4 soap_in_ns2__addProductTypeResponse(struct soap *soap, const char *tag, ns2__addProductTypeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addProductTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addProductTypeResponse, sizeof(ns2__addProductTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__addProductTypeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__addProductTypeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addProductTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addProductTypeResponse, SOAP_TYPE_ns2__addProductTypeResponse, sizeof(ns2__addProductTypeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__addProductTypeResponse * SOAP_FMAC2 soap_instantiate_ns2__addProductTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addProductTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__addProductTypeResponse *p;
	size_t k = sizeof(ns2__addProductTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__addProductTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__addProductTypeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__addProductTypeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__addProductTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__addProductTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__addProductTypeResponse(soap, tag ? tag : "ns2:addProductTypeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addProductTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addProductTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addProductTypeResponse * SOAP_FMAC4 soap_get_ns2__addProductTypeResponse(struct soap *soap, ns2__addProductTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addProductTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__addProductType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__addProductType::arg0 = NULL;
}

void ns2__addProductType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__productType(soap, &this->ns2__addProductType::arg0);
#endif
}

int ns2__addProductType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addProductType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addProductType(struct soap *soap, const char *tag, int id, const ns2__addProductType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addProductType), type))
		return soap->error;
	if (soap_out_PointerTons2__productType(soap, "arg0", -1, &a->ns2__addProductType::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__addProductType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__addProductType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addProductType * SOAP_FMAC4 soap_in_ns2__addProductType(struct soap *soap, const char *tag, ns2__addProductType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addProductType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addProductType, sizeof(ns2__addProductType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__addProductType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__addProductType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__productType(soap, "arg0", &a->ns2__addProductType::arg0, "ns2:productType"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addProductType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addProductType, SOAP_TYPE_ns2__addProductType, sizeof(ns2__addProductType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__addProductType * SOAP_FMAC2 soap_instantiate_ns2__addProductType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addProductType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__addProductType *p;
	size_t k = sizeof(ns2__addProductType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__addProductType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__addProductType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__addProductType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__addProductType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__addProductType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__addProductType(soap, tag ? tag : "ns2:addProductType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addProductType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addProductType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addProductType * SOAP_FMAC4 soap_get_ns2__addProductType(struct soap *soap, ns2__addProductType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderListByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderListByInfoResponse::return_);
}

void ns2__getOrderListByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderListByInfoResponse::return_);
#endif
}

int ns2__getOrderListByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderListByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderListByInfoResponse(struct soap *soap, const char *tag, int id, const ns2__getOrderListByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderListByInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__order(soap, "return", -1, &a->ns2__getOrderListByInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderListByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderListByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderListByInfoResponse * SOAP_FMAC4 soap_in_ns2__getOrderListByInfoResponse(struct soap *soap, const char *tag, ns2__getOrderListByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderListByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderListByInfoResponse, sizeof(ns2__getOrderListByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderListByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderListByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__order(soap, "return", &a->ns2__getOrderListByInfoResponse::return_, "ns2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderListByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderListByInfoResponse, SOAP_TYPE_ns2__getOrderListByInfoResponse, sizeof(ns2__getOrderListByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderListByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderListByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderListByInfoResponse *p;
	size_t k = sizeof(ns2__getOrderListByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderListByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderListByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderListByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderListByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderListByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderListByInfoResponse(soap, tag ? tag : "ns2:getOrderListByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderListByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderListByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderListByInfoResponse * SOAP_FMAC4 soap_get_ns2__getOrderListByInfoResponse(struct soap *soap, ns2__getOrderListByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderListByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderListByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getOrderListByInfo::arg0 = NULL;
}

void ns2__getOrderListByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__order(soap, &this->ns2__getOrderListByInfo::arg0);
#endif
}

int ns2__getOrderListByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderListByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderListByInfo(struct soap *soap, const char *tag, int id, const ns2__getOrderListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderListByInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg0", -1, &a->ns2__getOrderListByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderListByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderListByInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderListByInfo * SOAP_FMAC4 soap_in_ns2__getOrderListByInfo(struct soap *soap, const char *tag, ns2__getOrderListByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderListByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderListByInfo, sizeof(ns2__getOrderListByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderListByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderListByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg0", &a->ns2__getOrderListByInfo::arg0, "ns2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderListByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderListByInfo, SOAP_TYPE_ns2__getOrderListByInfo, sizeof(ns2__getOrderListByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderListByInfo * SOAP_FMAC2 soap_instantiate_ns2__getOrderListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderListByInfo *p;
	size_t k = sizeof(ns2__getOrderListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderListByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderListByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderListByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderListByInfo(soap, tag ? tag : "ns2:getOrderListByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderListByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderListByInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderListByInfo * SOAP_FMAC4 soap_get_ns2__getOrderListByInfo(struct soap *soap, ns2__getOrderListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getShopListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__shop(soap, &this->ns2__getShopListResponse::return_);
}

void ns2__getShopListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__shop(soap, &this->ns2__getShopListResponse::return_);
#endif
}

int ns2__getShopListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getShopListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getShopListResponse(struct soap *soap, const char *tag, int id, const ns2__getShopListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getShopListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__shop(soap, "return", -1, &a->ns2__getShopListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getShopListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getShopListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getShopListResponse * SOAP_FMAC4 soap_in_ns2__getShopListResponse(struct soap *soap, const char *tag, ns2__getShopListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getShopListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getShopListResponse, sizeof(ns2__getShopListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getShopListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getShopListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__shop(soap, "return", &a->ns2__getShopListResponse::return_, "ns2:shop"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getShopListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getShopListResponse, SOAP_TYPE_ns2__getShopListResponse, sizeof(ns2__getShopListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getShopListResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getShopListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getShopListResponse *p;
	size_t k = sizeof(ns2__getShopListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getShopListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getShopListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getShopListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getShopListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getShopListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getShopListResponse(soap, tag ? tag : "ns2:getShopListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getShopListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getShopListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getShopListResponse * SOAP_FMAC4 soap_get_ns2__getShopListResponse(struct soap *soap, ns2__getShopListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getShopListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getShopList::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__getShopList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__getShopList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getShopList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getShopList(struct soap *soap, const char *tag, int id, const ns2__getShopList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getShopList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getShopList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getShopList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getShopList * SOAP_FMAC4 soap_in_ns2__getShopList(struct soap *soap, const char *tag, ns2__getShopList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getShopList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getShopList, sizeof(ns2__getShopList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getShopList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getShopList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getShopList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getShopList, SOAP_TYPE_ns2__getShopList, sizeof(ns2__getShopList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getShopList * SOAP_FMAC2 soap_instantiate_ns2__getShopList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getShopList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getShopList *p;
	size_t k = sizeof(ns2__getShopList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getShopList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getShopList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getShopList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getShopList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getShopList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getShopList(soap, tag ? tag : "ns2:getShopList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getShopList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getShopList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getShopList * SOAP_FMAC4 soap_get_ns2__getShopList(struct soap *soap, ns2__getShopList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getShopList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getClientLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__client(soap, &this->ns2__getClientLikeListResponse::return_);
}

void ns2__getClientLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__client(soap, &this->ns2__getClientLikeListResponse::return_);
#endif
}

int ns2__getClientLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClientLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClientLikeListResponse(struct soap *soap, const char *tag, int id, const ns2__getClientLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClientLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__client(soap, "return", -1, &a->ns2__getClientLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getClientLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getClientLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClientLikeListResponse * SOAP_FMAC4 soap_in_ns2__getClientLikeListResponse(struct soap *soap, const char *tag, ns2__getClientLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClientLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClientLikeListResponse, sizeof(ns2__getClientLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getClientLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getClientLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__client(soap, "return", &a->ns2__getClientLikeListResponse::return_, "ns2:client"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClientLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClientLikeListResponse, SOAP_TYPE_ns2__getClientLikeListResponse, sizeof(ns2__getClientLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getClientLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClientLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getClientLikeListResponse *p;
	size_t k = sizeof(ns2__getClientLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getClientLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getClientLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getClientLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getClientLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getClientLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getClientLikeListResponse(soap, tag ? tag : "ns2:getClientLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClientLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClientLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClientLikeListResponse * SOAP_FMAC4 soap_get_ns2__getClientLikeListResponse(struct soap *soap, ns2__getClientLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClientLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getClientLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getClientLikeList::arg0 = NULL;
}

void ns2__getClientLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getClientLikeList::arg0);
#endif
}

int ns2__getClientLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClientLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClientLikeList(struct soap *soap, const char *tag, int id, const ns2__getClientLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClientLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getClientLikeList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getClientLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getClientLikeList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClientLikeList * SOAP_FMAC4 soap_in_ns2__getClientLikeList(struct soap *soap, const char *tag, ns2__getClientLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClientLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClientLikeList, sizeof(ns2__getClientLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getClientLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getClientLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getClientLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClientLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClientLikeList, SOAP_TYPE_ns2__getClientLikeList, sizeof(ns2__getClientLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getClientLikeList * SOAP_FMAC2 soap_instantiate_ns2__getClientLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClientLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getClientLikeList *p;
	size_t k = sizeof(ns2__getClientLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getClientLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getClientLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getClientLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getClientLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getClientLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getClientLikeList(soap, tag ? tag : "ns2:getClientLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClientLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClientLikeList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClientLikeList * SOAP_FMAC4 soap_get_ns2__getClientLikeList(struct soap *soap, ns2__getClientLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClientLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getUnreadMessageFromShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getUnreadMessageFromShopResponse::return_);
}

void ns2__getUnreadMessageFromShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getUnreadMessageFromShopResponse::return_);
#endif
}

int ns2__getUnreadMessageFromShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getUnreadMessageFromShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getUnreadMessageFromShopResponse(struct soap *soap, const char *tag, int id, const ns2__getUnreadMessageFromShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getUnreadMessageFromShopResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__message(soap, "return", -1, &a->ns2__getUnreadMessageFromShopResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getUnreadMessageFromShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getUnreadMessageFromShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromShopResponse * SOAP_FMAC4 soap_in_ns2__getUnreadMessageFromShopResponse(struct soap *soap, const char *tag, ns2__getUnreadMessageFromShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getUnreadMessageFromShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getUnreadMessageFromShopResponse, sizeof(ns2__getUnreadMessageFromShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getUnreadMessageFromShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getUnreadMessageFromShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__message(soap, "return", &a->ns2__getUnreadMessageFromShopResponse::return_, "ns2:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getUnreadMessageFromShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getUnreadMessageFromShopResponse, SOAP_TYPE_ns2__getUnreadMessageFromShopResponse, sizeof(ns2__getUnreadMessageFromShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getUnreadMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getUnreadMessageFromShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getUnreadMessageFromShopResponse *p;
	size_t k = sizeof(ns2__getUnreadMessageFromShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getUnreadMessageFromShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getUnreadMessageFromShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getUnreadMessageFromShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getUnreadMessageFromShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getUnreadMessageFromShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getUnreadMessageFromShopResponse(soap, tag ? tag : "ns2:getUnreadMessageFromShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getUnreadMessageFromShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getUnreadMessageFromShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromShopResponse * SOAP_FMAC4 soap_get_ns2__getUnreadMessageFromShopResponse(struct soap *soap, ns2__getUnreadMessageFromShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getUnreadMessageFromShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getUnreadMessageFromShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getUnreadMessageFromShop::arg0 = NULL;
}

void ns2__getUnreadMessageFromShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__client(soap, &this->ns2__getUnreadMessageFromShop::arg0);
#endif
}

int ns2__getUnreadMessageFromShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getUnreadMessageFromShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getUnreadMessageFromShop(struct soap *soap, const char *tag, int id, const ns2__getUnreadMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getUnreadMessageFromShop), type))
		return soap->error;
	if (soap_out_PointerTons2__client(soap, "arg0", -1, &a->ns2__getUnreadMessageFromShop::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getUnreadMessageFromShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getUnreadMessageFromShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromShop * SOAP_FMAC4 soap_in_ns2__getUnreadMessageFromShop(struct soap *soap, const char *tag, ns2__getUnreadMessageFromShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getUnreadMessageFromShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getUnreadMessageFromShop, sizeof(ns2__getUnreadMessageFromShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getUnreadMessageFromShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getUnreadMessageFromShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__client(soap, "arg0", &a->ns2__getUnreadMessageFromShop::arg0, "ns2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getUnreadMessageFromShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getUnreadMessageFromShop, SOAP_TYPE_ns2__getUnreadMessageFromShop, sizeof(ns2__getUnreadMessageFromShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getUnreadMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getUnreadMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getUnreadMessageFromShop *p;
	size_t k = sizeof(ns2__getUnreadMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getUnreadMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getUnreadMessageFromShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getUnreadMessageFromShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getUnreadMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getUnreadMessageFromShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getUnreadMessageFromShop(soap, tag ? tag : "ns2:getUnreadMessageFromShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getUnreadMessageFromShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getUnreadMessageFromShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromShop * SOAP_FMAC4 soap_get_ns2__getUnreadMessageFromShop(struct soap *soap, ns2__getUnreadMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getUnreadMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderLikeListResponse::return_);
}

void ns2__getOrderLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderLikeListResponse::return_);
#endif
}

int ns2__getOrderLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderLikeListResponse(struct soap *soap, const char *tag, int id, const ns2__getOrderLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__order(soap, "return", -1, &a->ns2__getOrderLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderLikeListResponse * SOAP_FMAC4 soap_in_ns2__getOrderLikeListResponse(struct soap *soap, const char *tag, ns2__getOrderLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderLikeListResponse, sizeof(ns2__getOrderLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__order(soap, "return", &a->ns2__getOrderLikeListResponse::return_, "ns2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderLikeListResponse, SOAP_TYPE_ns2__getOrderLikeListResponse, sizeof(ns2__getOrderLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderLikeListResponse *p;
	size_t k = sizeof(ns2__getOrderLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderLikeListResponse(soap, tag ? tag : "ns2:getOrderLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderLikeListResponse * SOAP_FMAC4 soap_get_ns2__getOrderLikeListResponse(struct soap *soap, ns2__getOrderLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getOrderLikeList::arg0 = NULL;
	this->ns2__getOrderLikeList::arg1 = NULL;
}

void ns2__getOrderLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getOrderLikeList::arg0);
	soap_serialize_PointerTons2__order(soap, &this->ns2__getOrderLikeList::arg1);
#endif
}

int ns2__getOrderLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderLikeList(struct soap *soap, const char *tag, int id, const ns2__getOrderLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getOrderLikeList::arg0, ""))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg1", -1, &a->ns2__getOrderLikeList::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderLikeList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderLikeList * SOAP_FMAC4 soap_in_ns2__getOrderLikeList(struct soap *soap, const char *tag, ns2__getOrderLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderLikeList, sizeof(ns2__getOrderLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getOrderLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg1", &a->ns2__getOrderLikeList::arg1, "ns2:order"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderLikeList, SOAP_TYPE_ns2__getOrderLikeList, sizeof(ns2__getOrderLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderLikeList * SOAP_FMAC2 soap_instantiate_ns2__getOrderLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderLikeList *p;
	size_t k = sizeof(ns2__getOrderLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderLikeList(soap, tag ? tag : "ns2:getOrderLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderLikeList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderLikeList * SOAP_FMAC4 soap_get_ns2__getOrderLikeList(struct soap *soap, ns2__getOrderLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteMessageFromShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteMessageFromShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteMessageFromShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteMessageFromShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteMessageFromShopResponse(struct soap *soap, const char *tag, int id, const ns2__deleteMessageFromShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteMessageFromShopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteMessageFromShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteMessageFromShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteMessageFromShopResponse * SOAP_FMAC4 soap_in_ns2__deleteMessageFromShopResponse(struct soap *soap, const char *tag, ns2__deleteMessageFromShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteMessageFromShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteMessageFromShopResponse, sizeof(ns2__deleteMessageFromShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteMessageFromShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteMessageFromShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteMessageFromShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteMessageFromShopResponse, SOAP_TYPE_ns2__deleteMessageFromShopResponse, sizeof(ns2__deleteMessageFromShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteMessageFromShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteMessageFromShopResponse *p;
	size_t k = sizeof(ns2__deleteMessageFromShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteMessageFromShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteMessageFromShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteMessageFromShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteMessageFromShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteMessageFromShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteMessageFromShopResponse(soap, tag ? tag : "ns2:deleteMessageFromShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteMessageFromShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteMessageFromShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteMessageFromShopResponse * SOAP_FMAC4 soap_get_ns2__deleteMessageFromShopResponse(struct soap *soap, ns2__deleteMessageFromShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteMessageFromShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteMessageFromShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteMessageFromShop::arg0 = NULL;
	soap_default_int(soap, &this->ns2__deleteMessageFromShop::arg1);
}

void ns2__deleteMessageFromShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__message(soap, &this->ns2__deleteMessageFromShop::arg0);
#endif
}

int ns2__deleteMessageFromShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteMessageFromShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteMessageFromShop(struct soap *soap, const char *tag, int id, const ns2__deleteMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteMessageFromShop), type))
		return soap->error;
	if (soap_out_PointerTons2__message(soap, "arg0", -1, &a->ns2__deleteMessageFromShop::arg0, ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &a->ns2__deleteMessageFromShop::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteMessageFromShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteMessageFromShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteMessageFromShop * SOAP_FMAC4 soap_in_ns2__deleteMessageFromShop(struct soap *soap, const char *tag, ns2__deleteMessageFromShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteMessageFromShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteMessageFromShop, sizeof(ns2__deleteMessageFromShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteMessageFromShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteMessageFromShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__message(soap, "arg0", &a->ns2__deleteMessageFromShop::arg0, "ns2:message"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg1", &a->ns2__deleteMessageFromShop::arg1, "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__deleteMessageFromShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteMessageFromShop, SOAP_TYPE_ns2__deleteMessageFromShop, sizeof(ns2__deleteMessageFromShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__deleteMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteMessageFromShop *p;
	size_t k = sizeof(ns2__deleteMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteMessageFromShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteMessageFromShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteMessageFromShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteMessageFromShop(soap, tag ? tag : "ns2:deleteMessageFromShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteMessageFromShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteMessageFromShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteMessageFromShop * SOAP_FMAC4 soap_get_ns2__deleteMessageFromShop(struct soap *soap, ns2__deleteMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getMessageFromShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getMessageFromShopResponse::return_);
}

void ns2__getMessageFromShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getMessageFromShopResponse::return_);
#endif
}

int ns2__getMessageFromShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMessageFromShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMessageFromShopResponse(struct soap *soap, const char *tag, int id, const ns2__getMessageFromShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMessageFromShopResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__message(soap, "return", -1, &a->ns2__getMessageFromShopResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getMessageFromShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getMessageFromShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMessageFromShopResponse * SOAP_FMAC4 soap_in_ns2__getMessageFromShopResponse(struct soap *soap, const char *tag, ns2__getMessageFromShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMessageFromShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMessageFromShopResponse, sizeof(ns2__getMessageFromShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getMessageFromShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getMessageFromShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__message(soap, "return", &a->ns2__getMessageFromShopResponse::return_, "ns2:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMessageFromShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMessageFromShopResponse, SOAP_TYPE_ns2__getMessageFromShopResponse, sizeof(ns2__getMessageFromShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMessageFromShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getMessageFromShopResponse *p;
	size_t k = sizeof(ns2__getMessageFromShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getMessageFromShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getMessageFromShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getMessageFromShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getMessageFromShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getMessageFromShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getMessageFromShopResponse(soap, tag ? tag : "ns2:getMessageFromShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMessageFromShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMessageFromShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMessageFromShopResponse * SOAP_FMAC4 soap_get_ns2__getMessageFromShopResponse(struct soap *soap, ns2__getMessageFromShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMessageFromShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getMessageFromShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getMessageFromShop::arg0 = NULL;
}

void ns2__getMessageFromShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__client(soap, &this->ns2__getMessageFromShop::arg0);
#endif
}

int ns2__getMessageFromShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMessageFromShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMessageFromShop(struct soap *soap, const char *tag, int id, const ns2__getMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMessageFromShop), type))
		return soap->error;
	if (soap_out_PointerTons2__client(soap, "arg0", -1, &a->ns2__getMessageFromShop::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getMessageFromShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getMessageFromShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMessageFromShop * SOAP_FMAC4 soap_in_ns2__getMessageFromShop(struct soap *soap, const char *tag, ns2__getMessageFromShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMessageFromShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMessageFromShop, sizeof(ns2__getMessageFromShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getMessageFromShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getMessageFromShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__client(soap, "arg0", &a->ns2__getMessageFromShop::arg0, "ns2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMessageFromShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMessageFromShop, SOAP_TYPE_ns2__getMessageFromShop, sizeof(ns2__getMessageFromShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getMessageFromShop *p;
	size_t k = sizeof(ns2__getMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getMessageFromShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getMessageFromShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getMessageFromShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getMessageFromShop(soap, tag ? tag : "ns2:getMessageFromShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMessageFromShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMessageFromShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMessageFromShop * SOAP_FMAC4 soap_get_ns2__getMessageFromShop(struct soap *soap, ns2__getMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getShopLikeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__shop(soap, &this->ns2__getShopLikeListResponse::return_);
}

void ns2__getShopLikeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__shop(soap, &this->ns2__getShopLikeListResponse::return_);
#endif
}

int ns2__getShopLikeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getShopLikeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getShopLikeListResponse(struct soap *soap, const char *tag, int id, const ns2__getShopLikeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getShopLikeListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__shop(soap, "return", -1, &a->ns2__getShopLikeListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getShopLikeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getShopLikeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getShopLikeListResponse * SOAP_FMAC4 soap_in_ns2__getShopLikeListResponse(struct soap *soap, const char *tag, ns2__getShopLikeListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getShopLikeListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getShopLikeListResponse, sizeof(ns2__getShopLikeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getShopLikeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getShopLikeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__shop(soap, "return", &a->ns2__getShopLikeListResponse::return_, "ns2:shop"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getShopLikeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getShopLikeListResponse, SOAP_TYPE_ns2__getShopLikeListResponse, sizeof(ns2__getShopLikeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getShopLikeListResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopLikeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getShopLikeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getShopLikeListResponse *p;
	size_t k = sizeof(ns2__getShopLikeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getShopLikeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getShopLikeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getShopLikeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getShopLikeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getShopLikeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getShopLikeListResponse(soap, tag ? tag : "ns2:getShopLikeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getShopLikeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getShopLikeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getShopLikeListResponse * SOAP_FMAC4 soap_get_ns2__getShopLikeListResponse(struct soap *soap, ns2__getShopLikeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getShopLikeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getShopLikeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getShopLikeList::arg0 = NULL;
}

void ns2__getShopLikeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getShopLikeList::arg0);
#endif
}

int ns2__getShopLikeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getShopLikeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getShopLikeList(struct soap *soap, const char *tag, int id, const ns2__getShopLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getShopLikeList), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getShopLikeList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getShopLikeList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getShopLikeList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getShopLikeList * SOAP_FMAC4 soap_in_ns2__getShopLikeList(struct soap *soap, const char *tag, ns2__getShopLikeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getShopLikeList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getShopLikeList, sizeof(ns2__getShopLikeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getShopLikeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getShopLikeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getShopLikeList::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getShopLikeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getShopLikeList, SOAP_TYPE_ns2__getShopLikeList, sizeof(ns2__getShopLikeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getShopLikeList * SOAP_FMAC2 soap_instantiate_ns2__getShopLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getShopLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getShopLikeList *p;
	size_t k = sizeof(ns2__getShopLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getShopLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getShopLikeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getShopLikeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getShopLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getShopLikeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getShopLikeList(soap, tag ? tag : "ns2:getShopLikeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getShopLikeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getShopLikeList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getShopLikeList * SOAP_FMAC4 soap_get_ns2__getShopLikeList(struct soap *soap, ns2__getShopLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getShopLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InsertMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__InsertMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__InsertMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InsertMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InsertMessageResponse(struct soap *soap, const char *tag, int id, const ns2__InsertMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InsertMessageResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InsertMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__InsertMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InsertMessageResponse * SOAP_FMAC4 soap_in_ns2__InsertMessageResponse(struct soap *soap, const char *tag, ns2__InsertMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InsertMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InsertMessageResponse, sizeof(ns2__InsertMessageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InsertMessageResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InsertMessageResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InsertMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InsertMessageResponse, SOAP_TYPE_ns2__InsertMessageResponse, sizeof(ns2__InsertMessageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InsertMessageResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InsertMessageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InsertMessageResponse *p;
	size_t k = sizeof(ns2__InsertMessageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__InsertMessageResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__InsertMessageResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__InsertMessageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InsertMessageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__InsertMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__InsertMessageResponse(soap, tag ? tag : "ns2:InsertMessageResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InsertMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InsertMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InsertMessageResponse * SOAP_FMAC4 soap_get_ns2__InsertMessageResponse(struct soap *soap, ns2__InsertMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InsertMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InsertMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__InsertMessage::arg0 = NULL;
}

void ns2__InsertMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__message(soap, &this->ns2__InsertMessage::arg0);
#endif
}

int ns2__InsertMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InsertMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InsertMessage(struct soap *soap, const char *tag, int id, const ns2__InsertMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InsertMessage), type))
		return soap->error;
	if (soap_out_PointerTons2__message(soap, "arg0", -1, &a->ns2__InsertMessage::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InsertMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__InsertMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InsertMessage * SOAP_FMAC4 soap_in_ns2__InsertMessage(struct soap *soap, const char *tag, ns2__InsertMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InsertMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InsertMessage, sizeof(ns2__InsertMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InsertMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InsertMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__message(soap, "arg0", &a->ns2__InsertMessage::arg0, "ns2:message"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InsertMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InsertMessage, SOAP_TYPE_ns2__InsertMessage, sizeof(ns2__InsertMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InsertMessage * SOAP_FMAC2 soap_instantiate_ns2__InsertMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InsertMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InsertMessage *p;
	size_t k = sizeof(ns2__InsertMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__InsertMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__InsertMessage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__InsertMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InsertMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__InsertMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__InsertMessage(soap, tag ? tag : "ns2:InsertMessage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InsertMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InsertMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InsertMessage * SOAP_FMAC4 soap_get_ns2__InsertMessage(struct soap *soap, ns2__InsertMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InsertMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__updateHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__updateHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateHistoryResponse(struct soap *soap, const char *tag, int id, const ns2__updateHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateHistoryResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateHistoryResponse * SOAP_FMAC4 soap_in_ns2__updateHistoryResponse(struct soap *soap, const char *tag, ns2__updateHistoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateHistoryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateHistoryResponse, sizeof(ns2__updateHistoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateHistoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateHistoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateHistoryResponse, SOAP_TYPE_ns2__updateHistoryResponse, sizeof(ns2__updateHistoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateHistoryResponse * SOAP_FMAC2 soap_instantiate_ns2__updateHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateHistoryResponse *p;
	size_t k = sizeof(ns2__updateHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateHistoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateHistoryResponse(soap, tag ? tag : "ns2:updateHistoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateHistoryResponse * SOAP_FMAC4 soap_get_ns2__updateHistoryResponse(struct soap *soap, ns2__updateHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__updateHistory::arg0 = NULL;
}

void ns2__updateHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__order(soap, &this->ns2__updateHistory::arg0);
#endif
}

int ns2__updateHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateHistory(struct soap *soap, const char *tag, int id, const ns2__updateHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateHistory), type))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg0", -1, &a->ns2__updateHistory::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateHistory(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateHistory * SOAP_FMAC4 soap_in_ns2__updateHistory(struct soap *soap, const char *tag, ns2__updateHistory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateHistory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateHistory, sizeof(ns2__updateHistory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateHistory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateHistory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg0", &a->ns2__updateHistory::arg0, "ns2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateHistory, SOAP_TYPE_ns2__updateHistory, sizeof(ns2__updateHistory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateHistory * SOAP_FMAC2 soap_instantiate_ns2__updateHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateHistory *p;
	size_t k = sizeof(ns2__updateHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateHistory);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateHistory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateHistory(soap, tag ? tag : "ns2:updateHistory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateHistory(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateHistory * SOAP_FMAC4 soap_get_ns2__updateHistory(struct soap *soap, ns2__updateHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getReadMessageFromClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getReadMessageFromClientResponse::return_);
}

void ns2__getReadMessageFromClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getReadMessageFromClientResponse::return_);
#endif
}

int ns2__getReadMessageFromClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getReadMessageFromClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getReadMessageFromClientResponse(struct soap *soap, const char *tag, int id, const ns2__getReadMessageFromClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getReadMessageFromClientResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__message(soap, "return", -1, &a->ns2__getReadMessageFromClientResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getReadMessageFromClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getReadMessageFromClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getReadMessageFromClientResponse * SOAP_FMAC4 soap_in_ns2__getReadMessageFromClientResponse(struct soap *soap, const char *tag, ns2__getReadMessageFromClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getReadMessageFromClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getReadMessageFromClientResponse, sizeof(ns2__getReadMessageFromClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getReadMessageFromClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getReadMessageFromClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__message(soap, "return", &a->ns2__getReadMessageFromClientResponse::return_, "ns2:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getReadMessageFromClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getReadMessageFromClientResponse, SOAP_TYPE_ns2__getReadMessageFromClientResponse, sizeof(ns2__getReadMessageFromClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getReadMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getReadMessageFromClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getReadMessageFromClientResponse *p;
	size_t k = sizeof(ns2__getReadMessageFromClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getReadMessageFromClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getReadMessageFromClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getReadMessageFromClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getReadMessageFromClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getReadMessageFromClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getReadMessageFromClientResponse(soap, tag ? tag : "ns2:getReadMessageFromClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getReadMessageFromClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getReadMessageFromClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getReadMessageFromClientResponse * SOAP_FMAC4 soap_get_ns2__getReadMessageFromClientResponse(struct soap *soap, ns2__getReadMessageFromClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getReadMessageFromClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getReadMessageFromClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getReadMessageFromClient::arg0 = NULL;
}

void ns2__getReadMessageFromClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__shop(soap, &this->ns2__getReadMessageFromClient::arg0);
#endif
}

int ns2__getReadMessageFromClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getReadMessageFromClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getReadMessageFromClient(struct soap *soap, const char *tag, int id, const ns2__getReadMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getReadMessageFromClient), type))
		return soap->error;
	if (soap_out_PointerTons2__shop(soap, "arg0", -1, &a->ns2__getReadMessageFromClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getReadMessageFromClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getReadMessageFromClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getReadMessageFromClient * SOAP_FMAC4 soap_in_ns2__getReadMessageFromClient(struct soap *soap, const char *tag, ns2__getReadMessageFromClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getReadMessageFromClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getReadMessageFromClient, sizeof(ns2__getReadMessageFromClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getReadMessageFromClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getReadMessageFromClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__shop(soap, "arg0", &a->ns2__getReadMessageFromClient::arg0, "ns2:shop"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getReadMessageFromClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getReadMessageFromClient, SOAP_TYPE_ns2__getReadMessageFromClient, sizeof(ns2__getReadMessageFromClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getReadMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getReadMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getReadMessageFromClient *p;
	size_t k = sizeof(ns2__getReadMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getReadMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getReadMessageFromClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getReadMessageFromClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getReadMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getReadMessageFromClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getReadMessageFromClient(soap, tag ? tag : "ns2:getReadMessageFromClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getReadMessageFromClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getReadMessageFromClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getReadMessageFromClient * SOAP_FMAC4 soap_get_ns2__getReadMessageFromClient(struct soap *soap, ns2__getReadMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getReadMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderListHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderListHistoryResponse::return_);
}

void ns2__getOrderListHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderListHistoryResponse::return_);
#endif
}

int ns2__getOrderListHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderListHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderListHistoryResponse(struct soap *soap, const char *tag, int id, const ns2__getOrderListHistoryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderListHistoryResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__order(soap, "return", -1, &a->ns2__getOrderListHistoryResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderListHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderListHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderListHistoryResponse * SOAP_FMAC4 soap_in_ns2__getOrderListHistoryResponse(struct soap *soap, const char *tag, ns2__getOrderListHistoryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderListHistoryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderListHistoryResponse, sizeof(ns2__getOrderListHistoryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderListHistoryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderListHistoryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__order(soap, "return", &a->ns2__getOrderListHistoryResponse::return_, "ns2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderListHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderListHistoryResponse, SOAP_TYPE_ns2__getOrderListHistoryResponse, sizeof(ns2__getOrderListHistoryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderListHistoryResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderListHistoryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderListHistoryResponse *p;
	size_t k = sizeof(ns2__getOrderListHistoryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderListHistoryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderListHistoryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderListHistoryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderListHistoryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderListHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderListHistoryResponse(soap, tag ? tag : "ns2:getOrderListHistoryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderListHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderListHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderListHistoryResponse * SOAP_FMAC4 soap_get_ns2__getOrderListHistoryResponse(struct soap *soap, ns2__getOrderListHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderListHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderListHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__getOrderListHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__getOrderListHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderListHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderListHistory(struct soap *soap, const char *tag, int id, const ns2__getOrderListHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderListHistory), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderListHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderListHistory(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderListHistory * SOAP_FMAC4 soap_in_ns2__getOrderListHistory(struct soap *soap, const char *tag, ns2__getOrderListHistory *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderListHistory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderListHistory, sizeof(ns2__getOrderListHistory), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderListHistory)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderListHistory *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderListHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderListHistory, SOAP_TYPE_ns2__getOrderListHistory, sizeof(ns2__getOrderListHistory), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderListHistory * SOAP_FMAC2 soap_instantiate_ns2__getOrderListHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderListHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderListHistory *p;
	size_t k = sizeof(ns2__getOrderListHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderListHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderListHistory);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderListHistory, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderListHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderListHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderListHistory(soap, tag ? tag : "ns2:getOrderListHistory", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderListHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderListHistory(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderListHistory * SOAP_FMAC4 soap_get_ns2__getOrderListHistory(struct soap *soap, ns2__getOrderListHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderListHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__product(soap, &this->ns2__getProductListResponse::return_);
}

void ns2__getProductListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__product(soap, &this->ns2__getProductListResponse::return_);
#endif
}

int ns2__getProductListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductListResponse(struct soap *soap, const char *tag, int id, const ns2__getProductListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__product(soap, "return", -1, &a->ns2__getProductListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductListResponse * SOAP_FMAC4 soap_in_ns2__getProductListResponse(struct soap *soap, const char *tag, ns2__getProductListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductListResponse, sizeof(ns2__getProductListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__product(soap, "return", &a->ns2__getProductListResponse::return_, "ns2:product"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductListResponse, SOAP_TYPE_ns2__getProductListResponse, sizeof(ns2__getProductListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductListResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductListResponse *p;
	size_t k = sizeof(ns2__getProductListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductListResponse(soap, tag ? tag : "ns2:getProductListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductListResponse * SOAP_FMAC4 soap_get_ns2__getProductListResponse(struct soap *soap, ns2__getProductListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__getProductList::arg0);
	soap_default_int(soap, &this->ns2__getProductList::arg1);
}

void ns2__getProductList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__getProductList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductList(struct soap *soap, const char *tag, int id, const ns2__getProductList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductList), type))
		return soap->error;
	if (soap_out_int(soap, "arg0", -1, &a->ns2__getProductList::arg0, ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &a->ns2__getProductList::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductList * SOAP_FMAC4 soap_in_ns2__getProductList(struct soap *soap, const char *tag, ns2__getProductList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductList, sizeof(ns2__getProductList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg0", &a->ns2__getProductList::arg0, "xsd:int"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg1", &a->ns2__getProductList::arg1, "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0 || soap_flag_arg11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__getProductList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductList, SOAP_TYPE_ns2__getProductList, sizeof(ns2__getProductList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductList * SOAP_FMAC2 soap_instantiate_ns2__getProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductList *p;
	size_t k = sizeof(ns2__getProductList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductList(soap, tag ? tag : "ns2:getProductList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductList * SOAP_FMAC4 soap_get_ns2__getProductList(struct soap *soap, ns2__getProductList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteShopByNameAndPwdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteShopByNameAndPwdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteShopByNameAndPwdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteShopByNameAndPwdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteShopByNameAndPwdResponse(struct soap *soap, const char *tag, int id, const ns2__deleteShopByNameAndPwdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteShopByNameAndPwdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteShopByNameAndPwdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteShopByNameAndPwdResponse * SOAP_FMAC4 soap_in_ns2__deleteShopByNameAndPwdResponse(struct soap *soap, const char *tag, ns2__deleteShopByNameAndPwdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteShopByNameAndPwdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse, sizeof(ns2__deleteShopByNameAndPwdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteShopByNameAndPwdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteShopByNameAndPwdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse, SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse, sizeof(ns2__deleteShopByNameAndPwdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteShopByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteShopByNameAndPwdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteShopByNameAndPwdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteShopByNameAndPwdResponse *p;
	size_t k = sizeof(ns2__deleteShopByNameAndPwdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteShopByNameAndPwdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteShopByNameAndPwdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteShopByNameAndPwdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteShopByNameAndPwdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteShopByNameAndPwdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteShopByNameAndPwdResponse(soap, tag ? tag : "ns2:deleteShopByNameAndPwdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteShopByNameAndPwdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteShopByNameAndPwdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteShopByNameAndPwdResponse * SOAP_FMAC4 soap_get_ns2__deleteShopByNameAndPwdResponse(struct soap *soap, ns2__deleteShopByNameAndPwdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteShopByNameAndPwdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteShopByNameAndPwd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteShopByNameAndPwd::arg0 = NULL;
	this->ns2__deleteShopByNameAndPwd::arg1 = NULL;
}

void ns2__deleteShopByNameAndPwd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteShopByNameAndPwd::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteShopByNameAndPwd::arg1);
#endif
}

int ns2__deleteShopByNameAndPwd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteShopByNameAndPwd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteShopByNameAndPwd(struct soap *soap, const char *tag, int id, const ns2__deleteShopByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteShopByNameAndPwd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__deleteShopByNameAndPwd::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->ns2__deleteShopByNameAndPwd::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteShopByNameAndPwd::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteShopByNameAndPwd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteShopByNameAndPwd * SOAP_FMAC4 soap_in_ns2__deleteShopByNameAndPwd(struct soap *soap, const char *tag, ns2__deleteShopByNameAndPwd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteShopByNameAndPwd*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteShopByNameAndPwd, sizeof(ns2__deleteShopByNameAndPwd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteShopByNameAndPwd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteShopByNameAndPwd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__deleteShopByNameAndPwd::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->ns2__deleteShopByNameAndPwd::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteShopByNameAndPwd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteShopByNameAndPwd, SOAP_TYPE_ns2__deleteShopByNameAndPwd, sizeof(ns2__deleteShopByNameAndPwd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteShopByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__deleteShopByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteShopByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteShopByNameAndPwd *p;
	size_t k = sizeof(ns2__deleteShopByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteShopByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteShopByNameAndPwd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteShopByNameAndPwd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteShopByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteShopByNameAndPwd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteShopByNameAndPwd(soap, tag ? tag : "ns2:deleteShopByNameAndPwd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteShopByNameAndPwd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteShopByNameAndPwd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteShopByNameAndPwd * SOAP_FMAC4 soap_get_ns2__deleteShopByNameAndPwd(struct soap *soap, ns2__deleteShopByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteShopByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__addOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__addOrderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__addOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addOrderResponse(struct soap *soap, const char *tag, int id, const ns2__addOrderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addOrderResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__addOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__addOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addOrderResponse * SOAP_FMAC4 soap_in_ns2__addOrderResponse(struct soap *soap, const char *tag, ns2__addOrderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addOrderResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addOrderResponse, sizeof(ns2__addOrderResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__addOrderResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__addOrderResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addOrderResponse, SOAP_TYPE_ns2__addOrderResponse, sizeof(ns2__addOrderResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__addOrderResponse * SOAP_FMAC2 soap_instantiate_ns2__addOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addOrderResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__addOrderResponse *p;
	size_t k = sizeof(ns2__addOrderResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__addOrderResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__addOrderResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__addOrderResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__addOrderResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__addOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__addOrderResponse(soap, tag ? tag : "ns2:addOrderResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addOrderResponse * SOAP_FMAC4 soap_get_ns2__addOrderResponse(struct soap *soap, ns2__addOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__addOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__addOrder::arg0 = NULL;
}

void ns2__addOrder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__order(soap, &this->ns2__addOrder::arg0);
#endif
}

int ns2__addOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addOrder(struct soap *soap, const char *tag, int id, const ns2__addOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addOrder), type))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg0", -1, &a->ns2__addOrder::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__addOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__addOrder(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addOrder * SOAP_FMAC4 soap_in_ns2__addOrder(struct soap *soap, const char *tag, ns2__addOrder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addOrder*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addOrder, sizeof(ns2__addOrder), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__addOrder)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__addOrder *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg0", &a->ns2__addOrder::arg0, "ns2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addOrder, SOAP_TYPE_ns2__addOrder, sizeof(ns2__addOrder), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__addOrder * SOAP_FMAC2 soap_instantiate_ns2__addOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__addOrder *p;
	size_t k = sizeof(ns2__addOrder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__addOrder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__addOrder);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__addOrder, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__addOrder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__addOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__addOrder(soap, tag ? tag : "ns2:addOrder", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addOrder(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addOrder * SOAP_FMAC4 soap_get_ns2__addOrder(struct soap *soap, ns2__addOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getMessageFromClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getMessageFromClientResponse::return_);
}

void ns2__getMessageFromClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getMessageFromClientResponse::return_);
#endif
}

int ns2__getMessageFromClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMessageFromClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMessageFromClientResponse(struct soap *soap, const char *tag, int id, const ns2__getMessageFromClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMessageFromClientResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__message(soap, "return", -1, &a->ns2__getMessageFromClientResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getMessageFromClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getMessageFromClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMessageFromClientResponse * SOAP_FMAC4 soap_in_ns2__getMessageFromClientResponse(struct soap *soap, const char *tag, ns2__getMessageFromClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMessageFromClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMessageFromClientResponse, sizeof(ns2__getMessageFromClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getMessageFromClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getMessageFromClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__message(soap, "return", &a->ns2__getMessageFromClientResponse::return_, "ns2:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMessageFromClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMessageFromClientResponse, SOAP_TYPE_ns2__getMessageFromClientResponse, sizeof(ns2__getMessageFromClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMessageFromClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getMessageFromClientResponse *p;
	size_t k = sizeof(ns2__getMessageFromClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getMessageFromClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getMessageFromClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getMessageFromClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getMessageFromClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getMessageFromClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getMessageFromClientResponse(soap, tag ? tag : "ns2:getMessageFromClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMessageFromClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMessageFromClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMessageFromClientResponse * SOAP_FMAC4 soap_get_ns2__getMessageFromClientResponse(struct soap *soap, ns2__getMessageFromClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMessageFromClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getMessageFromClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getMessageFromClient::arg0 = NULL;
}

void ns2__getMessageFromClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__shop(soap, &this->ns2__getMessageFromClient::arg0);
#endif
}

int ns2__getMessageFromClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getMessageFromClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMessageFromClient(struct soap *soap, const char *tag, int id, const ns2__getMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMessageFromClient), type))
		return soap->error;
	if (soap_out_PointerTons2__shop(soap, "arg0", -1, &a->ns2__getMessageFromClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getMessageFromClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getMessageFromClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getMessageFromClient * SOAP_FMAC4 soap_in_ns2__getMessageFromClient(struct soap *soap, const char *tag, ns2__getMessageFromClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getMessageFromClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMessageFromClient, sizeof(ns2__getMessageFromClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getMessageFromClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getMessageFromClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__shop(soap, "arg0", &a->ns2__getMessageFromClient::arg0, "ns2:shop"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getMessageFromClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMessageFromClient, SOAP_TYPE_ns2__getMessageFromClient, sizeof(ns2__getMessageFromClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getMessageFromClient *p;
	size_t k = sizeof(ns2__getMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getMessageFromClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getMessageFromClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getMessageFromClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getMessageFromClient(soap, tag ? tag : "ns2:getMessageFromClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getMessageFromClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getMessageFromClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getMessageFromClient * SOAP_FMAC4 soap_get_ns2__getMessageFromClient(struct soap *soap, ns2__getMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateProductByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__updateProductByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__updateProductByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateProductByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateProductByInfoResponse(struct soap *soap, const char *tag, int id, const ns2__updateProductByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateProductByInfoResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateProductByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateProductByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateProductByInfoResponse * SOAP_FMAC4 soap_in_ns2__updateProductByInfoResponse(struct soap *soap, const char *tag, ns2__updateProductByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateProductByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateProductByInfoResponse, sizeof(ns2__updateProductByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateProductByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateProductByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateProductByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateProductByInfoResponse, SOAP_TYPE_ns2__updateProductByInfoResponse, sizeof(ns2__updateProductByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateProductByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__updateProductByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateProductByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateProductByInfoResponse *p;
	size_t k = sizeof(ns2__updateProductByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateProductByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateProductByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateProductByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateProductByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateProductByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateProductByInfoResponse(soap, tag ? tag : "ns2:updateProductByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateProductByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateProductByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateProductByInfoResponse * SOAP_FMAC4 soap_get_ns2__updateProductByInfoResponse(struct soap *soap, ns2__updateProductByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateProductByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateProductByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__updateProductByInfo::arg0 = NULL;
}

void ns2__updateProductByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__product(soap, &this->ns2__updateProductByInfo::arg0);
#endif
}

int ns2__updateProductByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateProductByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateProductByInfo(struct soap *soap, const char *tag, int id, const ns2__updateProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateProductByInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__product(soap, "arg0", -1, &a->ns2__updateProductByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateProductByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateProductByInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateProductByInfo * SOAP_FMAC4 soap_in_ns2__updateProductByInfo(struct soap *soap, const char *tag, ns2__updateProductByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateProductByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateProductByInfo, sizeof(ns2__updateProductByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateProductByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateProductByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__product(soap, "arg0", &a->ns2__updateProductByInfo::arg0, "ns2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateProductByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateProductByInfo, SOAP_TYPE_ns2__updateProductByInfo, sizeof(ns2__updateProductByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateProductByInfo * SOAP_FMAC2 soap_instantiate_ns2__updateProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateProductByInfo *p;
	size_t k = sizeof(ns2__updateProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateProductByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateProductByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateProductByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateProductByInfo(soap, tag ? tag : "ns2:updateProductByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateProductByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateProductByInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateProductByInfo * SOAP_FMAC4 soap_get_ns2__updateProductByInfo(struct soap *soap, ns2__updateProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getUnreadMessageFromClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getUnreadMessageFromClientResponse::return_);
}

void ns2__getUnreadMessageFromClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getUnreadMessageFromClientResponse::return_);
#endif
}

int ns2__getUnreadMessageFromClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getUnreadMessageFromClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getUnreadMessageFromClientResponse(struct soap *soap, const char *tag, int id, const ns2__getUnreadMessageFromClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getUnreadMessageFromClientResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__message(soap, "return", -1, &a->ns2__getUnreadMessageFromClientResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getUnreadMessageFromClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getUnreadMessageFromClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromClientResponse * SOAP_FMAC4 soap_in_ns2__getUnreadMessageFromClientResponse(struct soap *soap, const char *tag, ns2__getUnreadMessageFromClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getUnreadMessageFromClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getUnreadMessageFromClientResponse, sizeof(ns2__getUnreadMessageFromClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getUnreadMessageFromClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getUnreadMessageFromClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__message(soap, "return", &a->ns2__getUnreadMessageFromClientResponse::return_, "ns2:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getUnreadMessageFromClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getUnreadMessageFromClientResponse, SOAP_TYPE_ns2__getUnreadMessageFromClientResponse, sizeof(ns2__getUnreadMessageFromClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getUnreadMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getUnreadMessageFromClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getUnreadMessageFromClientResponse *p;
	size_t k = sizeof(ns2__getUnreadMessageFromClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getUnreadMessageFromClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getUnreadMessageFromClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getUnreadMessageFromClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getUnreadMessageFromClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getUnreadMessageFromClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getUnreadMessageFromClientResponse(soap, tag ? tag : "ns2:getUnreadMessageFromClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getUnreadMessageFromClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getUnreadMessageFromClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromClientResponse * SOAP_FMAC4 soap_get_ns2__getUnreadMessageFromClientResponse(struct soap *soap, ns2__getUnreadMessageFromClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getUnreadMessageFromClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getUnreadMessageFromClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getUnreadMessageFromClient::arg0 = NULL;
}

void ns2__getUnreadMessageFromClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__shop(soap, &this->ns2__getUnreadMessageFromClient::arg0);
#endif
}

int ns2__getUnreadMessageFromClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getUnreadMessageFromClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getUnreadMessageFromClient(struct soap *soap, const char *tag, int id, const ns2__getUnreadMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getUnreadMessageFromClient), type))
		return soap->error;
	if (soap_out_PointerTons2__shop(soap, "arg0", -1, &a->ns2__getUnreadMessageFromClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getUnreadMessageFromClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getUnreadMessageFromClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromClient * SOAP_FMAC4 soap_in_ns2__getUnreadMessageFromClient(struct soap *soap, const char *tag, ns2__getUnreadMessageFromClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getUnreadMessageFromClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getUnreadMessageFromClient, sizeof(ns2__getUnreadMessageFromClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getUnreadMessageFromClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getUnreadMessageFromClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__shop(soap, "arg0", &a->ns2__getUnreadMessageFromClient::arg0, "ns2:shop"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getUnreadMessageFromClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getUnreadMessageFromClient, SOAP_TYPE_ns2__getUnreadMessageFromClient, sizeof(ns2__getUnreadMessageFromClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getUnreadMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__getUnreadMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getUnreadMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getUnreadMessageFromClient *p;
	size_t k = sizeof(ns2__getUnreadMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getUnreadMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getUnreadMessageFromClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getUnreadMessageFromClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getUnreadMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getUnreadMessageFromClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getUnreadMessageFromClient(soap, tag ? tag : "ns2:getUnreadMessageFromClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getUnreadMessageFromClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getUnreadMessageFromClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getUnreadMessageFromClient * SOAP_FMAC4 soap_get_ns2__getUnreadMessageFromClient(struct soap *soap, ns2__getUnreadMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getUnreadMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateMessageFromClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__updateMessageFromClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__updateMessageFromClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateMessageFromClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateMessageFromClientResponse(struct soap *soap, const char *tag, int id, const ns2__updateMessageFromClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateMessageFromClientResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateMessageFromClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateMessageFromClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateMessageFromClientResponse * SOAP_FMAC4 soap_in_ns2__updateMessageFromClientResponse(struct soap *soap, const char *tag, ns2__updateMessageFromClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateMessageFromClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateMessageFromClientResponse, sizeof(ns2__updateMessageFromClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateMessageFromClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateMessageFromClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateMessageFromClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateMessageFromClientResponse, SOAP_TYPE_ns2__updateMessageFromClientResponse, sizeof(ns2__updateMessageFromClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateMessageFromClientResponse * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateMessageFromClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateMessageFromClientResponse *p;
	size_t k = sizeof(ns2__updateMessageFromClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateMessageFromClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateMessageFromClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateMessageFromClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateMessageFromClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateMessageFromClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateMessageFromClientResponse(soap, tag ? tag : "ns2:updateMessageFromClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateMessageFromClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateMessageFromClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateMessageFromClientResponse * SOAP_FMAC4 soap_get_ns2__updateMessageFromClientResponse(struct soap *soap, ns2__updateMessageFromClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateMessageFromClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateMessageFromClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__updateMessageFromClient::arg0 = NULL;
	soap_default_int(soap, &this->ns2__updateMessageFromClient::arg1);
}

void ns2__updateMessageFromClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__message(soap, &this->ns2__updateMessageFromClient::arg0);
#endif
}

int ns2__updateMessageFromClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateMessageFromClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateMessageFromClient(struct soap *soap, const char *tag, int id, const ns2__updateMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateMessageFromClient), type))
		return soap->error;
	if (soap_out_PointerTons2__message(soap, "arg0", -1, &a->ns2__updateMessageFromClient::arg0, ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &a->ns2__updateMessageFromClient::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateMessageFromClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateMessageFromClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateMessageFromClient * SOAP_FMAC4 soap_in_ns2__updateMessageFromClient(struct soap *soap, const char *tag, ns2__updateMessageFromClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateMessageFromClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateMessageFromClient, sizeof(ns2__updateMessageFromClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateMessageFromClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateMessageFromClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__message(soap, "arg0", &a->ns2__updateMessageFromClient::arg0, "ns2:message"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg1", &a->ns2__updateMessageFromClient::arg1, "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__updateMessageFromClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateMessageFromClient, SOAP_TYPE_ns2__updateMessageFromClient, sizeof(ns2__updateMessageFromClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateMessageFromClient * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateMessageFromClient *p;
	size_t k = sizeof(ns2__updateMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateMessageFromClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateMessageFromClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateMessageFromClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateMessageFromClient(soap, tag ? tag : "ns2:updateMessageFromClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateMessageFromClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateMessageFromClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateMessageFromClient * SOAP_FMAC4 soap_get_ns2__updateMessageFromClient(struct soap *soap, ns2__updateMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__purchaseProductResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__purchaseProductResponse::return_ = NULL;
}

void ns2__purchaseProductResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__purchaseProductResponse::return_);
#endif
}

int ns2__purchaseProductResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__purchaseProductResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__purchaseProductResponse(struct soap *soap, const char *tag, int id, const ns2__purchaseProductResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__purchaseProductResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &a->ns2__purchaseProductResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__purchaseProductResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__purchaseProductResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__purchaseProductResponse * SOAP_FMAC4 soap_in_ns2__purchaseProductResponse(struct soap *soap, const char *tag, ns2__purchaseProductResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__purchaseProductResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__purchaseProductResponse, sizeof(ns2__purchaseProductResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__purchaseProductResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__purchaseProductResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "return", &a->ns2__purchaseProductResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__purchaseProductResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__purchaseProductResponse, SOAP_TYPE_ns2__purchaseProductResponse, sizeof(ns2__purchaseProductResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__purchaseProductResponse * SOAP_FMAC2 soap_instantiate_ns2__purchaseProductResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__purchaseProductResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__purchaseProductResponse *p;
	size_t k = sizeof(ns2__purchaseProductResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__purchaseProductResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__purchaseProductResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__purchaseProductResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__purchaseProductResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__purchaseProductResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__purchaseProductResponse(soap, tag ? tag : "ns2:purchaseProductResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__purchaseProductResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__purchaseProductResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__purchaseProductResponse * SOAP_FMAC4 soap_get_ns2__purchaseProductResponse(struct soap *soap, ns2__purchaseProductResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__purchaseProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__purchaseProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__purchaseProduct::arg0 = NULL;
}

void ns2__purchaseProduct::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__order(soap, &this->ns2__purchaseProduct::arg0);
#endif
}

int ns2__purchaseProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__purchaseProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__purchaseProduct(struct soap *soap, const char *tag, int id, const ns2__purchaseProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__purchaseProduct), type))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg0", -1, &a->ns2__purchaseProduct::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__purchaseProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__purchaseProduct(soap, tag, this, type);
}

SOAP_FMAC3 ns2__purchaseProduct * SOAP_FMAC4 soap_in_ns2__purchaseProduct(struct soap *soap, const char *tag, ns2__purchaseProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__purchaseProduct*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__purchaseProduct, sizeof(ns2__purchaseProduct), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__purchaseProduct)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__purchaseProduct *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg0", &a->ns2__purchaseProduct::arg0, "ns2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__purchaseProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__purchaseProduct, SOAP_TYPE_ns2__purchaseProduct, sizeof(ns2__purchaseProduct), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__purchaseProduct * SOAP_FMAC2 soap_instantiate_ns2__purchaseProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__purchaseProduct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__purchaseProduct *p;
	size_t k = sizeof(ns2__purchaseProduct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__purchaseProduct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__purchaseProduct);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__purchaseProduct, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__purchaseProduct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__purchaseProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__purchaseProduct(soap, tag ? tag : "ns2:purchaseProduct", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__purchaseProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__purchaseProduct(soap, this, tag, type);
}

SOAP_FMAC3 ns2__purchaseProduct * SOAP_FMAC4 soap_get_ns2__purchaseProduct(struct soap *soap, ns2__purchaseProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__purchaseProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getClientListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__client(soap, &this->ns2__getClientListResponse::return_);
}

void ns2__getClientListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__client(soap, &this->ns2__getClientListResponse::return_);
#endif
}

int ns2__getClientListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClientListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClientListResponse(struct soap *soap, const char *tag, int id, const ns2__getClientListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClientListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__client(soap, "return", -1, &a->ns2__getClientListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getClientListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getClientListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClientListResponse * SOAP_FMAC4 soap_in_ns2__getClientListResponse(struct soap *soap, const char *tag, ns2__getClientListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClientListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClientListResponse, sizeof(ns2__getClientListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getClientListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getClientListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__client(soap, "return", &a->ns2__getClientListResponse::return_, "ns2:client"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClientListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClientListResponse, SOAP_TYPE_ns2__getClientListResponse, sizeof(ns2__getClientListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getClientListResponse * SOAP_FMAC2 soap_instantiate_ns2__getClientListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClientListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getClientListResponse *p;
	size_t k = sizeof(ns2__getClientListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getClientListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getClientListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getClientListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getClientListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getClientListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getClientListResponse(soap, tag ? tag : "ns2:getClientListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClientListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClientListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClientListResponse * SOAP_FMAC4 soap_get_ns2__getClientListResponse(struct soap *soap, ns2__getClientListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClientListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getClientList::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__getClientList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__getClientList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getClientList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getClientList(struct soap *soap, const char *tag, int id, const ns2__getClientList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getClientList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getClientList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getClientList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getClientList * SOAP_FMAC4 soap_in_ns2__getClientList(struct soap *soap, const char *tag, ns2__getClientList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getClientList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getClientList, sizeof(ns2__getClientList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getClientList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getClientList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getClientList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getClientList, SOAP_TYPE_ns2__getClientList, sizeof(ns2__getClientList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getClientList * SOAP_FMAC2 soap_instantiate_ns2__getClientList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getClientList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getClientList *p;
	size_t k = sizeof(ns2__getClientList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getClientList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getClientList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getClientList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getClientList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getClientList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getClientList(soap, tag ? tag : "ns2:getClientList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getClientList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getClientList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getClientList * SOAP_FMAC4 soap_get_ns2__getClientList(struct soap *soap, ns2__getClientList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getClientList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__productType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__productType::typeId);
	this->ns2__productType::typeName = NULL;
	this->ns2__productType::typeProduct = NULL;
	soap_default_int(soap, &this->ns2__productType::typeProductId);
}

void ns2__productType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__productType::typeName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__productType::typeProduct);
#endif
}

int ns2__productType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__productType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__productType(struct soap *soap, const char *tag, int id, const ns2__productType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__productType), type))
		return soap->error;
	if (soap_out_int(soap, "typeId", -1, &a->ns2__productType::typeId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "typeName", -1, &a->ns2__productType::typeName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "typeProduct", -1, &a->ns2__productType::typeProduct, ""))
		return soap->error;
	if (soap_out_int(soap, "typeProductId", -1, &a->ns2__productType::typeProductId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__productType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__productType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__productType * SOAP_FMAC4 soap_in_ns2__productType(struct soap *soap, const char *tag, ns2__productType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__productType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__productType, sizeof(ns2__productType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__productType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__productType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_typeId1 = 1;
	size_t soap_flag_typeName1 = 1;
	size_t soap_flag_typeProduct1 = 1;
	size_t soap_flag_typeProductId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_typeId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "typeId", &a->ns2__productType::typeId, "xsd:int"))
				{	soap_flag_typeId1--;
					continue;
				}
			}
			if (soap_flag_typeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "typeName", &a->ns2__productType::typeName, "xsd:string"))
				{	soap_flag_typeName1--;
					continue;
				}
			}
			if (soap_flag_typeProduct1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "typeProduct", &a->ns2__productType::typeProduct, "xsd:string"))
				{	soap_flag_typeProduct1--;
					continue;
				}
			}
			if (soap_flag_typeProductId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "typeProductId", &a->ns2__productType::typeProductId, "xsd:int"))
				{	soap_flag_typeProductId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_typeId1 > 0 || soap_flag_typeProductId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__productType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__productType, SOAP_TYPE_ns2__productType, sizeof(ns2__productType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__productType * SOAP_FMAC2 soap_instantiate_ns2__productType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__productType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__productType *p;
	size_t k = sizeof(ns2__productType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__productType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__productType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__productType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__productType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__productType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__productType(soap, tag ? tag : "ns2:productType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__productType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__productType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__productType * SOAP_FMAC4 soap_get_ns2__productType(struct soap *soap, ns2__productType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__productType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductTypeByProNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__productType(soap, &this->ns2__getProductTypeByProNameResponse::return_);
}

void ns2__getProductTypeByProNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__productType(soap, &this->ns2__getProductTypeByProNameResponse::return_);
#endif
}

int ns2__getProductTypeByProNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductTypeByProNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductTypeByProNameResponse(struct soap *soap, const char *tag, int id, const ns2__getProductTypeByProNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductTypeByProNameResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__productType(soap, "return", -1, &a->ns2__getProductTypeByProNameResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductTypeByProNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductTypeByProNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductTypeByProNameResponse * SOAP_FMAC4 soap_in_ns2__getProductTypeByProNameResponse(struct soap *soap, const char *tag, ns2__getProductTypeByProNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductTypeByProNameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductTypeByProNameResponse, sizeof(ns2__getProductTypeByProNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductTypeByProNameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductTypeByProNameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__productType(soap, "return", &a->ns2__getProductTypeByProNameResponse::return_, "ns2:productType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductTypeByProNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductTypeByProNameResponse, SOAP_TYPE_ns2__getProductTypeByProNameResponse, sizeof(ns2__getProductTypeByProNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductTypeByProNameResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductTypeByProNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductTypeByProNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductTypeByProNameResponse *p;
	size_t k = sizeof(ns2__getProductTypeByProNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductTypeByProNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductTypeByProNameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductTypeByProNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductTypeByProNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductTypeByProNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductTypeByProNameResponse(soap, tag ? tag : "ns2:getProductTypeByProNameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductTypeByProNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductTypeByProNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductTypeByProNameResponse * SOAP_FMAC4 soap_get_ns2__getProductTypeByProNameResponse(struct soap *soap, ns2__getProductTypeByProNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductTypeByProNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductTypeByProName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getProductTypeByProName::arg0 = NULL;
}

void ns2__getProductTypeByProName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getProductTypeByProName::arg0);
#endif
}

int ns2__getProductTypeByProName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductTypeByProName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductTypeByProName(struct soap *soap, const char *tag, int id, const ns2__getProductTypeByProName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductTypeByProName), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getProductTypeByProName::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductTypeByProName::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductTypeByProName(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductTypeByProName * SOAP_FMAC4 soap_in_ns2__getProductTypeByProName(struct soap *soap, const char *tag, ns2__getProductTypeByProName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductTypeByProName*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductTypeByProName, sizeof(ns2__getProductTypeByProName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductTypeByProName)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductTypeByProName *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getProductTypeByProName::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductTypeByProName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductTypeByProName, SOAP_TYPE_ns2__getProductTypeByProName, sizeof(ns2__getProductTypeByProName), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductTypeByProName * SOAP_FMAC2 soap_instantiate_ns2__getProductTypeByProName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductTypeByProName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductTypeByProName *p;
	size_t k = sizeof(ns2__getProductTypeByProName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductTypeByProName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductTypeByProName);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductTypeByProName, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductTypeByProName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductTypeByProName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductTypeByProName(soap, tag ? tag : "ns2:getProductTypeByProName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductTypeByProName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductTypeByProName(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductTypeByProName * SOAP_FMAC4 soap_get_ns2__getProductTypeByProName(struct soap *soap, ns2__getProductTypeByProName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductTypeByProName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateMessageFromShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__updateMessageFromShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__updateMessageFromShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateMessageFromShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateMessageFromShopResponse(struct soap *soap, const char *tag, int id, const ns2__updateMessageFromShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateMessageFromShopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateMessageFromShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateMessageFromShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateMessageFromShopResponse * SOAP_FMAC4 soap_in_ns2__updateMessageFromShopResponse(struct soap *soap, const char *tag, ns2__updateMessageFromShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateMessageFromShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateMessageFromShopResponse, sizeof(ns2__updateMessageFromShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateMessageFromShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateMessageFromShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateMessageFromShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateMessageFromShopResponse, SOAP_TYPE_ns2__updateMessageFromShopResponse, sizeof(ns2__updateMessageFromShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateMessageFromShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateMessageFromShopResponse *p;
	size_t k = sizeof(ns2__updateMessageFromShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateMessageFromShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateMessageFromShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateMessageFromShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateMessageFromShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateMessageFromShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateMessageFromShopResponse(soap, tag ? tag : "ns2:updateMessageFromShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateMessageFromShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateMessageFromShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateMessageFromShopResponse * SOAP_FMAC4 soap_get_ns2__updateMessageFromShopResponse(struct soap *soap, ns2__updateMessageFromShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateMessageFromShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateMessageFromShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__updateMessageFromShop::arg0 = NULL;
	soap_default_int(soap, &this->ns2__updateMessageFromShop::arg1);
}

void ns2__updateMessageFromShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__message(soap, &this->ns2__updateMessageFromShop::arg0);
#endif
}

int ns2__updateMessageFromShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateMessageFromShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateMessageFromShop(struct soap *soap, const char *tag, int id, const ns2__updateMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateMessageFromShop), type))
		return soap->error;
	if (soap_out_PointerTons2__message(soap, "arg0", -1, &a->ns2__updateMessageFromShop::arg0, ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &a->ns2__updateMessageFromShop::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateMessageFromShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateMessageFromShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateMessageFromShop * SOAP_FMAC4 soap_in_ns2__updateMessageFromShop(struct soap *soap, const char *tag, ns2__updateMessageFromShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateMessageFromShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateMessageFromShop, sizeof(ns2__updateMessageFromShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateMessageFromShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateMessageFromShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__message(soap, "arg0", &a->ns2__updateMessageFromShop::arg0, "ns2:message"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg1", &a->ns2__updateMessageFromShop::arg1, "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__updateMessageFromShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateMessageFromShop, SOAP_TYPE_ns2__updateMessageFromShop, sizeof(ns2__updateMessageFromShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__updateMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateMessageFromShop *p;
	size_t k = sizeof(ns2__updateMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateMessageFromShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateMessageFromShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateMessageFromShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateMessageFromShop(soap, tag ? tag : "ns2:updateMessageFromShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateMessageFromShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateMessageFromShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateMessageFromShop * SOAP_FMAC4 soap_get_ns2__updateMessageFromShop(struct soap *soap, ns2__updateMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InsertShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__InsertShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__InsertShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InsertShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InsertShopResponse(struct soap *soap, const char *tag, int id, const ns2__InsertShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InsertShopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InsertShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__InsertShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InsertShopResponse * SOAP_FMAC4 soap_in_ns2__InsertShopResponse(struct soap *soap, const char *tag, ns2__InsertShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InsertShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InsertShopResponse, sizeof(ns2__InsertShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InsertShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InsertShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InsertShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InsertShopResponse, SOAP_TYPE_ns2__InsertShopResponse, sizeof(ns2__InsertShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InsertShopResponse * SOAP_FMAC2 soap_instantiate_ns2__InsertShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InsertShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InsertShopResponse *p;
	size_t k = sizeof(ns2__InsertShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__InsertShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__InsertShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__InsertShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InsertShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__InsertShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__InsertShopResponse(soap, tag ? tag : "ns2:InsertShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InsertShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InsertShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InsertShopResponse * SOAP_FMAC4 soap_get_ns2__InsertShopResponse(struct soap *soap, ns2__InsertShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InsertShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InsertShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__InsertShop::arg0 = NULL;
}

void ns2__InsertShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__shop(soap, &this->ns2__InsertShop::arg0);
#endif
}

int ns2__InsertShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InsertShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InsertShop(struct soap *soap, const char *tag, int id, const ns2__InsertShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InsertShop), type))
		return soap->error;
	if (soap_out_PointerTons2__shop(soap, "arg0", -1, &a->ns2__InsertShop::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InsertShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__InsertShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InsertShop * SOAP_FMAC4 soap_in_ns2__InsertShop(struct soap *soap, const char *tag, ns2__InsertShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InsertShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InsertShop, sizeof(ns2__InsertShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InsertShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InsertShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__shop(soap, "arg0", &a->ns2__InsertShop::arg0, "ns2:shop"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InsertShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InsertShop, SOAP_TYPE_ns2__InsertShop, sizeof(ns2__InsertShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InsertShop * SOAP_FMAC2 soap_instantiate_ns2__InsertShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InsertShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InsertShop *p;
	size_t k = sizeof(ns2__InsertShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__InsertShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__InsertShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__InsertShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InsertShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__InsertShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__InsertShop(soap, tag ? tag : "ns2:InsertShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InsertShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InsertShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InsertShop * SOAP_FMAC4 soap_get_ns2__InsertShop(struct soap *soap, ns2__InsertShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InsertShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteClientByNameAndPwdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteClientByNameAndPwdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteClientByNameAndPwdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteClientByNameAndPwdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteClientByNameAndPwdResponse(struct soap *soap, const char *tag, int id, const ns2__deleteClientByNameAndPwdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteClientByNameAndPwdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteClientByNameAndPwdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteClientByNameAndPwdResponse * SOAP_FMAC4 soap_in_ns2__deleteClientByNameAndPwdResponse(struct soap *soap, const char *tag, ns2__deleteClientByNameAndPwdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteClientByNameAndPwdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse, sizeof(ns2__deleteClientByNameAndPwdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteClientByNameAndPwdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteClientByNameAndPwdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse, SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse, sizeof(ns2__deleteClientByNameAndPwdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteClientByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteClientByNameAndPwdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteClientByNameAndPwdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteClientByNameAndPwdResponse *p;
	size_t k = sizeof(ns2__deleteClientByNameAndPwdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteClientByNameAndPwdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteClientByNameAndPwdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteClientByNameAndPwdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteClientByNameAndPwdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteClientByNameAndPwdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteClientByNameAndPwdResponse(soap, tag ? tag : "ns2:deleteClientByNameAndPwdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteClientByNameAndPwdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteClientByNameAndPwdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteClientByNameAndPwdResponse * SOAP_FMAC4 soap_get_ns2__deleteClientByNameAndPwdResponse(struct soap *soap, ns2__deleteClientByNameAndPwdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteClientByNameAndPwdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteClientByNameAndPwd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteClientByNameAndPwd::arg0 = NULL;
	this->ns2__deleteClientByNameAndPwd::arg1 = NULL;
}

void ns2__deleteClientByNameAndPwd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteClientByNameAndPwd::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteClientByNameAndPwd::arg1);
#endif
}

int ns2__deleteClientByNameAndPwd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteClientByNameAndPwd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, int id, const ns2__deleteClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteClientByNameAndPwd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__deleteClientByNameAndPwd::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->ns2__deleteClientByNameAndPwd::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteClientByNameAndPwd::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteClientByNameAndPwd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteClientByNameAndPwd * SOAP_FMAC4 soap_in_ns2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, ns2__deleteClientByNameAndPwd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteClientByNameAndPwd*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteClientByNameAndPwd, sizeof(ns2__deleteClientByNameAndPwd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteClientByNameAndPwd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteClientByNameAndPwd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__deleteClientByNameAndPwd::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->ns2__deleteClientByNameAndPwd::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteClientByNameAndPwd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteClientByNameAndPwd, SOAP_TYPE_ns2__deleteClientByNameAndPwd, sizeof(ns2__deleteClientByNameAndPwd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__deleteClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteClientByNameAndPwd *p;
	size_t k = sizeof(ns2__deleteClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteClientByNameAndPwd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteClientByNameAndPwd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteClientByNameAndPwd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteClientByNameAndPwd(soap, tag ? tag : "ns2:deleteClientByNameAndPwd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteClientByNameAndPwd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteClientByNameAndPwd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteClientByNameAndPwd * SOAP_FMAC4 soap_get_ns2__deleteClientByNameAndPwd(struct soap *soap, ns2__deleteClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteProductByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteProductByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteProductByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteProductByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteProductByInfoResponse(struct soap *soap, const char *tag, int id, const ns2__deleteProductByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteProductByInfoResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteProductByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteProductByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteProductByInfoResponse * SOAP_FMAC4 soap_in_ns2__deleteProductByInfoResponse(struct soap *soap, const char *tag, ns2__deleteProductByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteProductByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteProductByInfoResponse, sizeof(ns2__deleteProductByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteProductByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteProductByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteProductByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteProductByInfoResponse, SOAP_TYPE_ns2__deleteProductByInfoResponse, sizeof(ns2__deleteProductByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteProductByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteProductByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteProductByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteProductByInfoResponse *p;
	size_t k = sizeof(ns2__deleteProductByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteProductByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteProductByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteProductByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteProductByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteProductByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteProductByInfoResponse(soap, tag ? tag : "ns2:deleteProductByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteProductByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteProductByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteProductByInfoResponse * SOAP_FMAC4 soap_get_ns2__deleteProductByInfoResponse(struct soap *soap, ns2__deleteProductByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteProductByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteProductByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteProductByInfo::arg0 = NULL;
}

void ns2__deleteProductByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__product(soap, &this->ns2__deleteProductByInfo::arg0);
#endif
}

int ns2__deleteProductByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteProductByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteProductByInfo(struct soap *soap, const char *tag, int id, const ns2__deleteProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteProductByInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__product(soap, "arg0", -1, &a->ns2__deleteProductByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteProductByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteProductByInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteProductByInfo * SOAP_FMAC4 soap_in_ns2__deleteProductByInfo(struct soap *soap, const char *tag, ns2__deleteProductByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteProductByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteProductByInfo, sizeof(ns2__deleteProductByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteProductByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteProductByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__product(soap, "arg0", &a->ns2__deleteProductByInfo::arg0, "ns2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteProductByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteProductByInfo, SOAP_TYPE_ns2__deleteProductByInfo, sizeof(ns2__deleteProductByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteProductByInfo * SOAP_FMAC2 soap_instantiate_ns2__deleteProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteProductByInfo *p;
	size_t k = sizeof(ns2__deleteProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteProductByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteProductByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteProductByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteProductByInfo(soap, tag ? tag : "ns2:deleteProductByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteProductByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteProductByInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteProductByInfo * SOAP_FMAC4 soap_get_ns2__deleteProductByInfo(struct soap *soap, ns2__deleteProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateClientResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__updateClientResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__updateClientResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateClientResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateClientResponse(struct soap *soap, const char *tag, int id, const ns2__updateClientResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateClientResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateClientResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateClientResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateClientResponse * SOAP_FMAC4 soap_in_ns2__updateClientResponse(struct soap *soap, const char *tag, ns2__updateClientResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateClientResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateClientResponse, sizeof(ns2__updateClientResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateClientResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateClientResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateClientResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateClientResponse, SOAP_TYPE_ns2__updateClientResponse, sizeof(ns2__updateClientResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateClientResponse * SOAP_FMAC2 soap_instantiate_ns2__updateClientResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateClientResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateClientResponse *p;
	size_t k = sizeof(ns2__updateClientResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateClientResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateClientResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateClientResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateClientResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateClientResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateClientResponse(soap, tag ? tag : "ns2:updateClientResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateClientResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateClientResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateClientResponse * SOAP_FMAC4 soap_get_ns2__updateClientResponse(struct soap *soap, ns2__updateClientResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateClientResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateClient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__updateClient::arg0 = NULL;
}

void ns2__updateClient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__client(soap, &this->ns2__updateClient::arg0);
#endif
}

int ns2__updateClient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateClient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateClient(struct soap *soap, const char *tag, int id, const ns2__updateClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateClient), type))
		return soap->error;
	if (soap_out_PointerTons2__client(soap, "arg0", -1, &a->ns2__updateClient::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateClient::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateClient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateClient * SOAP_FMAC4 soap_in_ns2__updateClient(struct soap *soap, const char *tag, ns2__updateClient *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateClient*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateClient, sizeof(ns2__updateClient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateClient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateClient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__client(soap, "arg0", &a->ns2__updateClient::arg0, "ns2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateClient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateClient, SOAP_TYPE_ns2__updateClient, sizeof(ns2__updateClient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateClient * SOAP_FMAC2 soap_instantiate_ns2__updateClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateClient *p;
	size_t k = sizeof(ns2__updateClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateClient);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateClient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateClient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateClient(soap, tag ? tag : "ns2:updateClient", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateClient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateClient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateClient * SOAP_FMAC4 soap_get_ns2__updateClient(struct soap *soap, ns2__updateClient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__message::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__message::msgClientId);
	this->ns2__message::msgClientName = NULL;
	this->ns2__message::msgContent = NULL;
	soap_default_int(soap, &this->ns2__message::msgFrom);
	soap_default_int(soap, &this->ns2__message::msgId);
	soap_default_int(soap, &this->ns2__message::msgShopId);
	this->ns2__message::msgShopName = NULL;
	this->ns2__message::msgTime = NULL;
	soap_default_int(soap, &this->ns2__message::readStatus);
}

void ns2__message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__message::msgClientName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__message::msgContent);
	soap_serialize_PointerTostd__string(soap, &this->ns2__message::msgShopName);
	soap_serialize_PointerTodateTime(soap, &this->ns2__message::msgTime);
#endif
}

int ns2__message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__message(struct soap *soap, const char *tag, int id, const ns2__message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__message), type))
		return soap->error;
	if (soap_out_int(soap, "msgClientId", -1, &a->ns2__message::msgClientId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msgClientName", -1, &a->ns2__message::msgClientName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msgContent", -1, &a->ns2__message::msgContent, ""))
		return soap->error;
	if (soap_out_int(soap, "msgFrom", -1, &a->ns2__message::msgFrom, ""))
		return soap->error;
	if (soap_out_int(soap, "msgId", -1, &a->ns2__message::msgId, ""))
		return soap->error;
	if (soap_out_int(soap, "msgShopId", -1, &a->ns2__message::msgShopId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msgShopName", -1, &a->ns2__message::msgShopName, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "msgTime", -1, &a->ns2__message::msgTime, ""))
		return soap->error;
	if (soap_out_int(soap, "readStatus", -1, &a->ns2__message::readStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__message::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__message(soap, tag, this, type);
}

SOAP_FMAC3 ns2__message * SOAP_FMAC4 soap_in_ns2__message(struct soap *soap, const char *tag, ns2__message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__message, sizeof(ns2__message), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_msgClientId1 = 1;
	size_t soap_flag_msgClientName1 = 1;
	size_t soap_flag_msgContent1 = 1;
	size_t soap_flag_msgFrom1 = 1;
	size_t soap_flag_msgId1 = 1;
	size_t soap_flag_msgShopId1 = 1;
	size_t soap_flag_msgShopName1 = 1;
	size_t soap_flag_msgTime1 = 1;
	size_t soap_flag_readStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msgClientId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "msgClientId", &a->ns2__message::msgClientId, "xsd:int"))
				{	soap_flag_msgClientId1--;
					continue;
				}
			}
			if (soap_flag_msgClientName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "msgClientName", &a->ns2__message::msgClientName, "xsd:string"))
				{	soap_flag_msgClientName1--;
					continue;
				}
			}
			if (soap_flag_msgContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "msgContent", &a->ns2__message::msgContent, "xsd:string"))
				{	soap_flag_msgContent1--;
					continue;
				}
			}
			if (soap_flag_msgFrom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "msgFrom", &a->ns2__message::msgFrom, "xsd:int"))
				{	soap_flag_msgFrom1--;
					continue;
				}
			}
			if (soap_flag_msgId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "msgId", &a->ns2__message::msgId, "xsd:int"))
				{	soap_flag_msgId1--;
					continue;
				}
			}
			if (soap_flag_msgShopId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "msgShopId", &a->ns2__message::msgShopId, "xsd:int"))
				{	soap_flag_msgShopId1--;
					continue;
				}
			}
			if (soap_flag_msgShopName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "msgShopName", &a->ns2__message::msgShopName, "xsd:string"))
				{	soap_flag_msgShopName1--;
					continue;
				}
			}
			if (soap_flag_msgTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "msgTime", &a->ns2__message::msgTime, "xsd:dateTime"))
				{	soap_flag_msgTime1--;
					continue;
				}
			}
			if (soap_flag_readStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "readStatus", &a->ns2__message::readStatus, "xsd:int"))
				{	soap_flag_readStatus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msgClientId1 > 0 || soap_flag_msgFrom1 > 0 || soap_flag_msgId1 > 0 || soap_flag_msgShopId1 > 0 || soap_flag_readStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__message, SOAP_TYPE_ns2__message, sizeof(ns2__message), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__message * SOAP_FMAC2 soap_instantiate_ns2__message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__message *p;
	size_t k = sizeof(ns2__message);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__message, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__message);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__message, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__message location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__message(soap, tag ? tag : "ns2:message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__message(soap, this, tag, type);
}

SOAP_FMAC3 ns2__message * SOAP_FMAC4 soap_get_ns2__message(struct soap *soap, ns2__message *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getReadMessageFromShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getReadMessageFromShopResponse::return_);
}

void ns2__getReadMessageFromShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__message(soap, &this->ns2__getReadMessageFromShopResponse::return_);
#endif
}

int ns2__getReadMessageFromShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getReadMessageFromShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getReadMessageFromShopResponse(struct soap *soap, const char *tag, int id, const ns2__getReadMessageFromShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getReadMessageFromShopResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__message(soap, "return", -1, &a->ns2__getReadMessageFromShopResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getReadMessageFromShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getReadMessageFromShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getReadMessageFromShopResponse * SOAP_FMAC4 soap_in_ns2__getReadMessageFromShopResponse(struct soap *soap, const char *tag, ns2__getReadMessageFromShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getReadMessageFromShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getReadMessageFromShopResponse, sizeof(ns2__getReadMessageFromShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getReadMessageFromShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getReadMessageFromShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__message(soap, "return", &a->ns2__getReadMessageFromShopResponse::return_, "ns2:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getReadMessageFromShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getReadMessageFromShopResponse, SOAP_TYPE_ns2__getReadMessageFromShopResponse, sizeof(ns2__getReadMessageFromShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getReadMessageFromShopResponse * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getReadMessageFromShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getReadMessageFromShopResponse *p;
	size_t k = sizeof(ns2__getReadMessageFromShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getReadMessageFromShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getReadMessageFromShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getReadMessageFromShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getReadMessageFromShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getReadMessageFromShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getReadMessageFromShopResponse(soap, tag ? tag : "ns2:getReadMessageFromShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getReadMessageFromShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getReadMessageFromShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getReadMessageFromShopResponse * SOAP_FMAC4 soap_get_ns2__getReadMessageFromShopResponse(struct soap *soap, ns2__getReadMessageFromShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getReadMessageFromShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__client::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__client::clientBought);
	this->ns2__client::clientEmail = NULL;
	soap_default_int(soap, &this->ns2__client::clientId);
	this->ns2__client::clientImage = NULL;
	this->ns2__client::clientName = NULL;
	this->ns2__client::clientPhone = NULL;
	this->ns2__client::clientPwd = NULL;
	this->ns2__client::clientSignTime = NULL;
}

void ns2__client::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__client::clientEmail);
	soap_serialize_PointerTostd__string(soap, &this->ns2__client::clientImage);
	soap_serialize_PointerTostd__string(soap, &this->ns2__client::clientName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__client::clientPhone);
	soap_serialize_PointerTostd__string(soap, &this->ns2__client::clientPwd);
	soap_serialize_PointerTodateTime(soap, &this->ns2__client::clientSignTime);
#endif
}

int ns2__client::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__client(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__client(struct soap *soap, const char *tag, int id, const ns2__client *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__client), type))
		return soap->error;
	if (soap_out_int(soap, "clientBought", -1, &a->ns2__client::clientBought, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientEmail", -1, &a->ns2__client::clientEmail, ""))
		return soap->error;
	if (soap_out_int(soap, "clientId", -1, &a->ns2__client::clientId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientImage", -1, &a->ns2__client::clientImage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientName", -1, &a->ns2__client::clientName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientPhone", -1, &a->ns2__client::clientPhone, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientPwd", -1, &a->ns2__client::clientPwd, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "clientSignTime", -1, &a->ns2__client::clientSignTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__client::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__client(soap, tag, this, type);
}

SOAP_FMAC3 ns2__client * SOAP_FMAC4 soap_in_ns2__client(struct soap *soap, const char *tag, ns2__client *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__client*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__client, sizeof(ns2__client), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__client)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__client *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clientBought1 = 1;
	size_t soap_flag_clientEmail1 = 1;
	size_t soap_flag_clientId1 = 1;
	size_t soap_flag_clientImage1 = 1;
	size_t soap_flag_clientName1 = 1;
	size_t soap_flag_clientPhone1 = 1;
	size_t soap_flag_clientPwd1 = 1;
	size_t soap_flag_clientSignTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientBought1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "clientBought", &a->ns2__client::clientBought, "xsd:int"))
				{	soap_flag_clientBought1--;
					continue;
				}
			}
			if (soap_flag_clientEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientEmail", &a->ns2__client::clientEmail, "xsd:string"))
				{	soap_flag_clientEmail1--;
					continue;
				}
			}
			if (soap_flag_clientId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "clientId", &a->ns2__client::clientId, "xsd:int"))
				{	soap_flag_clientId1--;
					continue;
				}
			}
			if (soap_flag_clientImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientImage", &a->ns2__client::clientImage, "xsd:string"))
				{	soap_flag_clientImage1--;
					continue;
				}
			}
			if (soap_flag_clientName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientName", &a->ns2__client::clientName, "xsd:string"))
				{	soap_flag_clientName1--;
					continue;
				}
			}
			if (soap_flag_clientPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientPhone", &a->ns2__client::clientPhone, "xsd:string"))
				{	soap_flag_clientPhone1--;
					continue;
				}
			}
			if (soap_flag_clientPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "clientPwd", &a->ns2__client::clientPwd, "xsd:string"))
				{	soap_flag_clientPwd1--;
					continue;
				}
			}
			if (soap_flag_clientSignTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "clientSignTime", &a->ns2__client::clientSignTime, "xsd:dateTime"))
				{	soap_flag_clientSignTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clientBought1 > 0 || soap_flag_clientId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__client *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__client, SOAP_TYPE_ns2__client, sizeof(ns2__client), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__client * SOAP_FMAC2 soap_instantiate_ns2__client(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__client(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__client *p;
	size_t k = sizeof(ns2__client);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__client, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__client);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__client, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__client location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__client::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__client(soap, tag ? tag : "ns2:client", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__client::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__client(soap, this, tag, type);
}

SOAP_FMAC3 ns2__client * SOAP_FMAC4 soap_get_ns2__client(struct soap *soap, ns2__client *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__client(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getReadMessageFromShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getReadMessageFromShop::arg0 = NULL;
}

void ns2__getReadMessageFromShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__client(soap, &this->ns2__getReadMessageFromShop::arg0);
#endif
}

int ns2__getReadMessageFromShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getReadMessageFromShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getReadMessageFromShop(struct soap *soap, const char *tag, int id, const ns2__getReadMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getReadMessageFromShop), type))
		return soap->error;
	if (soap_out_PointerTons2__client(soap, "arg0", -1, &a->ns2__getReadMessageFromShop::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getReadMessageFromShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getReadMessageFromShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getReadMessageFromShop * SOAP_FMAC4 soap_in_ns2__getReadMessageFromShop(struct soap *soap, const char *tag, ns2__getReadMessageFromShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getReadMessageFromShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getReadMessageFromShop, sizeof(ns2__getReadMessageFromShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getReadMessageFromShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getReadMessageFromShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__client(soap, "arg0", &a->ns2__getReadMessageFromShop::arg0, "ns2:client"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getReadMessageFromShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getReadMessageFromShop, SOAP_TYPE_ns2__getReadMessageFromShop, sizeof(ns2__getReadMessageFromShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getReadMessageFromShop * SOAP_FMAC2 soap_instantiate_ns2__getReadMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getReadMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getReadMessageFromShop *p;
	size_t k = sizeof(ns2__getReadMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getReadMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getReadMessageFromShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getReadMessageFromShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getReadMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getReadMessageFromShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getReadMessageFromShop(soap, tag ? tag : "ns2:getReadMessageFromShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getReadMessageFromShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getReadMessageFromShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getReadMessageFromShop * SOAP_FMAC4 soap_get_ns2__getReadMessageFromShop(struct soap *soap, ns2__getReadMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getReadMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductListByInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__product(soap, &this->ns2__getProductListByInfoResponse::return_);
}

void ns2__getProductListByInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__product(soap, &this->ns2__getProductListByInfoResponse::return_);
#endif
}

int ns2__getProductListByInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductListByInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductListByInfoResponse(struct soap *soap, const char *tag, int id, const ns2__getProductListByInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductListByInfoResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__product(soap, "return", -1, &a->ns2__getProductListByInfoResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductListByInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductListByInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductListByInfoResponse * SOAP_FMAC4 soap_in_ns2__getProductListByInfoResponse(struct soap *soap, const char *tag, ns2__getProductListByInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductListByInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductListByInfoResponse, sizeof(ns2__getProductListByInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductListByInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductListByInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__product(soap, "return", &a->ns2__getProductListByInfoResponse::return_, "ns2:product"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductListByInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductListByInfoResponse, SOAP_TYPE_ns2__getProductListByInfoResponse, sizeof(ns2__getProductListByInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductListByInfoResponse * SOAP_FMAC2 soap_instantiate_ns2__getProductListByInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductListByInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductListByInfoResponse *p;
	size_t k = sizeof(ns2__getProductListByInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductListByInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductListByInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductListByInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductListByInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductListByInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductListByInfoResponse(soap, tag ? tag : "ns2:getProductListByInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductListByInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductListByInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductListByInfoResponse * SOAP_FMAC4 soap_get_ns2__getProductListByInfoResponse(struct soap *soap, ns2__getProductListByInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductListByInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getProductListByInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getProductListByInfo::arg0 = NULL;
}

void ns2__getProductListByInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__product(soap, &this->ns2__getProductListByInfo::arg0);
#endif
}

int ns2__getProductListByInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getProductListByInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getProductListByInfo(struct soap *soap, const char *tag, int id, const ns2__getProductListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getProductListByInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__product(soap, "arg0", -1, &a->ns2__getProductListByInfo::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getProductListByInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getProductListByInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getProductListByInfo * SOAP_FMAC4 soap_in_ns2__getProductListByInfo(struct soap *soap, const char *tag, ns2__getProductListByInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getProductListByInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getProductListByInfo, sizeof(ns2__getProductListByInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getProductListByInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getProductListByInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__product(soap, "arg0", &a->ns2__getProductListByInfo::arg0, "ns2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getProductListByInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getProductListByInfo, SOAP_TYPE_ns2__getProductListByInfo, sizeof(ns2__getProductListByInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getProductListByInfo * SOAP_FMAC2 soap_instantiate_ns2__getProductListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getProductListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getProductListByInfo *p;
	size_t k = sizeof(ns2__getProductListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getProductListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getProductListByInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getProductListByInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getProductListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getProductListByInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getProductListByInfo(soap, tag ? tag : "ns2:getProductListByInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getProductListByInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getProductListByInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getProductListByInfo * SOAP_FMAC4 soap_get_ns2__getProductListByInfo(struct soap *soap, ns2__getProductListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getProductListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateShopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__updateShopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__updateShopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateShopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateShopResponse(struct soap *soap, const char *tag, int id, const ns2__updateShopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateShopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateShopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateShopResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateShopResponse * SOAP_FMAC4 soap_in_ns2__updateShopResponse(struct soap *soap, const char *tag, ns2__updateShopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateShopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateShopResponse, sizeof(ns2__updateShopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateShopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateShopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateShopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateShopResponse, SOAP_TYPE_ns2__updateShopResponse, sizeof(ns2__updateShopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateShopResponse * SOAP_FMAC2 soap_instantiate_ns2__updateShopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateShopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateShopResponse *p;
	size_t k = sizeof(ns2__updateShopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateShopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateShopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateShopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateShopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateShopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateShopResponse(soap, tag ? tag : "ns2:updateShopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateShopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateShopResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateShopResponse * SOAP_FMAC4 soap_get_ns2__updateShopResponse(struct soap *soap, ns2__updateShopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateShopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__updateShop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__updateShop::arg0 = NULL;
}

void ns2__updateShop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__shop(soap, &this->ns2__updateShop::arg0);
#endif
}

int ns2__updateShop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__updateShop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__updateShop(struct soap *soap, const char *tag, int id, const ns2__updateShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__updateShop), type))
		return soap->error;
	if (soap_out_PointerTons2__shop(soap, "arg0", -1, &a->ns2__updateShop::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__updateShop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__updateShop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__updateShop * SOAP_FMAC4 soap_in_ns2__updateShop(struct soap *soap, const char *tag, ns2__updateShop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__updateShop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__updateShop, sizeof(ns2__updateShop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__updateShop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__updateShop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__shop(soap, "arg0", &a->ns2__updateShop::arg0, "ns2:shop"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__updateShop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__updateShop, SOAP_TYPE_ns2__updateShop, sizeof(ns2__updateShop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__updateShop * SOAP_FMAC2 soap_instantiate_ns2__updateShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__updateShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__updateShop *p;
	size_t k = sizeof(ns2__updateShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__updateShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__updateShop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__updateShop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__updateShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__updateShop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__updateShop(soap, tag ? tag : "ns2:updateShop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__updateShop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__updateShop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__updateShop * SOAP_FMAC4 soap_get_ns2__updateShop(struct soap *soap, ns2__updateShop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__updateShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__shop::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__shop::shopEmail = NULL;
	soap_default_int(soap, &this->ns2__shop::shopId);
	this->ns2__shop::shopImage = NULL;
	this->ns2__shop::shopName = NULL;
	this->ns2__shop::shopPhone = NULL;
	this->ns2__shop::shopPwd = NULL;
	this->ns2__shop::shopSignTime = NULL;
}

void ns2__shop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__shop::shopEmail);
	soap_serialize_PointerTostd__string(soap, &this->ns2__shop::shopImage);
	soap_serialize_PointerTostd__string(soap, &this->ns2__shop::shopName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__shop::shopPhone);
	soap_serialize_PointerTostd__string(soap, &this->ns2__shop::shopPwd);
	soap_serialize_PointerTodateTime(soap, &this->ns2__shop::shopSignTime);
#endif
}

int ns2__shop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__shop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__shop(struct soap *soap, const char *tag, int id, const ns2__shop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__shop), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "shopEmail", -1, &a->ns2__shop::shopEmail, ""))
		return soap->error;
	if (soap_out_int(soap, "shopId", -1, &a->ns2__shop::shopId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "shopImage", -1, &a->ns2__shop::shopImage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "shopName", -1, &a->ns2__shop::shopName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "shopPhone", -1, &a->ns2__shop::shopPhone, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "shopPwd", -1, &a->ns2__shop::shopPwd, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "shopSignTime", -1, &a->ns2__shop::shopSignTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__shop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__shop(soap, tag, this, type);
}

SOAP_FMAC3 ns2__shop * SOAP_FMAC4 soap_in_ns2__shop(struct soap *soap, const char *tag, ns2__shop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__shop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__shop, sizeof(ns2__shop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__shop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__shop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_shopEmail1 = 1;
	size_t soap_flag_shopId1 = 1;
	size_t soap_flag_shopImage1 = 1;
	size_t soap_flag_shopName1 = 1;
	size_t soap_flag_shopPhone1 = 1;
	size_t soap_flag_shopPwd1 = 1;
	size_t soap_flag_shopSignTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_shopEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "shopEmail", &a->ns2__shop::shopEmail, "xsd:string"))
				{	soap_flag_shopEmail1--;
					continue;
				}
			}
			if (soap_flag_shopId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "shopId", &a->ns2__shop::shopId, "xsd:int"))
				{	soap_flag_shopId1--;
					continue;
				}
			}
			if (soap_flag_shopImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "shopImage", &a->ns2__shop::shopImage, "xsd:string"))
				{	soap_flag_shopImage1--;
					continue;
				}
			}
			if (soap_flag_shopName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "shopName", &a->ns2__shop::shopName, "xsd:string"))
				{	soap_flag_shopName1--;
					continue;
				}
			}
			if (soap_flag_shopPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "shopPhone", &a->ns2__shop::shopPhone, "xsd:string"))
				{	soap_flag_shopPhone1--;
					continue;
				}
			}
			if (soap_flag_shopPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "shopPwd", &a->ns2__shop::shopPwd, "xsd:string"))
				{	soap_flag_shopPwd1--;
					continue;
				}
			}
			if (soap_flag_shopSignTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "shopSignTime", &a->ns2__shop::shopSignTime, "xsd:dateTime"))
				{	soap_flag_shopSignTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shopId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__shop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__shop, SOAP_TYPE_ns2__shop, sizeof(ns2__shop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__shop * SOAP_FMAC2 soap_instantiate_ns2__shop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__shop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__shop *p;
	size_t k = sizeof(ns2__shop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__shop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__shop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__shop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__shop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__shop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__shop(soap, tag ? tag : "ns2:shop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__shop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__shop(soap, this, tag, type);
}

SOAP_FMAC3 ns2__shop * SOAP_FMAC4 soap_get_ns2__shop(struct soap *soap, ns2__shop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__shop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getShopByNameAndPwdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getShopByNameAndPwdResponse::return_ = NULL;
}

void ns2__getShopByNameAndPwdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__shop(soap, &this->ns2__getShopByNameAndPwdResponse::return_);
#endif
}

int ns2__getShopByNameAndPwdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getShopByNameAndPwdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getShopByNameAndPwdResponse(struct soap *soap, const char *tag, int id, const ns2__getShopByNameAndPwdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getShopByNameAndPwdResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__shop(soap, "return", -1, &a->ns2__getShopByNameAndPwdResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getShopByNameAndPwdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getShopByNameAndPwdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getShopByNameAndPwdResponse * SOAP_FMAC4 soap_in_ns2__getShopByNameAndPwdResponse(struct soap *soap, const char *tag, ns2__getShopByNameAndPwdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getShopByNameAndPwdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getShopByNameAndPwdResponse, sizeof(ns2__getShopByNameAndPwdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getShopByNameAndPwdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getShopByNameAndPwdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__shop(soap, "return", &a->ns2__getShopByNameAndPwdResponse::return_, "ns2:shop"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getShopByNameAndPwdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getShopByNameAndPwdResponse, SOAP_TYPE_ns2__getShopByNameAndPwdResponse, sizeof(ns2__getShopByNameAndPwdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getShopByNameAndPwdResponse * SOAP_FMAC2 soap_instantiate_ns2__getShopByNameAndPwdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getShopByNameAndPwdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getShopByNameAndPwdResponse *p;
	size_t k = sizeof(ns2__getShopByNameAndPwdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getShopByNameAndPwdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getShopByNameAndPwdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getShopByNameAndPwdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getShopByNameAndPwdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getShopByNameAndPwdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getShopByNameAndPwdResponse(soap, tag ? tag : "ns2:getShopByNameAndPwdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getShopByNameAndPwdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getShopByNameAndPwdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getShopByNameAndPwdResponse * SOAP_FMAC4 soap_get_ns2__getShopByNameAndPwdResponse(struct soap *soap, ns2__getShopByNameAndPwdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getShopByNameAndPwdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getShopByNameAndPwd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getShopByNameAndPwd::arg0 = NULL;
	this->ns2__getShopByNameAndPwd::arg1 = NULL;
}

void ns2__getShopByNameAndPwd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__getShopByNameAndPwd::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns2__getShopByNameAndPwd::arg1);
#endif
}

int ns2__getShopByNameAndPwd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getShopByNameAndPwd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getShopByNameAndPwd(struct soap *soap, const char *tag, int id, const ns2__getShopByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getShopByNameAndPwd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__getShopByNameAndPwd::arg0, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &a->ns2__getShopByNameAndPwd::arg1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getShopByNameAndPwd::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getShopByNameAndPwd(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getShopByNameAndPwd * SOAP_FMAC4 soap_in_ns2__getShopByNameAndPwd(struct soap *soap, const char *tag, ns2__getShopByNameAndPwd *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getShopByNameAndPwd*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getShopByNameAndPwd, sizeof(ns2__getShopByNameAndPwd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getShopByNameAndPwd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getShopByNameAndPwd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__getShopByNameAndPwd::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg1", &a->ns2__getShopByNameAndPwd::arg1, "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getShopByNameAndPwd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getShopByNameAndPwd, SOAP_TYPE_ns2__getShopByNameAndPwd, sizeof(ns2__getShopByNameAndPwd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getShopByNameAndPwd * SOAP_FMAC2 soap_instantiate_ns2__getShopByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getShopByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getShopByNameAndPwd *p;
	size_t k = sizeof(ns2__getShopByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getShopByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getShopByNameAndPwd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getShopByNameAndPwd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getShopByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getShopByNameAndPwd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getShopByNameAndPwd(soap, tag ? tag : "ns2:getShopByNameAndPwd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getShopByNameAndPwd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getShopByNameAndPwd(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getShopByNameAndPwd * SOAP_FMAC4 soap_get_ns2__getShopByNameAndPwd(struct soap *soap, ns2__getShopByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getShopByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderListResponse::return_);
}

void ns2__getOrderListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__order(soap, &this->ns2__getOrderListResponse::return_);
#endif
}

int ns2__getOrderListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderListResponse(struct soap *soap, const char *tag, int id, const ns2__getOrderListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__order(soap, "return", -1, &a->ns2__getOrderListResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderListResponse * SOAP_FMAC4 soap_in_ns2__getOrderListResponse(struct soap *soap, const char *tag, ns2__getOrderListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderListResponse, sizeof(ns2__getOrderListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__order(soap, "return", &a->ns2__getOrderListResponse::return_, "ns2:order"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderListResponse, SOAP_TYPE_ns2__getOrderListResponse, sizeof(ns2__getOrderListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderListResponse * SOAP_FMAC2 soap_instantiate_ns2__getOrderListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderListResponse *p;
	size_t k = sizeof(ns2__getOrderListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderListResponse(soap, tag ? tag : "ns2:getOrderListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderListResponse * SOAP_FMAC4 soap_get_ns2__getOrderListResponse(struct soap *soap, ns2__getOrderListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__order::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__order::orderCheck);
	this->ns2__order::orderClient = NULL;
	soap_default_int(soap, &this->ns2__order::orderClientId);
	this->ns2__order::orderCost = NULL;
	soap_default_int(soap, &this->ns2__order::orderHide);
	soap_default_int(soap, &this->ns2__order::orderId);
	soap_default_int(soap, &this->ns2__order::orderProductId);
	this->ns2__order::orderProductName = NULL;
	soap_default_int(soap, &this->ns2__order::orderProductNum);
	this->ns2__order::orderProductStyle = NULL;
	soap_default_int(soap, &this->ns2__order::orderRefund);
	soap_default_int(soap, &this->ns2__order::orderShip);
	soap_default_int(soap, &this->ns2__order::orderShopId);
	this->ns2__order::orderTime = NULL;
}

void ns2__order::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__order::orderClient);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns2__order::orderCost);
	soap_serialize_PointerTostd__string(soap, &this->ns2__order::orderProductName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__order::orderProductStyle);
	soap_serialize_PointerTodateTime(soap, &this->ns2__order::orderTime);
#endif
}

int ns2__order::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__order(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__order(struct soap *soap, const char *tag, int id, const ns2__order *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__order), type))
		return soap->error;
	if (soap_out_int(soap, "orderCheck", -1, &a->ns2__order::orderCheck, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "orderClient", -1, &a->ns2__order::orderClient, ""))
		return soap->error;
	if (soap_out_int(soap, "orderClientId", -1, &a->ns2__order::orderClientId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "orderCost", -1, &a->ns2__order::orderCost, ""))
		return soap->error;
	if (soap_out_int(soap, "orderHide", -1, &a->ns2__order::orderHide, ""))
		return soap->error;
	if (soap_out_int(soap, "orderId", -1, &a->ns2__order::orderId, ""))
		return soap->error;
	if (soap_out_int(soap, "orderProductId", -1, &a->ns2__order::orderProductId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "orderProductName", -1, &a->ns2__order::orderProductName, ""))
		return soap->error;
	if (soap_out_int(soap, "orderProductNum", -1, &a->ns2__order::orderProductNum, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "orderProductStyle", -1, &a->ns2__order::orderProductStyle, ""))
		return soap->error;
	if (soap_out_int(soap, "orderRefund", -1, &a->ns2__order::orderRefund, ""))
		return soap->error;
	if (soap_out_int(soap, "orderShip", -1, &a->ns2__order::orderShip, ""))
		return soap->error;
	if (soap_out_int(soap, "orderShopId", -1, &a->ns2__order::orderShopId, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "orderTime", -1, &a->ns2__order::orderTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__order::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__order(soap, tag, this, type);
}

SOAP_FMAC3 ns2__order * SOAP_FMAC4 soap_in_ns2__order(struct soap *soap, const char *tag, ns2__order *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__order*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__order, sizeof(ns2__order), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__order)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__order *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_orderCheck1 = 1;
	size_t soap_flag_orderClient1 = 1;
	size_t soap_flag_orderClientId1 = 1;
	size_t soap_flag_orderCost1 = 1;
	size_t soap_flag_orderHide1 = 1;
	size_t soap_flag_orderId1 = 1;
	size_t soap_flag_orderProductId1 = 1;
	size_t soap_flag_orderProductName1 = 1;
	size_t soap_flag_orderProductNum1 = 1;
	size_t soap_flag_orderProductStyle1 = 1;
	size_t soap_flag_orderRefund1 = 1;
	size_t soap_flag_orderShip1 = 1;
	size_t soap_flag_orderShopId1 = 1;
	size_t soap_flag_orderTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderCheck1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderCheck", &a->ns2__order::orderCheck, "xsd:int"))
				{	soap_flag_orderCheck1--;
					continue;
				}
			}
			if (soap_flag_orderClient1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "orderClient", &a->ns2__order::orderClient, "xsd:string"))
				{	soap_flag_orderClient1--;
					continue;
				}
			}
			if (soap_flag_orderClientId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderClientId", &a->ns2__order::orderClientId, "xsd:int"))
				{	soap_flag_orderClientId1--;
					continue;
				}
			}
			if (soap_flag_orderCost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "orderCost", &a->ns2__order::orderCost, "xsd:decimal"))
				{	soap_flag_orderCost1--;
					continue;
				}
			}
			if (soap_flag_orderHide1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderHide", &a->ns2__order::orderHide, "xsd:int"))
				{	soap_flag_orderHide1--;
					continue;
				}
			}
			if (soap_flag_orderId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderId", &a->ns2__order::orderId, "xsd:int"))
				{	soap_flag_orderId1--;
					continue;
				}
			}
			if (soap_flag_orderProductId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderProductId", &a->ns2__order::orderProductId, "xsd:int"))
				{	soap_flag_orderProductId1--;
					continue;
				}
			}
			if (soap_flag_orderProductName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "orderProductName", &a->ns2__order::orderProductName, "xsd:string"))
				{	soap_flag_orderProductName1--;
					continue;
				}
			}
			if (soap_flag_orderProductNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderProductNum", &a->ns2__order::orderProductNum, "xsd:int"))
				{	soap_flag_orderProductNum1--;
					continue;
				}
			}
			if (soap_flag_orderProductStyle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "orderProductStyle", &a->ns2__order::orderProductStyle, "xsd:string"))
				{	soap_flag_orderProductStyle1--;
					continue;
				}
			}
			if (soap_flag_orderRefund1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderRefund", &a->ns2__order::orderRefund, "xsd:int"))
				{	soap_flag_orderRefund1--;
					continue;
				}
			}
			if (soap_flag_orderShip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderShip", &a->ns2__order::orderShip, "xsd:int"))
				{	soap_flag_orderShip1--;
					continue;
				}
			}
			if (soap_flag_orderShopId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "orderShopId", &a->ns2__order::orderShopId, "xsd:int"))
				{	soap_flag_orderShopId1--;
					continue;
				}
			}
			if (soap_flag_orderTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "orderTime", &a->ns2__order::orderTime, "xsd:dateTime"))
				{	soap_flag_orderTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_orderCheck1 > 0 || soap_flag_orderClientId1 > 0 || soap_flag_orderHide1 > 0 || soap_flag_orderId1 > 0 || soap_flag_orderProductId1 > 0 || soap_flag_orderProductNum1 > 0 || soap_flag_orderRefund1 > 0 || soap_flag_orderShip1 > 0 || soap_flag_orderShopId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__order *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__order, SOAP_TYPE_ns2__order, sizeof(ns2__order), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__order * SOAP_FMAC2 soap_instantiate_ns2__order(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__order(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__order *p;
	size_t k = sizeof(ns2__order);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__order, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__order);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__order, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__order location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__order::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__order(soap, tag ? tag : "ns2:order", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__order::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__order(soap, this, tag, type);
}

SOAP_FMAC3 ns2__order * SOAP_FMAC4 soap_get_ns2__order(struct soap *soap, ns2__order *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__order(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__getOrderList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__getOrderList::arg0 = NULL;
}

void ns2__getOrderList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__order(soap, &this->ns2__getOrderList::arg0);
#endif
}

int ns2__getOrderList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__getOrderList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOrderList(struct soap *soap, const char *tag, int id, const ns2__getOrderList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOrderList), type))
		return soap->error;
	if (soap_out_PointerTons2__order(soap, "arg0", -1, &a->ns2__getOrderList::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__getOrderList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__getOrderList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__getOrderList * SOAP_FMAC4 soap_in_ns2__getOrderList(struct soap *soap, const char *tag, ns2__getOrderList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__getOrderList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOrderList, sizeof(ns2__getOrderList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__getOrderList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__getOrderList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__order(soap, "arg0", &a->ns2__getOrderList::arg0, "ns2:order"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__getOrderList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOrderList, SOAP_TYPE_ns2__getOrderList, sizeof(ns2__getOrderList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__getOrderList * SOAP_FMAC2 soap_instantiate_ns2__getOrderList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOrderList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__getOrderList *p;
	size_t k = sizeof(ns2__getOrderList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__getOrderList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__getOrderList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__getOrderList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__getOrderList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__getOrderList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__getOrderList(soap, tag ? tag : "ns2:getOrderList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__getOrderList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__getOrderList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__getOrderList * SOAP_FMAC4 soap_get_ns2__getOrderList(struct soap *soap, ns2__getOrderList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__getOrderList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteProductTypeByNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__deleteProductTypeByNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__deleteProductTypeByNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteProductTypeByNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteProductTypeByNameResponse(struct soap *soap, const char *tag, int id, const ns2__deleteProductTypeByNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteProductTypeByNameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteProductTypeByNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteProductTypeByNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteProductTypeByNameResponse * SOAP_FMAC4 soap_in_ns2__deleteProductTypeByNameResponse(struct soap *soap, const char *tag, ns2__deleteProductTypeByNameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteProductTypeByNameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteProductTypeByNameResponse, sizeof(ns2__deleteProductTypeByNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteProductTypeByNameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteProductTypeByNameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteProductTypeByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteProductTypeByNameResponse, SOAP_TYPE_ns2__deleteProductTypeByNameResponse, sizeof(ns2__deleteProductTypeByNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteProductTypeByNameResponse * SOAP_FMAC2 soap_instantiate_ns2__deleteProductTypeByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteProductTypeByNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteProductTypeByNameResponse *p;
	size_t k = sizeof(ns2__deleteProductTypeByNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteProductTypeByNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteProductTypeByNameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteProductTypeByNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteProductTypeByNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteProductTypeByNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteProductTypeByNameResponse(soap, tag ? tag : "ns2:deleteProductTypeByNameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteProductTypeByNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteProductTypeByNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteProductTypeByNameResponse * SOAP_FMAC4 soap_get_ns2__deleteProductTypeByNameResponse(struct soap *soap, ns2__deleteProductTypeByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteProductTypeByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__deleteProductTypeByName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__deleteProductTypeByName::arg0 = NULL;
}

void ns2__deleteProductTypeByName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__deleteProductTypeByName::arg0);
#endif
}

int ns2__deleteProductTypeByName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__deleteProductTypeByName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__deleteProductTypeByName(struct soap *soap, const char *tag, int id, const ns2__deleteProductTypeByName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__deleteProductTypeByName), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &a->ns2__deleteProductTypeByName::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__deleteProductTypeByName::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__deleteProductTypeByName(soap, tag, this, type);
}

SOAP_FMAC3 ns2__deleteProductTypeByName * SOAP_FMAC4 soap_in_ns2__deleteProductTypeByName(struct soap *soap, const char *tag, ns2__deleteProductTypeByName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__deleteProductTypeByName*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__deleteProductTypeByName, sizeof(ns2__deleteProductTypeByName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__deleteProductTypeByName)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__deleteProductTypeByName *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arg0", &a->ns2__deleteProductTypeByName::arg0, "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__deleteProductTypeByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__deleteProductTypeByName, SOAP_TYPE_ns2__deleteProductTypeByName, sizeof(ns2__deleteProductTypeByName), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate_ns2__deleteProductTypeByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__deleteProductTypeByName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__deleteProductTypeByName *p;
	size_t k = sizeof(ns2__deleteProductTypeByName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__deleteProductTypeByName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__deleteProductTypeByName);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__deleteProductTypeByName, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__deleteProductTypeByName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__deleteProductTypeByName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__deleteProductTypeByName(soap, tag ? tag : "ns2:deleteProductTypeByName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__deleteProductTypeByName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__deleteProductTypeByName(soap, this, tag, type);
}

SOAP_FMAC3 ns2__deleteProductTypeByName * SOAP_FMAC4 soap_get_ns2__deleteProductTypeByName(struct soap *soap, ns2__deleteProductTypeByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__deleteProductTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__addProductResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__addProductResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__addProductResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addProductResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addProductResponse(struct soap *soap, const char *tag, int id, const ns2__addProductResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addProductResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__addProductResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__addProductResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addProductResponse * SOAP_FMAC4 soap_in_ns2__addProductResponse(struct soap *soap, const char *tag, ns2__addProductResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addProductResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addProductResponse, sizeof(ns2__addProductResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__addProductResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__addProductResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addProductResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addProductResponse, SOAP_TYPE_ns2__addProductResponse, sizeof(ns2__addProductResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__addProductResponse * SOAP_FMAC2 soap_instantiate_ns2__addProductResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addProductResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__addProductResponse *p;
	size_t k = sizeof(ns2__addProductResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__addProductResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__addProductResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__addProductResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__addProductResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__addProductResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__addProductResponse(soap, tag ? tag : "ns2:addProductResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addProductResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addProductResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addProductResponse * SOAP_FMAC4 soap_get_ns2__addProductResponse(struct soap *soap, ns2__addProductResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__addProduct::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__addProduct::arg0 = NULL;
}

void ns2__addProduct::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__product(soap, &this->ns2__addProduct::arg0);
#endif
}

int ns2__addProduct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__addProduct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__addProduct(struct soap *soap, const char *tag, int id, const ns2__addProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__addProduct), type))
		return soap->error;
	if (soap_out_PointerTons2__product(soap, "arg0", -1, &a->ns2__addProduct::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__addProduct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__addProduct(soap, tag, this, type);
}

SOAP_FMAC3 ns2__addProduct * SOAP_FMAC4 soap_in_ns2__addProduct(struct soap *soap, const char *tag, ns2__addProduct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__addProduct*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__addProduct, sizeof(ns2__addProduct), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__addProduct)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__addProduct *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__product(soap, "arg0", &a->ns2__addProduct::arg0, "ns2:product"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__addProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__addProduct, SOAP_TYPE_ns2__addProduct, sizeof(ns2__addProduct), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__addProduct * SOAP_FMAC2 soap_instantiate_ns2__addProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__addProduct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__addProduct *p;
	size_t k = sizeof(ns2__addProduct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__addProduct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__addProduct);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__addProduct, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__addProduct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__addProduct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__addProduct(soap, tag ? tag : "ns2:addProduct", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__addProduct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__addProduct(soap, this, tag, type);
}

SOAP_FMAC3 ns2__addProduct * SOAP_FMAC4 soap_get_ns2__addProduct(struct soap *soap, ns2__addProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__addProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__product::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__product::discountEndTime = NULL;
	this->ns2__product::discountStartTime = NULL;
	this->ns2__product::flashSaleEndTime = NULL;
	soap_default_int(soap, &this->ns2__product::flashSalePurchaseLimit);
	this->ns2__product::flashSaleStartTime = NULL;
	soap_default_int(soap, &this->ns2__product::productBuyNum);
	soap_default_float(soap, &this->ns2__product::productDiscount);
	soap_default_float(soap, &this->ns2__product::productFlashSalePrice);
	soap_default_int(soap, &this->ns2__product::productId);
	this->ns2__product::productImage = NULL;
	this->ns2__product::productName = NULL;
	soap_default_int(soap, &this->ns2__product::productNum);
	soap_default_int(soap, &this->ns2__product::productPrice);
	soap_default_int(soap, &this->ns2__product::productShopId);
}

void ns2__product::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns2__product::discountEndTime);
	soap_serialize_PointerTodateTime(soap, &this->ns2__product::discountStartTime);
	soap_serialize_PointerTodateTime(soap, &this->ns2__product::flashSaleEndTime);
	soap_serialize_PointerTodateTime(soap, &this->ns2__product::flashSaleStartTime);
	soap_serialize_PointerTostd__string(soap, &this->ns2__product::productImage);
	soap_serialize_PointerTostd__string(soap, &this->ns2__product::productName);
#endif
}

int ns2__product::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__product(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__product(struct soap *soap, const char *tag, int id, const ns2__product *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__product), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "discountEndTime", -1, &a->ns2__product::discountEndTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "discountStartTime", -1, &a->ns2__product::discountStartTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "flashSaleEndTime", -1, &a->ns2__product::flashSaleEndTime, ""))
		return soap->error;
	if (soap_out_int(soap, "flashSalePurchaseLimit", -1, &a->ns2__product::flashSalePurchaseLimit, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "flashSaleStartTime", -1, &a->ns2__product::flashSaleStartTime, ""))
		return soap->error;
	if (soap_out_int(soap, "productBuyNum", -1, &a->ns2__product::productBuyNum, ""))
		return soap->error;
	if (soap_out_float(soap, "productDiscount", -1, &a->ns2__product::productDiscount, ""))
		return soap->error;
	if (soap_out_float(soap, "productFlashSalePrice", -1, &a->ns2__product::productFlashSalePrice, ""))
		return soap->error;
	if (soap_out_int(soap, "productId", -1, &a->ns2__product::productId, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "productImage", -1, &a->ns2__product::productImage, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "productName", -1, &a->ns2__product::productName, ""))
		return soap->error;
	if (soap_out_int(soap, "productNum", -1, &a->ns2__product::productNum, ""))
		return soap->error;
	if (soap_out_int(soap, "productPrice", -1, &a->ns2__product::productPrice, ""))
		return soap->error;
	if (soap_out_int(soap, "productShopId", -1, &a->ns2__product::productShopId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__product::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__product(soap, tag, this, type);
}

SOAP_FMAC3 ns2__product * SOAP_FMAC4 soap_in_ns2__product(struct soap *soap, const char *tag, ns2__product *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__product*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__product, sizeof(ns2__product), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__product)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__product *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_discountEndTime1 = 1;
	size_t soap_flag_discountStartTime1 = 1;
	size_t soap_flag_flashSaleEndTime1 = 1;
	size_t soap_flag_flashSalePurchaseLimit1 = 1;
	size_t soap_flag_flashSaleStartTime1 = 1;
	size_t soap_flag_productBuyNum1 = 1;
	size_t soap_flag_productDiscount1 = 1;
	size_t soap_flag_productFlashSalePrice1 = 1;
	size_t soap_flag_productId1 = 1;
	size_t soap_flag_productImage1 = 1;
	size_t soap_flag_productName1 = 1;
	size_t soap_flag_productNum1 = 1;
	size_t soap_flag_productPrice1 = 1;
	size_t soap_flag_productShopId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_discountEndTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "discountEndTime", &a->ns2__product::discountEndTime, "xsd:dateTime"))
				{	soap_flag_discountEndTime1--;
					continue;
				}
			}
			if (soap_flag_discountStartTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "discountStartTime", &a->ns2__product::discountStartTime, "xsd:dateTime"))
				{	soap_flag_discountStartTime1--;
					continue;
				}
			}
			if (soap_flag_flashSaleEndTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "flashSaleEndTime", &a->ns2__product::flashSaleEndTime, "xsd:dateTime"))
				{	soap_flag_flashSaleEndTime1--;
					continue;
				}
			}
			if (soap_flag_flashSalePurchaseLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "flashSalePurchaseLimit", &a->ns2__product::flashSalePurchaseLimit, "xsd:int"))
				{	soap_flag_flashSalePurchaseLimit1--;
					continue;
				}
			}
			if (soap_flag_flashSaleStartTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "flashSaleStartTime", &a->ns2__product::flashSaleStartTime, "xsd:dateTime"))
				{	soap_flag_flashSaleStartTime1--;
					continue;
				}
			}
			if (soap_flag_productBuyNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productBuyNum", &a->ns2__product::productBuyNum, "xsd:int"))
				{	soap_flag_productBuyNum1--;
					continue;
				}
			}
			if (soap_flag_productDiscount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "productDiscount", &a->ns2__product::productDiscount, "xsd:float"))
				{	soap_flag_productDiscount1--;
					continue;
				}
			}
			if (soap_flag_productFlashSalePrice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "productFlashSalePrice", &a->ns2__product::productFlashSalePrice, "xsd:float"))
				{	soap_flag_productFlashSalePrice1--;
					continue;
				}
			}
			if (soap_flag_productId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productId", &a->ns2__product::productId, "xsd:int"))
				{	soap_flag_productId1--;
					continue;
				}
			}
			if (soap_flag_productImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "productImage", &a->ns2__product::productImage, "xsd:string"))
				{	soap_flag_productImage1--;
					continue;
				}
			}
			if (soap_flag_productName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "productName", &a->ns2__product::productName, "xsd:string"))
				{	soap_flag_productName1--;
					continue;
				}
			}
			if (soap_flag_productNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productNum", &a->ns2__product::productNum, "xsd:int"))
				{	soap_flag_productNum1--;
					continue;
				}
			}
			if (soap_flag_productPrice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productPrice", &a->ns2__product::productPrice, "xsd:int"))
				{	soap_flag_productPrice1--;
					continue;
				}
			}
			if (soap_flag_productShopId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "productShopId", &a->ns2__product::productShopId, "xsd:int"))
				{	soap_flag_productShopId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_flashSalePurchaseLimit1 > 0 || soap_flag_productBuyNum1 > 0 || soap_flag_productDiscount1 > 0 || soap_flag_productFlashSalePrice1 > 0 || soap_flag_productId1 > 0 || soap_flag_productNum1 > 0 || soap_flag_productPrice1 > 0 || soap_flag_productShopId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__product *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__product, SOAP_TYPE_ns2__product, sizeof(ns2__product), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__product * SOAP_FMAC2 soap_instantiate_ns2__product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__product(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__product *p;
	size_t k = sizeof(ns2__product);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__product, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__product);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__product, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__product location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__product::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__product(soap, tag ? tag : "ns2:product", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__product::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__product(soap, this, tag, type);
}

SOAP_FMAC3 ns2__product * SOAP_FMAC4 soap_get_ns2__product(struct soap *soap, ns2__product *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__selectProductForUpdateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__selectProductForUpdateResponse::return_ = NULL;
}

void ns2__selectProductForUpdateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__product(soap, &this->ns2__selectProductForUpdateResponse::return_);
#endif
}

int ns2__selectProductForUpdateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__selectProductForUpdateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__selectProductForUpdateResponse(struct soap *soap, const char *tag, int id, const ns2__selectProductForUpdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__selectProductForUpdateResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__product(soap, "return", -1, &a->ns2__selectProductForUpdateResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__selectProductForUpdateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__selectProductForUpdateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns2__selectProductForUpdateResponse * SOAP_FMAC4 soap_in_ns2__selectProductForUpdateResponse(struct soap *soap, const char *tag, ns2__selectProductForUpdateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__selectProductForUpdateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__selectProductForUpdateResponse, sizeof(ns2__selectProductForUpdateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__selectProductForUpdateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__selectProductForUpdateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__product(soap, "return", &a->ns2__selectProductForUpdateResponse::return_, "ns2:product"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__selectProductForUpdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__selectProductForUpdateResponse, SOAP_TYPE_ns2__selectProductForUpdateResponse, sizeof(ns2__selectProductForUpdateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__selectProductForUpdateResponse * SOAP_FMAC2 soap_instantiate_ns2__selectProductForUpdateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__selectProductForUpdateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__selectProductForUpdateResponse *p;
	size_t k = sizeof(ns2__selectProductForUpdateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__selectProductForUpdateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__selectProductForUpdateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__selectProductForUpdateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__selectProductForUpdateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__selectProductForUpdateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__selectProductForUpdateResponse(soap, tag ? tag : "ns2:selectProductForUpdateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__selectProductForUpdateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__selectProductForUpdateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns2__selectProductForUpdateResponse * SOAP_FMAC4 soap_get_ns2__selectProductForUpdateResponse(struct soap *soap, ns2__selectProductForUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__selectProductForUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__selectProductForUpdate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__selectProductForUpdate::arg0);
}

void ns2__selectProductForUpdate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__selectProductForUpdate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__selectProductForUpdate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__selectProductForUpdate(struct soap *soap, const char *tag, int id, const ns2__selectProductForUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__selectProductForUpdate), type))
		return soap->error;
	if (soap_out_int(soap, "arg0", -1, &a->ns2__selectProductForUpdate::arg0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__selectProductForUpdate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__selectProductForUpdate(soap, tag, this, type);
}

SOAP_FMAC3 ns2__selectProductForUpdate * SOAP_FMAC4 soap_in_ns2__selectProductForUpdate(struct soap *soap, const char *tag, ns2__selectProductForUpdate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__selectProductForUpdate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__selectProductForUpdate, sizeof(ns2__selectProductForUpdate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__selectProductForUpdate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__selectProductForUpdate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_arg01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "arg0", &a->ns2__selectProductForUpdate::arg0, "xsd:int"))
				{	soap_flag_arg01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__selectProductForUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__selectProductForUpdate, SOAP_TYPE_ns2__selectProductForUpdate, sizeof(ns2__selectProductForUpdate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__selectProductForUpdate * SOAP_FMAC2 soap_instantiate_ns2__selectProductForUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__selectProductForUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__selectProductForUpdate *p;
	size_t k = sizeof(ns2__selectProductForUpdate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns2__selectProductForUpdate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__selectProductForUpdate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__selectProductForUpdate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__selectProductForUpdate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__selectProductForUpdate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__selectProductForUpdate(soap, tag ? tag : "ns2:selectProductForUpdate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__selectProductForUpdate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__selectProductForUpdate(soap, this, tag, type);
}

SOAP_FMAC3 ns2__selectProductForUpdate * SOAP_FMAC4 soap_get_ns2__selectProductForUpdate(struct soap *soap, ns2__selectProductForUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__selectProductForUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsertClient(struct soap *soap, struct __ns1__InsertClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__InsertClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsertClient(struct soap *soap, const struct __ns1__InsertClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__InsertClient(soap, &a->ns2__InsertClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsertClient(struct soap *soap, const char *tag, int id, const struct __ns1__InsertClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__InsertClient(soap, "ns2:InsertClient", -1, &a->ns2__InsertClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertClient * SOAP_FMAC4 soap_in___ns1__InsertClient(struct soap *soap, const char *tag, struct __ns1__InsertClient *a, const char *type)
{
	size_t soap_flag_ns2__InsertClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsertClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsertClient, sizeof(struct __ns1__InsertClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsertClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__InsertClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__InsertClient(soap, "ns2:InsertClient", &a->ns2__InsertClient_, "ns2:InsertClient"))
				{	soap_flag_ns2__InsertClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsertClient * SOAP_FMAC2 soap_instantiate___ns1__InsertClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsertClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsertClient *p;
	size_t k = sizeof(struct __ns1__InsertClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InsertClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InsertClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InsertClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsertClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsertClient(struct soap *soap, const struct __ns1__InsertClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsertClient(soap, tag ? tag : "-ns1:InsertClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertClient * SOAP_FMAC4 soap_get___ns1__InsertClient(struct soap *soap, struct __ns1__InsertClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsertClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteShoppingCart(struct soap *soap, struct __ns1__deleteShoppingCart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteShoppingCart_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteShoppingCart(struct soap *soap, const struct __ns1__deleteShoppingCart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteShoppingCart(soap, &a->ns2__deleteShoppingCart_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteShoppingCart(struct soap *soap, const char *tag, int id, const struct __ns1__deleteShoppingCart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteShoppingCart(soap, "ns2:deleteShoppingCart", -1, &a->ns2__deleteShoppingCart_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteShoppingCart * SOAP_FMAC4 soap_in___ns1__deleteShoppingCart(struct soap *soap, const char *tag, struct __ns1__deleteShoppingCart *a, const char *type)
{
	size_t soap_flag_ns2__deleteShoppingCart_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteShoppingCart*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteShoppingCart, sizeof(struct __ns1__deleteShoppingCart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteShoppingCart(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteShoppingCart_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteShoppingCart(soap, "ns2:deleteShoppingCart", &a->ns2__deleteShoppingCart_, "ns2:deleteShoppingCart"))
				{	soap_flag_ns2__deleteShoppingCart_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteShoppingCart * SOAP_FMAC2 soap_instantiate___ns1__deleteShoppingCart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteShoppingCart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteShoppingCart *p;
	size_t k = sizeof(struct __ns1__deleteShoppingCart);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteShoppingCart, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteShoppingCart);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteShoppingCart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteShoppingCart location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteShoppingCart(struct soap *soap, const struct __ns1__deleteShoppingCart *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteShoppingCart(soap, tag ? tag : "-ns1:deleteShoppingCart", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteShoppingCart * SOAP_FMAC4 soap_get___ns1__deleteShoppingCart(struct soap *soap, struct __ns1__deleteShoppingCart *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClientByNameAndPwd(struct soap *soap, struct __ns1__getClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClientByNameAndPwd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClientByNameAndPwd(struct soap *soap, const struct __ns1__getClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getClientByNameAndPwd(soap, &a->ns2__getClientByNameAndPwd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClientByNameAndPwd(struct soap *soap, const char *tag, int id, const struct __ns1__getClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getClientByNameAndPwd(soap, "ns2:getClientByNameAndPwd", -1, &a->ns2__getClientByNameAndPwd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClientByNameAndPwd * SOAP_FMAC4 soap_in___ns1__getClientByNameAndPwd(struct soap *soap, const char *tag, struct __ns1__getClientByNameAndPwd *a, const char *type)
{
	size_t soap_flag_ns2__getClientByNameAndPwd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getClientByNameAndPwd*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClientByNameAndPwd, sizeof(struct __ns1__getClientByNameAndPwd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClientByNameAndPwd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClientByNameAndPwd_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getClientByNameAndPwd(soap, "ns2:getClientByNameAndPwd", &a->ns2__getClientByNameAndPwd_, "ns2:getClientByNameAndPwd"))
				{	soap_flag_ns2__getClientByNameAndPwd_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__getClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getClientByNameAndPwd *p;
	size_t k = sizeof(struct __ns1__getClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getClientByNameAndPwd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getClientByNameAndPwd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClientByNameAndPwd(struct soap *soap, const struct __ns1__getClientByNameAndPwd *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getClientByNameAndPwd(soap, tag ? tag : "-ns1:getClientByNameAndPwd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClientByNameAndPwd * SOAP_FMAC4 soap_get___ns1__getClientByNameAndPwd(struct soap *soap, struct __ns1__getClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProductLikeList(struct soap *soap, struct __ns1__getProductLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getProductLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProductLikeList(struct soap *soap, const struct __ns1__getProductLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getProductLikeList(soap, &a->ns2__getProductLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProductLikeList(struct soap *soap, const char *tag, int id, const struct __ns1__getProductLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getProductLikeList(soap, "ns2:getProductLikeList", -1, &a->ns2__getProductLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductLikeList * SOAP_FMAC4 soap_in___ns1__getProductLikeList(struct soap *soap, const char *tag, struct __ns1__getProductLikeList *a, const char *type)
{
	size_t soap_flag_ns2__getProductLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getProductLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProductLikeList, sizeof(struct __ns1__getProductLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProductLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getProductLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getProductLikeList(soap, "ns2:getProductLikeList", &a->ns2__getProductLikeList_, "ns2:getProductLikeList"))
				{	soap_flag_ns2__getProductLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getProductLikeList * SOAP_FMAC2 soap_instantiate___ns1__getProductLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProductLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getProductLikeList *p;
	size_t k = sizeof(struct __ns1__getProductLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getProductLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getProductLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getProductLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getProductLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProductLikeList(struct soap *soap, const struct __ns1__getProductLikeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getProductLikeList(soap, tag ? tag : "-ns1:getProductLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductLikeList * SOAP_FMAC4 soap_get___ns1__getProductLikeList(struct soap *soap, struct __ns1__getProductLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProductLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteMessageFromClient(struct soap *soap, struct __ns1__deleteMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteMessageFromClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteMessageFromClient(struct soap *soap, const struct __ns1__deleteMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteMessageFromClient(soap, &a->ns2__deleteMessageFromClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteMessageFromClient(struct soap *soap, const char *tag, int id, const struct __ns1__deleteMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteMessageFromClient(soap, "ns2:deleteMessageFromClient", -1, &a->ns2__deleteMessageFromClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteMessageFromClient * SOAP_FMAC4 soap_in___ns1__deleteMessageFromClient(struct soap *soap, const char *tag, struct __ns1__deleteMessageFromClient *a, const char *type)
{
	size_t soap_flag_ns2__deleteMessageFromClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteMessageFromClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteMessageFromClient, sizeof(struct __ns1__deleteMessageFromClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteMessageFromClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteMessageFromClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteMessageFromClient(soap, "ns2:deleteMessageFromClient", &a->ns2__deleteMessageFromClient_, "ns2:deleteMessageFromClient"))
				{	soap_flag_ns2__deleteMessageFromClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__deleteMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteMessageFromClient *p;
	size_t k = sizeof(struct __ns1__deleteMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteMessageFromClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteMessageFromClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteMessageFromClient(struct soap *soap, const struct __ns1__deleteMessageFromClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteMessageFromClient(soap, tag ? tag : "-ns1:deleteMessageFromClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteMessageFromClient * SOAP_FMAC4 soap_get___ns1__deleteMessageFromClient(struct soap *soap, struct __ns1__deleteMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addProductType(struct soap *soap, struct __ns1__addProductType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__addProductType_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addProductType(struct soap *soap, const struct __ns1__addProductType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__addProductType(soap, &a->ns2__addProductType_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addProductType(struct soap *soap, const char *tag, int id, const struct __ns1__addProductType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__addProductType(soap, "ns2:addProductType", -1, &a->ns2__addProductType_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addProductType * SOAP_FMAC4 soap_in___ns1__addProductType(struct soap *soap, const char *tag, struct __ns1__addProductType *a, const char *type)
{
	size_t soap_flag_ns2__addProductType_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__addProductType*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addProductType, sizeof(struct __ns1__addProductType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addProductType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__addProductType_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__addProductType(soap, "ns2:addProductType", &a->ns2__addProductType_, "ns2:addProductType"))
				{	soap_flag_ns2__addProductType_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__addProductType * SOAP_FMAC2 soap_instantiate___ns1__addProductType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addProductType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__addProductType *p;
	size_t k = sizeof(struct __ns1__addProductType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__addProductType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__addProductType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__addProductType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__addProductType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addProductType(struct soap *soap, const struct __ns1__addProductType *a, const char *tag, const char *type)
{
	if (soap_out___ns1__addProductType(soap, tag ? tag : "-ns1:addProductType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addProductType * SOAP_FMAC4 soap_get___ns1__addProductType(struct soap *soap, struct __ns1__addProductType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOrderListByInfo(struct soap *soap, struct __ns1__getOrderListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getOrderListByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOrderListByInfo(struct soap *soap, const struct __ns1__getOrderListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getOrderListByInfo(soap, &a->ns2__getOrderListByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOrderListByInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getOrderListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getOrderListByInfo(soap, "ns2:getOrderListByInfo", -1, &a->ns2__getOrderListByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderListByInfo * SOAP_FMAC4 soap_in___ns1__getOrderListByInfo(struct soap *soap, const char *tag, struct __ns1__getOrderListByInfo *a, const char *type)
{
	size_t soap_flag_ns2__getOrderListByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getOrderListByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOrderListByInfo, sizeof(struct __ns1__getOrderListByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOrderListByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getOrderListByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getOrderListByInfo(soap, "ns2:getOrderListByInfo", &a->ns2__getOrderListByInfo_, "ns2:getOrderListByInfo"))
				{	soap_flag_ns2__getOrderListByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getOrderListByInfo * SOAP_FMAC2 soap_instantiate___ns1__getOrderListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOrderListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getOrderListByInfo *p;
	size_t k = sizeof(struct __ns1__getOrderListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getOrderListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getOrderListByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getOrderListByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getOrderListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOrderListByInfo(struct soap *soap, const struct __ns1__getOrderListByInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getOrderListByInfo(soap, tag ? tag : "-ns1:getOrderListByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderListByInfo * SOAP_FMAC4 soap_get___ns1__getOrderListByInfo(struct soap *soap, struct __ns1__getOrderListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOrderListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getShopList(struct soap *soap, struct __ns1__getShopList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getShopList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getShopList(struct soap *soap, const struct __ns1__getShopList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getShopList(soap, &a->ns2__getShopList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getShopList(struct soap *soap, const char *tag, int id, const struct __ns1__getShopList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getShopList(soap, "ns2:getShopList", -1, &a->ns2__getShopList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getShopList * SOAP_FMAC4 soap_in___ns1__getShopList(struct soap *soap, const char *tag, struct __ns1__getShopList *a, const char *type)
{
	size_t soap_flag_ns2__getShopList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getShopList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getShopList, sizeof(struct __ns1__getShopList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getShopList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getShopList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getShopList(soap, "ns2:getShopList", &a->ns2__getShopList_, "ns2:getShopList"))
				{	soap_flag_ns2__getShopList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getShopList * SOAP_FMAC2 soap_instantiate___ns1__getShopList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getShopList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getShopList *p;
	size_t k = sizeof(struct __ns1__getShopList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getShopList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getShopList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getShopList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getShopList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getShopList(struct soap *soap, const struct __ns1__getShopList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getShopList(soap, tag ? tag : "-ns1:getShopList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getShopList * SOAP_FMAC4 soap_get___ns1__getShopList(struct soap *soap, struct __ns1__getShopList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getShopList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClientLikeList(struct soap *soap, struct __ns1__getClientLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClientLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClientLikeList(struct soap *soap, const struct __ns1__getClientLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getClientLikeList(soap, &a->ns2__getClientLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClientLikeList(struct soap *soap, const char *tag, int id, const struct __ns1__getClientLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getClientLikeList(soap, "ns2:getClientLikeList", -1, &a->ns2__getClientLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClientLikeList * SOAP_FMAC4 soap_in___ns1__getClientLikeList(struct soap *soap, const char *tag, struct __ns1__getClientLikeList *a, const char *type)
{
	size_t soap_flag_ns2__getClientLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getClientLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClientLikeList, sizeof(struct __ns1__getClientLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClientLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClientLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getClientLikeList(soap, "ns2:getClientLikeList", &a->ns2__getClientLikeList_, "ns2:getClientLikeList"))
				{	soap_flag_ns2__getClientLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getClientLikeList * SOAP_FMAC2 soap_instantiate___ns1__getClientLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClientLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getClientLikeList *p;
	size_t k = sizeof(struct __ns1__getClientLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getClientLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getClientLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getClientLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getClientLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClientLikeList(struct soap *soap, const struct __ns1__getClientLikeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getClientLikeList(soap, tag ? tag : "-ns1:getClientLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClientLikeList * SOAP_FMAC4 soap_get___ns1__getClientLikeList(struct soap *soap, struct __ns1__getClientLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClientLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUnreadMessageFromShop(struct soap *soap, struct __ns1__getUnreadMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getUnreadMessageFromShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUnreadMessageFromShop(struct soap *soap, const struct __ns1__getUnreadMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getUnreadMessageFromShop(soap, &a->ns2__getUnreadMessageFromShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUnreadMessageFromShop(struct soap *soap, const char *tag, int id, const struct __ns1__getUnreadMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getUnreadMessageFromShop(soap, "ns2:getUnreadMessageFromShop", -1, &a->ns2__getUnreadMessageFromShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUnreadMessageFromShop * SOAP_FMAC4 soap_in___ns1__getUnreadMessageFromShop(struct soap *soap, const char *tag, struct __ns1__getUnreadMessageFromShop *a, const char *type)
{
	size_t soap_flag_ns2__getUnreadMessageFromShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getUnreadMessageFromShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUnreadMessageFromShop, sizeof(struct __ns1__getUnreadMessageFromShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUnreadMessageFromShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getUnreadMessageFromShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getUnreadMessageFromShop(soap, "ns2:getUnreadMessageFromShop", &a->ns2__getUnreadMessageFromShop_, "ns2:getUnreadMessageFromShop"))
				{	soap_flag_ns2__getUnreadMessageFromShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getUnreadMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__getUnreadMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUnreadMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getUnreadMessageFromShop *p;
	size_t k = sizeof(struct __ns1__getUnreadMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getUnreadMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getUnreadMessageFromShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getUnreadMessageFromShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getUnreadMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUnreadMessageFromShop(struct soap *soap, const struct __ns1__getUnreadMessageFromShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getUnreadMessageFromShop(soap, tag ? tag : "-ns1:getUnreadMessageFromShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUnreadMessageFromShop * SOAP_FMAC4 soap_get___ns1__getUnreadMessageFromShop(struct soap *soap, struct __ns1__getUnreadMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUnreadMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOrderLikeList(struct soap *soap, struct __ns1__getOrderLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getOrderLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOrderLikeList(struct soap *soap, const struct __ns1__getOrderLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getOrderLikeList(soap, &a->ns2__getOrderLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOrderLikeList(struct soap *soap, const char *tag, int id, const struct __ns1__getOrderLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getOrderLikeList(soap, "ns2:getOrderLikeList", -1, &a->ns2__getOrderLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderLikeList * SOAP_FMAC4 soap_in___ns1__getOrderLikeList(struct soap *soap, const char *tag, struct __ns1__getOrderLikeList *a, const char *type)
{
	size_t soap_flag_ns2__getOrderLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getOrderLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOrderLikeList, sizeof(struct __ns1__getOrderLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOrderLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getOrderLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getOrderLikeList(soap, "ns2:getOrderLikeList", &a->ns2__getOrderLikeList_, "ns2:getOrderLikeList"))
				{	soap_flag_ns2__getOrderLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getOrderLikeList * SOAP_FMAC2 soap_instantiate___ns1__getOrderLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOrderLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getOrderLikeList *p;
	size_t k = sizeof(struct __ns1__getOrderLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getOrderLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getOrderLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getOrderLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getOrderLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOrderLikeList(struct soap *soap, const struct __ns1__getOrderLikeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getOrderLikeList(soap, tag ? tag : "-ns1:getOrderLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderLikeList * SOAP_FMAC4 soap_get___ns1__getOrderLikeList(struct soap *soap, struct __ns1__getOrderLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOrderLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteMessageFromShop(struct soap *soap, struct __ns1__deleteMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteMessageFromShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteMessageFromShop(struct soap *soap, const struct __ns1__deleteMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteMessageFromShop(soap, &a->ns2__deleteMessageFromShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteMessageFromShop(struct soap *soap, const char *tag, int id, const struct __ns1__deleteMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteMessageFromShop(soap, "ns2:deleteMessageFromShop", -1, &a->ns2__deleteMessageFromShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteMessageFromShop * SOAP_FMAC4 soap_in___ns1__deleteMessageFromShop(struct soap *soap, const char *tag, struct __ns1__deleteMessageFromShop *a, const char *type)
{
	size_t soap_flag_ns2__deleteMessageFromShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteMessageFromShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteMessageFromShop, sizeof(struct __ns1__deleteMessageFromShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteMessageFromShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteMessageFromShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteMessageFromShop(soap, "ns2:deleteMessageFromShop", &a->ns2__deleteMessageFromShop_, "ns2:deleteMessageFromShop"))
				{	soap_flag_ns2__deleteMessageFromShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__deleteMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteMessageFromShop *p;
	size_t k = sizeof(struct __ns1__deleteMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteMessageFromShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteMessageFromShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteMessageFromShop(struct soap *soap, const struct __ns1__deleteMessageFromShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteMessageFromShop(soap, tag ? tag : "-ns1:deleteMessageFromShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteMessageFromShop * SOAP_FMAC4 soap_get___ns1__deleteMessageFromShop(struct soap *soap, struct __ns1__deleteMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMessageFromShop(struct soap *soap, struct __ns1__getMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getMessageFromShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMessageFromShop(struct soap *soap, const struct __ns1__getMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getMessageFromShop(soap, &a->ns2__getMessageFromShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMessageFromShop(struct soap *soap, const char *tag, int id, const struct __ns1__getMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getMessageFromShop(soap, "ns2:getMessageFromShop", -1, &a->ns2__getMessageFromShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessageFromShop * SOAP_FMAC4 soap_in___ns1__getMessageFromShop(struct soap *soap, const char *tag, struct __ns1__getMessageFromShop *a, const char *type)
{
	size_t soap_flag_ns2__getMessageFromShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMessageFromShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMessageFromShop, sizeof(struct __ns1__getMessageFromShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMessageFromShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getMessageFromShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getMessageFromShop(soap, "ns2:getMessageFromShop", &a->ns2__getMessageFromShop_, "ns2:getMessageFromShop"))
				{	soap_flag_ns2__getMessageFromShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__getMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMessageFromShop *p;
	size_t k = sizeof(struct __ns1__getMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getMessageFromShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getMessageFromShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMessageFromShop(struct soap *soap, const struct __ns1__getMessageFromShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMessageFromShop(soap, tag ? tag : "-ns1:getMessageFromShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessageFromShop * SOAP_FMAC4 soap_get___ns1__getMessageFromShop(struct soap *soap, struct __ns1__getMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getShopLikeList(struct soap *soap, struct __ns1__getShopLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getShopLikeList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getShopLikeList(struct soap *soap, const struct __ns1__getShopLikeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getShopLikeList(soap, &a->ns2__getShopLikeList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getShopLikeList(struct soap *soap, const char *tag, int id, const struct __ns1__getShopLikeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getShopLikeList(soap, "ns2:getShopLikeList", -1, &a->ns2__getShopLikeList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getShopLikeList * SOAP_FMAC4 soap_in___ns1__getShopLikeList(struct soap *soap, const char *tag, struct __ns1__getShopLikeList *a, const char *type)
{
	size_t soap_flag_ns2__getShopLikeList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getShopLikeList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getShopLikeList, sizeof(struct __ns1__getShopLikeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getShopLikeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getShopLikeList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getShopLikeList(soap, "ns2:getShopLikeList", &a->ns2__getShopLikeList_, "ns2:getShopLikeList"))
				{	soap_flag_ns2__getShopLikeList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getShopLikeList * SOAP_FMAC2 soap_instantiate___ns1__getShopLikeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getShopLikeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getShopLikeList *p;
	size_t k = sizeof(struct __ns1__getShopLikeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getShopLikeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getShopLikeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getShopLikeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getShopLikeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getShopLikeList(struct soap *soap, const struct __ns1__getShopLikeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getShopLikeList(soap, tag ? tag : "-ns1:getShopLikeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getShopLikeList * SOAP_FMAC4 soap_get___ns1__getShopLikeList(struct soap *soap, struct __ns1__getShopLikeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getShopLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsertMessage(struct soap *soap, struct __ns1__InsertMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__InsertMessage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsertMessage(struct soap *soap, const struct __ns1__InsertMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__InsertMessage(soap, &a->ns2__InsertMessage_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsertMessage(struct soap *soap, const char *tag, int id, const struct __ns1__InsertMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__InsertMessage(soap, "ns2:InsertMessage", -1, &a->ns2__InsertMessage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertMessage * SOAP_FMAC4 soap_in___ns1__InsertMessage(struct soap *soap, const char *tag, struct __ns1__InsertMessage *a, const char *type)
{
	size_t soap_flag_ns2__InsertMessage_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsertMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsertMessage, sizeof(struct __ns1__InsertMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsertMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__InsertMessage_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__InsertMessage(soap, "ns2:InsertMessage", &a->ns2__InsertMessage_, "ns2:InsertMessage"))
				{	soap_flag_ns2__InsertMessage_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsertMessage * SOAP_FMAC2 soap_instantiate___ns1__InsertMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsertMessage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsertMessage *p;
	size_t k = sizeof(struct __ns1__InsertMessage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InsertMessage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InsertMessage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InsertMessage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsertMessage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsertMessage(struct soap *soap, const struct __ns1__InsertMessage *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsertMessage(soap, tag ? tag : "-ns1:InsertMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertMessage * SOAP_FMAC4 soap_get___ns1__InsertMessage(struct soap *soap, struct __ns1__InsertMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsertMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateHistory(struct soap *soap, struct __ns1__updateHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__updateHistory_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateHistory(struct soap *soap, const struct __ns1__updateHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__updateHistory(soap, &a->ns2__updateHistory_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateHistory(struct soap *soap, const char *tag, int id, const struct __ns1__updateHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__updateHistory(soap, "ns2:updateHistory", -1, &a->ns2__updateHistory_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateHistory * SOAP_FMAC4 soap_in___ns1__updateHistory(struct soap *soap, const char *tag, struct __ns1__updateHistory *a, const char *type)
{
	size_t soap_flag_ns2__updateHistory_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateHistory*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateHistory, sizeof(struct __ns1__updateHistory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__updateHistory_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__updateHistory(soap, "ns2:updateHistory", &a->ns2__updateHistory_, "ns2:updateHistory"))
				{	soap_flag_ns2__updateHistory_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateHistory * SOAP_FMAC2 soap_instantiate___ns1__updateHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateHistory *p;
	size_t k = sizeof(struct __ns1__updateHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__updateHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__updateHistory);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__updateHistory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateHistory(struct soap *soap, const struct __ns1__updateHistory *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateHistory(soap, tag ? tag : "-ns1:updateHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateHistory * SOAP_FMAC4 soap_get___ns1__updateHistory(struct soap *soap, struct __ns1__updateHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getReadMessageFromClient(struct soap *soap, struct __ns1__getReadMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getReadMessageFromClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getReadMessageFromClient(struct soap *soap, const struct __ns1__getReadMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getReadMessageFromClient(soap, &a->ns2__getReadMessageFromClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getReadMessageFromClient(struct soap *soap, const char *tag, int id, const struct __ns1__getReadMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getReadMessageFromClient(soap, "ns2:getReadMessageFromClient", -1, &a->ns2__getReadMessageFromClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getReadMessageFromClient * SOAP_FMAC4 soap_in___ns1__getReadMessageFromClient(struct soap *soap, const char *tag, struct __ns1__getReadMessageFromClient *a, const char *type)
{
	size_t soap_flag_ns2__getReadMessageFromClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getReadMessageFromClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getReadMessageFromClient, sizeof(struct __ns1__getReadMessageFromClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getReadMessageFromClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getReadMessageFromClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getReadMessageFromClient(soap, "ns2:getReadMessageFromClient", &a->ns2__getReadMessageFromClient_, "ns2:getReadMessageFromClient"))
				{	soap_flag_ns2__getReadMessageFromClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getReadMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__getReadMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getReadMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getReadMessageFromClient *p;
	size_t k = sizeof(struct __ns1__getReadMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getReadMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getReadMessageFromClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getReadMessageFromClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getReadMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getReadMessageFromClient(struct soap *soap, const struct __ns1__getReadMessageFromClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getReadMessageFromClient(soap, tag ? tag : "-ns1:getReadMessageFromClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getReadMessageFromClient * SOAP_FMAC4 soap_get___ns1__getReadMessageFromClient(struct soap *soap, struct __ns1__getReadMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getReadMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOrderListHistory(struct soap *soap, struct __ns1__getOrderListHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getOrderListHistory_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOrderListHistory(struct soap *soap, const struct __ns1__getOrderListHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getOrderListHistory(soap, &a->ns2__getOrderListHistory_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOrderListHistory(struct soap *soap, const char *tag, int id, const struct __ns1__getOrderListHistory *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getOrderListHistory(soap, "ns2:getOrderListHistory", -1, &a->ns2__getOrderListHistory_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderListHistory * SOAP_FMAC4 soap_in___ns1__getOrderListHistory(struct soap *soap, const char *tag, struct __ns1__getOrderListHistory *a, const char *type)
{
	size_t soap_flag_ns2__getOrderListHistory_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getOrderListHistory*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOrderListHistory, sizeof(struct __ns1__getOrderListHistory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOrderListHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getOrderListHistory_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getOrderListHistory(soap, "ns2:getOrderListHistory", &a->ns2__getOrderListHistory_, "ns2:getOrderListHistory"))
				{	soap_flag_ns2__getOrderListHistory_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getOrderListHistory * SOAP_FMAC2 soap_instantiate___ns1__getOrderListHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOrderListHistory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getOrderListHistory *p;
	size_t k = sizeof(struct __ns1__getOrderListHistory);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getOrderListHistory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getOrderListHistory);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getOrderListHistory, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getOrderListHistory location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOrderListHistory(struct soap *soap, const struct __ns1__getOrderListHistory *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getOrderListHistory(soap, tag ? tag : "-ns1:getOrderListHistory", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderListHistory * SOAP_FMAC4 soap_get___ns1__getOrderListHistory(struct soap *soap, struct __ns1__getOrderListHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOrderListHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProductList(struct soap *soap, struct __ns1__getProductList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getProductList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProductList(struct soap *soap, const struct __ns1__getProductList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getProductList(soap, &a->ns2__getProductList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProductList(struct soap *soap, const char *tag, int id, const struct __ns1__getProductList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getProductList(soap, "ns2:getProductList", -1, &a->ns2__getProductList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductList * SOAP_FMAC4 soap_in___ns1__getProductList(struct soap *soap, const char *tag, struct __ns1__getProductList *a, const char *type)
{
	size_t soap_flag_ns2__getProductList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getProductList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProductList, sizeof(struct __ns1__getProductList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProductList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getProductList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getProductList(soap, "ns2:getProductList", &a->ns2__getProductList_, "ns2:getProductList"))
				{	soap_flag_ns2__getProductList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getProductList * SOAP_FMAC2 soap_instantiate___ns1__getProductList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProductList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getProductList *p;
	size_t k = sizeof(struct __ns1__getProductList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getProductList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getProductList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getProductList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getProductList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProductList(struct soap *soap, const struct __ns1__getProductList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getProductList(soap, tag ? tag : "-ns1:getProductList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductList * SOAP_FMAC4 soap_get___ns1__getProductList(struct soap *soap, struct __ns1__getProductList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProductList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteShopByNameAndPwd(struct soap *soap, struct __ns1__deleteShopByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteShopByNameAndPwd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteShopByNameAndPwd(struct soap *soap, const struct __ns1__deleteShopByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteShopByNameAndPwd(soap, &a->ns2__deleteShopByNameAndPwd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteShopByNameAndPwd(struct soap *soap, const char *tag, int id, const struct __ns1__deleteShopByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteShopByNameAndPwd(soap, "ns2:deleteShopByNameAndPwd", -1, &a->ns2__deleteShopByNameAndPwd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteShopByNameAndPwd * SOAP_FMAC4 soap_in___ns1__deleteShopByNameAndPwd(struct soap *soap, const char *tag, struct __ns1__deleteShopByNameAndPwd *a, const char *type)
{
	size_t soap_flag_ns2__deleteShopByNameAndPwd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteShopByNameAndPwd*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteShopByNameAndPwd, sizeof(struct __ns1__deleteShopByNameAndPwd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteShopByNameAndPwd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteShopByNameAndPwd_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteShopByNameAndPwd(soap, "ns2:deleteShopByNameAndPwd", &a->ns2__deleteShopByNameAndPwd_, "ns2:deleteShopByNameAndPwd"))
				{	soap_flag_ns2__deleteShopByNameAndPwd_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteShopByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__deleteShopByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteShopByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteShopByNameAndPwd *p;
	size_t k = sizeof(struct __ns1__deleteShopByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteShopByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteShopByNameAndPwd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteShopByNameAndPwd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteShopByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteShopByNameAndPwd(struct soap *soap, const struct __ns1__deleteShopByNameAndPwd *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteShopByNameAndPwd(soap, tag ? tag : "-ns1:deleteShopByNameAndPwd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteShopByNameAndPwd * SOAP_FMAC4 soap_get___ns1__deleteShopByNameAndPwd(struct soap *soap, struct __ns1__deleteShopByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteShopByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addOrder(struct soap *soap, struct __ns1__addOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__addOrder_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addOrder(struct soap *soap, const struct __ns1__addOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__addOrder(soap, &a->ns2__addOrder_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addOrder(struct soap *soap, const char *tag, int id, const struct __ns1__addOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__addOrder(soap, "ns2:addOrder", -1, &a->ns2__addOrder_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addOrder * SOAP_FMAC4 soap_in___ns1__addOrder(struct soap *soap, const char *tag, struct __ns1__addOrder *a, const char *type)
{
	size_t soap_flag_ns2__addOrder_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__addOrder*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addOrder, sizeof(struct __ns1__addOrder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__addOrder_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__addOrder(soap, "ns2:addOrder", &a->ns2__addOrder_, "ns2:addOrder"))
				{	soap_flag_ns2__addOrder_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__addOrder * SOAP_FMAC2 soap_instantiate___ns1__addOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addOrder(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__addOrder *p;
	size_t k = sizeof(struct __ns1__addOrder);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__addOrder, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__addOrder);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__addOrder, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__addOrder location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addOrder(struct soap *soap, const struct __ns1__addOrder *a, const char *tag, const char *type)
{
	if (soap_out___ns1__addOrder(soap, tag ? tag : "-ns1:addOrder", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addOrder * SOAP_FMAC4 soap_get___ns1__addOrder(struct soap *soap, struct __ns1__addOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMessageFromClient(struct soap *soap, struct __ns1__getMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getMessageFromClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMessageFromClient(struct soap *soap, const struct __ns1__getMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getMessageFromClient(soap, &a->ns2__getMessageFromClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMessageFromClient(struct soap *soap, const char *tag, int id, const struct __ns1__getMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getMessageFromClient(soap, "ns2:getMessageFromClient", -1, &a->ns2__getMessageFromClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessageFromClient * SOAP_FMAC4 soap_in___ns1__getMessageFromClient(struct soap *soap, const char *tag, struct __ns1__getMessageFromClient *a, const char *type)
{
	size_t soap_flag_ns2__getMessageFromClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMessageFromClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMessageFromClient, sizeof(struct __ns1__getMessageFromClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMessageFromClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getMessageFromClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getMessageFromClient(soap, "ns2:getMessageFromClient", &a->ns2__getMessageFromClient_, "ns2:getMessageFromClient"))
				{	soap_flag_ns2__getMessageFromClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__getMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMessageFromClient *p;
	size_t k = sizeof(struct __ns1__getMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getMessageFromClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getMessageFromClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMessageFromClient(struct soap *soap, const struct __ns1__getMessageFromClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMessageFromClient(soap, tag ? tag : "-ns1:getMessageFromClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMessageFromClient * SOAP_FMAC4 soap_get___ns1__getMessageFromClient(struct soap *soap, struct __ns1__getMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateProductByInfo(struct soap *soap, struct __ns1__updateProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__updateProductByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateProductByInfo(struct soap *soap, const struct __ns1__updateProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__updateProductByInfo(soap, &a->ns2__updateProductByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateProductByInfo(struct soap *soap, const char *tag, int id, const struct __ns1__updateProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__updateProductByInfo(soap, "ns2:updateProductByInfo", -1, &a->ns2__updateProductByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateProductByInfo * SOAP_FMAC4 soap_in___ns1__updateProductByInfo(struct soap *soap, const char *tag, struct __ns1__updateProductByInfo *a, const char *type)
{
	size_t soap_flag_ns2__updateProductByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateProductByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateProductByInfo, sizeof(struct __ns1__updateProductByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateProductByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__updateProductByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__updateProductByInfo(soap, "ns2:updateProductByInfo", &a->ns2__updateProductByInfo_, "ns2:updateProductByInfo"))
				{	soap_flag_ns2__updateProductByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateProductByInfo * SOAP_FMAC2 soap_instantiate___ns1__updateProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateProductByInfo *p;
	size_t k = sizeof(struct __ns1__updateProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__updateProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__updateProductByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__updateProductByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateProductByInfo(struct soap *soap, const struct __ns1__updateProductByInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateProductByInfo(soap, tag ? tag : "-ns1:updateProductByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateProductByInfo * SOAP_FMAC4 soap_get___ns1__updateProductByInfo(struct soap *soap, struct __ns1__updateProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUnreadMessageFromClient(struct soap *soap, struct __ns1__getUnreadMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getUnreadMessageFromClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUnreadMessageFromClient(struct soap *soap, const struct __ns1__getUnreadMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getUnreadMessageFromClient(soap, &a->ns2__getUnreadMessageFromClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUnreadMessageFromClient(struct soap *soap, const char *tag, int id, const struct __ns1__getUnreadMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getUnreadMessageFromClient(soap, "ns2:getUnreadMessageFromClient", -1, &a->ns2__getUnreadMessageFromClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUnreadMessageFromClient * SOAP_FMAC4 soap_in___ns1__getUnreadMessageFromClient(struct soap *soap, const char *tag, struct __ns1__getUnreadMessageFromClient *a, const char *type)
{
	size_t soap_flag_ns2__getUnreadMessageFromClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getUnreadMessageFromClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUnreadMessageFromClient, sizeof(struct __ns1__getUnreadMessageFromClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUnreadMessageFromClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getUnreadMessageFromClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getUnreadMessageFromClient(soap, "ns2:getUnreadMessageFromClient", &a->ns2__getUnreadMessageFromClient_, "ns2:getUnreadMessageFromClient"))
				{	soap_flag_ns2__getUnreadMessageFromClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getUnreadMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__getUnreadMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUnreadMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getUnreadMessageFromClient *p;
	size_t k = sizeof(struct __ns1__getUnreadMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getUnreadMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getUnreadMessageFromClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getUnreadMessageFromClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getUnreadMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUnreadMessageFromClient(struct soap *soap, const struct __ns1__getUnreadMessageFromClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getUnreadMessageFromClient(soap, tag ? tag : "-ns1:getUnreadMessageFromClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUnreadMessageFromClient * SOAP_FMAC4 soap_get___ns1__getUnreadMessageFromClient(struct soap *soap, struct __ns1__getUnreadMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUnreadMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateMessageFromClient(struct soap *soap, struct __ns1__updateMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__updateMessageFromClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateMessageFromClient(struct soap *soap, const struct __ns1__updateMessageFromClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__updateMessageFromClient(soap, &a->ns2__updateMessageFromClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateMessageFromClient(struct soap *soap, const char *tag, int id, const struct __ns1__updateMessageFromClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__updateMessageFromClient(soap, "ns2:updateMessageFromClient", -1, &a->ns2__updateMessageFromClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateMessageFromClient * SOAP_FMAC4 soap_in___ns1__updateMessageFromClient(struct soap *soap, const char *tag, struct __ns1__updateMessageFromClient *a, const char *type)
{
	size_t soap_flag_ns2__updateMessageFromClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateMessageFromClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateMessageFromClient, sizeof(struct __ns1__updateMessageFromClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateMessageFromClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__updateMessageFromClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__updateMessageFromClient(soap, "ns2:updateMessageFromClient", &a->ns2__updateMessageFromClient_, "ns2:updateMessageFromClient"))
				{	soap_flag_ns2__updateMessageFromClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateMessageFromClient * SOAP_FMAC2 soap_instantiate___ns1__updateMessageFromClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateMessageFromClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateMessageFromClient *p;
	size_t k = sizeof(struct __ns1__updateMessageFromClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__updateMessageFromClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__updateMessageFromClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__updateMessageFromClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateMessageFromClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateMessageFromClient(struct soap *soap, const struct __ns1__updateMessageFromClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateMessageFromClient(soap, tag ? tag : "-ns1:updateMessageFromClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateMessageFromClient * SOAP_FMAC4 soap_get___ns1__updateMessageFromClient(struct soap *soap, struct __ns1__updateMessageFromClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__purchaseProduct(struct soap *soap, struct __ns1__purchaseProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__purchaseProduct_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__purchaseProduct(struct soap *soap, const struct __ns1__purchaseProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__purchaseProduct(soap, &a->ns2__purchaseProduct_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__purchaseProduct(struct soap *soap, const char *tag, int id, const struct __ns1__purchaseProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__purchaseProduct(soap, "ns2:purchaseProduct", -1, &a->ns2__purchaseProduct_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__purchaseProduct * SOAP_FMAC4 soap_in___ns1__purchaseProduct(struct soap *soap, const char *tag, struct __ns1__purchaseProduct *a, const char *type)
{
	size_t soap_flag_ns2__purchaseProduct_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__purchaseProduct*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__purchaseProduct, sizeof(struct __ns1__purchaseProduct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__purchaseProduct(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__purchaseProduct_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__purchaseProduct(soap, "ns2:purchaseProduct", &a->ns2__purchaseProduct_, "ns2:purchaseProduct"))
				{	soap_flag_ns2__purchaseProduct_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__purchaseProduct * SOAP_FMAC2 soap_instantiate___ns1__purchaseProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__purchaseProduct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__purchaseProduct *p;
	size_t k = sizeof(struct __ns1__purchaseProduct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__purchaseProduct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__purchaseProduct);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__purchaseProduct, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__purchaseProduct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__purchaseProduct(struct soap *soap, const struct __ns1__purchaseProduct *a, const char *tag, const char *type)
{
	if (soap_out___ns1__purchaseProduct(soap, tag ? tag : "-ns1:purchaseProduct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__purchaseProduct * SOAP_FMAC4 soap_get___ns1__purchaseProduct(struct soap *soap, struct __ns1__purchaseProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__purchaseProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getClientList(struct soap *soap, struct __ns1__getClientList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getClientList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getClientList(struct soap *soap, const struct __ns1__getClientList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getClientList(soap, &a->ns2__getClientList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getClientList(struct soap *soap, const char *tag, int id, const struct __ns1__getClientList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getClientList(soap, "ns2:getClientList", -1, &a->ns2__getClientList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClientList * SOAP_FMAC4 soap_in___ns1__getClientList(struct soap *soap, const char *tag, struct __ns1__getClientList *a, const char *type)
{
	size_t soap_flag_ns2__getClientList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getClientList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getClientList, sizeof(struct __ns1__getClientList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getClientList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getClientList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getClientList(soap, "ns2:getClientList", &a->ns2__getClientList_, "ns2:getClientList"))
				{	soap_flag_ns2__getClientList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getClientList * SOAP_FMAC2 soap_instantiate___ns1__getClientList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getClientList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getClientList *p;
	size_t k = sizeof(struct __ns1__getClientList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getClientList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getClientList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getClientList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getClientList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getClientList(struct soap *soap, const struct __ns1__getClientList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getClientList(soap, tag ? tag : "-ns1:getClientList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getClientList * SOAP_FMAC4 soap_get___ns1__getClientList(struct soap *soap, struct __ns1__getClientList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getClientList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProductTypeByProName(struct soap *soap, struct __ns1__getProductTypeByProName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getProductTypeByProName_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProductTypeByProName(struct soap *soap, const struct __ns1__getProductTypeByProName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getProductTypeByProName(soap, &a->ns2__getProductTypeByProName_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProductTypeByProName(struct soap *soap, const char *tag, int id, const struct __ns1__getProductTypeByProName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getProductTypeByProName(soap, "ns2:getProductTypeByProName", -1, &a->ns2__getProductTypeByProName_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductTypeByProName * SOAP_FMAC4 soap_in___ns1__getProductTypeByProName(struct soap *soap, const char *tag, struct __ns1__getProductTypeByProName *a, const char *type)
{
	size_t soap_flag_ns2__getProductTypeByProName_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getProductTypeByProName*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProductTypeByProName, sizeof(struct __ns1__getProductTypeByProName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProductTypeByProName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getProductTypeByProName_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getProductTypeByProName(soap, "ns2:getProductTypeByProName", &a->ns2__getProductTypeByProName_, "ns2:getProductTypeByProName"))
				{	soap_flag_ns2__getProductTypeByProName_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getProductTypeByProName * SOAP_FMAC2 soap_instantiate___ns1__getProductTypeByProName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProductTypeByProName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getProductTypeByProName *p;
	size_t k = sizeof(struct __ns1__getProductTypeByProName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getProductTypeByProName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getProductTypeByProName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getProductTypeByProName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getProductTypeByProName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProductTypeByProName(struct soap *soap, const struct __ns1__getProductTypeByProName *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getProductTypeByProName(soap, tag ? tag : "-ns1:getProductTypeByProName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductTypeByProName * SOAP_FMAC4 soap_get___ns1__getProductTypeByProName(struct soap *soap, struct __ns1__getProductTypeByProName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProductTypeByProName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateMessageFromShop(struct soap *soap, struct __ns1__updateMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__updateMessageFromShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateMessageFromShop(struct soap *soap, const struct __ns1__updateMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__updateMessageFromShop(soap, &a->ns2__updateMessageFromShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateMessageFromShop(struct soap *soap, const char *tag, int id, const struct __ns1__updateMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__updateMessageFromShop(soap, "ns2:updateMessageFromShop", -1, &a->ns2__updateMessageFromShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateMessageFromShop * SOAP_FMAC4 soap_in___ns1__updateMessageFromShop(struct soap *soap, const char *tag, struct __ns1__updateMessageFromShop *a, const char *type)
{
	size_t soap_flag_ns2__updateMessageFromShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateMessageFromShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateMessageFromShop, sizeof(struct __ns1__updateMessageFromShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateMessageFromShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__updateMessageFromShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__updateMessageFromShop(soap, "ns2:updateMessageFromShop", &a->ns2__updateMessageFromShop_, "ns2:updateMessageFromShop"))
				{	soap_flag_ns2__updateMessageFromShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__updateMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateMessageFromShop *p;
	size_t k = sizeof(struct __ns1__updateMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__updateMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__updateMessageFromShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__updateMessageFromShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateMessageFromShop(struct soap *soap, const struct __ns1__updateMessageFromShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateMessageFromShop(soap, tag ? tag : "-ns1:updateMessageFromShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateMessageFromShop * SOAP_FMAC4 soap_get___ns1__updateMessageFromShop(struct soap *soap, struct __ns1__updateMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsertShop(struct soap *soap, struct __ns1__InsertShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__InsertShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsertShop(struct soap *soap, const struct __ns1__InsertShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__InsertShop(soap, &a->ns2__InsertShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsertShop(struct soap *soap, const char *tag, int id, const struct __ns1__InsertShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__InsertShop(soap, "ns2:InsertShop", -1, &a->ns2__InsertShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertShop * SOAP_FMAC4 soap_in___ns1__InsertShop(struct soap *soap, const char *tag, struct __ns1__InsertShop *a, const char *type)
{
	size_t soap_flag_ns2__InsertShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsertShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsertShop, sizeof(struct __ns1__InsertShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsertShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__InsertShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__InsertShop(soap, "ns2:InsertShop", &a->ns2__InsertShop_, "ns2:InsertShop"))
				{	soap_flag_ns2__InsertShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsertShop * SOAP_FMAC2 soap_instantiate___ns1__InsertShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsertShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsertShop *p;
	size_t k = sizeof(struct __ns1__InsertShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__InsertShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__InsertShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__InsertShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsertShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsertShop(struct soap *soap, const struct __ns1__InsertShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsertShop(soap, tag ? tag : "-ns1:InsertShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertShop * SOAP_FMAC4 soap_get___ns1__InsertShop(struct soap *soap, struct __ns1__InsertShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsertShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteClientByNameAndPwd(struct soap *soap, struct __ns1__deleteClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteClientByNameAndPwd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteClientByNameAndPwd(struct soap *soap, const struct __ns1__deleteClientByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteClientByNameAndPwd(soap, &a->ns2__deleteClientByNameAndPwd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteClientByNameAndPwd(struct soap *soap, const char *tag, int id, const struct __ns1__deleteClientByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteClientByNameAndPwd(soap, "ns2:deleteClientByNameAndPwd", -1, &a->ns2__deleteClientByNameAndPwd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteClientByNameAndPwd * SOAP_FMAC4 soap_in___ns1__deleteClientByNameAndPwd(struct soap *soap, const char *tag, struct __ns1__deleteClientByNameAndPwd *a, const char *type)
{
	size_t soap_flag_ns2__deleteClientByNameAndPwd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteClientByNameAndPwd*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteClientByNameAndPwd, sizeof(struct __ns1__deleteClientByNameAndPwd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteClientByNameAndPwd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteClientByNameAndPwd_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteClientByNameAndPwd(soap, "ns2:deleteClientByNameAndPwd", &a->ns2__deleteClientByNameAndPwd_, "ns2:deleteClientByNameAndPwd"))
				{	soap_flag_ns2__deleteClientByNameAndPwd_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteClientByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__deleteClientByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteClientByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteClientByNameAndPwd *p;
	size_t k = sizeof(struct __ns1__deleteClientByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteClientByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteClientByNameAndPwd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteClientByNameAndPwd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteClientByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteClientByNameAndPwd(struct soap *soap, const struct __ns1__deleteClientByNameAndPwd *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteClientByNameAndPwd(soap, tag ? tag : "-ns1:deleteClientByNameAndPwd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteClientByNameAndPwd * SOAP_FMAC4 soap_get___ns1__deleteClientByNameAndPwd(struct soap *soap, struct __ns1__deleteClientByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteProductByInfo(struct soap *soap, struct __ns1__deleteProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteProductByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteProductByInfo(struct soap *soap, const struct __ns1__deleteProductByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteProductByInfo(soap, &a->ns2__deleteProductByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteProductByInfo(struct soap *soap, const char *tag, int id, const struct __ns1__deleteProductByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteProductByInfo(soap, "ns2:deleteProductByInfo", -1, &a->ns2__deleteProductByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteProductByInfo * SOAP_FMAC4 soap_in___ns1__deleteProductByInfo(struct soap *soap, const char *tag, struct __ns1__deleteProductByInfo *a, const char *type)
{
	size_t soap_flag_ns2__deleteProductByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteProductByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteProductByInfo, sizeof(struct __ns1__deleteProductByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteProductByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteProductByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteProductByInfo(soap, "ns2:deleteProductByInfo", &a->ns2__deleteProductByInfo_, "ns2:deleteProductByInfo"))
				{	soap_flag_ns2__deleteProductByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteProductByInfo * SOAP_FMAC2 soap_instantiate___ns1__deleteProductByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteProductByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteProductByInfo *p;
	size_t k = sizeof(struct __ns1__deleteProductByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteProductByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteProductByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteProductByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteProductByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteProductByInfo(struct soap *soap, const struct __ns1__deleteProductByInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteProductByInfo(soap, tag ? tag : "-ns1:deleteProductByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteProductByInfo * SOAP_FMAC4 soap_get___ns1__deleteProductByInfo(struct soap *soap, struct __ns1__deleteProductByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateClient(struct soap *soap, struct __ns1__updateClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__updateClient_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateClient(struct soap *soap, const struct __ns1__updateClient *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__updateClient(soap, &a->ns2__updateClient_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateClient(struct soap *soap, const char *tag, int id, const struct __ns1__updateClient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__updateClient(soap, "ns2:updateClient", -1, &a->ns2__updateClient_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateClient * SOAP_FMAC4 soap_in___ns1__updateClient(struct soap *soap, const char *tag, struct __ns1__updateClient *a, const char *type)
{
	size_t soap_flag_ns2__updateClient_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateClient*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateClient, sizeof(struct __ns1__updateClient), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateClient(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__updateClient_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__updateClient(soap, "ns2:updateClient", &a->ns2__updateClient_, "ns2:updateClient"))
				{	soap_flag_ns2__updateClient_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateClient * SOAP_FMAC2 soap_instantiate___ns1__updateClient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateClient(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateClient *p;
	size_t k = sizeof(struct __ns1__updateClient);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__updateClient, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__updateClient);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__updateClient, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateClient location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateClient(struct soap *soap, const struct __ns1__updateClient *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateClient(soap, tag ? tag : "-ns1:updateClient", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateClient * SOAP_FMAC4 soap_get___ns1__updateClient(struct soap *soap, struct __ns1__updateClient *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getReadMessageFromShop(struct soap *soap, struct __ns1__getReadMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getReadMessageFromShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getReadMessageFromShop(struct soap *soap, const struct __ns1__getReadMessageFromShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getReadMessageFromShop(soap, &a->ns2__getReadMessageFromShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getReadMessageFromShop(struct soap *soap, const char *tag, int id, const struct __ns1__getReadMessageFromShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getReadMessageFromShop(soap, "ns2:getReadMessageFromShop", -1, &a->ns2__getReadMessageFromShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getReadMessageFromShop * SOAP_FMAC4 soap_in___ns1__getReadMessageFromShop(struct soap *soap, const char *tag, struct __ns1__getReadMessageFromShop *a, const char *type)
{
	size_t soap_flag_ns2__getReadMessageFromShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getReadMessageFromShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getReadMessageFromShop, sizeof(struct __ns1__getReadMessageFromShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getReadMessageFromShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getReadMessageFromShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getReadMessageFromShop(soap, "ns2:getReadMessageFromShop", &a->ns2__getReadMessageFromShop_, "ns2:getReadMessageFromShop"))
				{	soap_flag_ns2__getReadMessageFromShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getReadMessageFromShop * SOAP_FMAC2 soap_instantiate___ns1__getReadMessageFromShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getReadMessageFromShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getReadMessageFromShop *p;
	size_t k = sizeof(struct __ns1__getReadMessageFromShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getReadMessageFromShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getReadMessageFromShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getReadMessageFromShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getReadMessageFromShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getReadMessageFromShop(struct soap *soap, const struct __ns1__getReadMessageFromShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getReadMessageFromShop(soap, tag ? tag : "-ns1:getReadMessageFromShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getReadMessageFromShop * SOAP_FMAC4 soap_get___ns1__getReadMessageFromShop(struct soap *soap, struct __ns1__getReadMessageFromShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getReadMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProductListByInfo(struct soap *soap, struct __ns1__getProductListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getProductListByInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProductListByInfo(struct soap *soap, const struct __ns1__getProductListByInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getProductListByInfo(soap, &a->ns2__getProductListByInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProductListByInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getProductListByInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getProductListByInfo(soap, "ns2:getProductListByInfo", -1, &a->ns2__getProductListByInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductListByInfo * SOAP_FMAC4 soap_in___ns1__getProductListByInfo(struct soap *soap, const char *tag, struct __ns1__getProductListByInfo *a, const char *type)
{
	size_t soap_flag_ns2__getProductListByInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getProductListByInfo*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProductListByInfo, sizeof(struct __ns1__getProductListByInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProductListByInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getProductListByInfo_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getProductListByInfo(soap, "ns2:getProductListByInfo", &a->ns2__getProductListByInfo_, "ns2:getProductListByInfo"))
				{	soap_flag_ns2__getProductListByInfo_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getProductListByInfo * SOAP_FMAC2 soap_instantiate___ns1__getProductListByInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProductListByInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getProductListByInfo *p;
	size_t k = sizeof(struct __ns1__getProductListByInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getProductListByInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getProductListByInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getProductListByInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getProductListByInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProductListByInfo(struct soap *soap, const struct __ns1__getProductListByInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getProductListByInfo(soap, tag ? tag : "-ns1:getProductListByInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProductListByInfo * SOAP_FMAC4 soap_get___ns1__getProductListByInfo(struct soap *soap, struct __ns1__getProductListByInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProductListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateShop(struct soap *soap, struct __ns1__updateShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__updateShop_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateShop(struct soap *soap, const struct __ns1__updateShop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__updateShop(soap, &a->ns2__updateShop_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateShop(struct soap *soap, const char *tag, int id, const struct __ns1__updateShop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__updateShop(soap, "ns2:updateShop", -1, &a->ns2__updateShop_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateShop * SOAP_FMAC4 soap_in___ns1__updateShop(struct soap *soap, const char *tag, struct __ns1__updateShop *a, const char *type)
{
	size_t soap_flag_ns2__updateShop_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateShop*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateShop, sizeof(struct __ns1__updateShop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateShop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__updateShop_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__updateShop(soap, "ns2:updateShop", &a->ns2__updateShop_, "ns2:updateShop"))
				{	soap_flag_ns2__updateShop_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateShop * SOAP_FMAC2 soap_instantiate___ns1__updateShop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateShop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateShop *p;
	size_t k = sizeof(struct __ns1__updateShop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__updateShop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__updateShop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__updateShop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateShop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateShop(struct soap *soap, const struct __ns1__updateShop *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateShop(soap, tag ? tag : "-ns1:updateShop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateShop * SOAP_FMAC4 soap_get___ns1__updateShop(struct soap *soap, struct __ns1__updateShop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getShopByNameAndPwd(struct soap *soap, struct __ns1__getShopByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getShopByNameAndPwd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getShopByNameAndPwd(struct soap *soap, const struct __ns1__getShopByNameAndPwd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getShopByNameAndPwd(soap, &a->ns2__getShopByNameAndPwd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getShopByNameAndPwd(struct soap *soap, const char *tag, int id, const struct __ns1__getShopByNameAndPwd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getShopByNameAndPwd(soap, "ns2:getShopByNameAndPwd", -1, &a->ns2__getShopByNameAndPwd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getShopByNameAndPwd * SOAP_FMAC4 soap_in___ns1__getShopByNameAndPwd(struct soap *soap, const char *tag, struct __ns1__getShopByNameAndPwd *a, const char *type)
{
	size_t soap_flag_ns2__getShopByNameAndPwd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getShopByNameAndPwd*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getShopByNameAndPwd, sizeof(struct __ns1__getShopByNameAndPwd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getShopByNameAndPwd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getShopByNameAndPwd_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getShopByNameAndPwd(soap, "ns2:getShopByNameAndPwd", &a->ns2__getShopByNameAndPwd_, "ns2:getShopByNameAndPwd"))
				{	soap_flag_ns2__getShopByNameAndPwd_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getShopByNameAndPwd * SOAP_FMAC2 soap_instantiate___ns1__getShopByNameAndPwd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getShopByNameAndPwd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getShopByNameAndPwd *p;
	size_t k = sizeof(struct __ns1__getShopByNameAndPwd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getShopByNameAndPwd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getShopByNameAndPwd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getShopByNameAndPwd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getShopByNameAndPwd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getShopByNameAndPwd(struct soap *soap, const struct __ns1__getShopByNameAndPwd *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getShopByNameAndPwd(soap, tag ? tag : "-ns1:getShopByNameAndPwd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getShopByNameAndPwd * SOAP_FMAC4 soap_get___ns1__getShopByNameAndPwd(struct soap *soap, struct __ns1__getShopByNameAndPwd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getShopByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOrderList(struct soap *soap, struct __ns1__getOrderList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getOrderList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOrderList(struct soap *soap, const struct __ns1__getOrderList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__getOrderList(soap, &a->ns2__getOrderList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOrderList(struct soap *soap, const char *tag, int id, const struct __ns1__getOrderList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__getOrderList(soap, "ns2:getOrderList", -1, &a->ns2__getOrderList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderList * SOAP_FMAC4 soap_in___ns1__getOrderList(struct soap *soap, const char *tag, struct __ns1__getOrderList *a, const char *type)
{
	size_t soap_flag_ns2__getOrderList_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getOrderList*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOrderList, sizeof(struct __ns1__getOrderList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOrderList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getOrderList_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__getOrderList(soap, "ns2:getOrderList", &a->ns2__getOrderList_, "ns2:getOrderList"))
				{	soap_flag_ns2__getOrderList_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getOrderList * SOAP_FMAC2 soap_instantiate___ns1__getOrderList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOrderList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getOrderList *p;
	size_t k = sizeof(struct __ns1__getOrderList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__getOrderList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__getOrderList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__getOrderList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getOrderList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOrderList(struct soap *soap, const struct __ns1__getOrderList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getOrderList(soap, tag ? tag : "-ns1:getOrderList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOrderList * SOAP_FMAC4 soap_get___ns1__getOrderList(struct soap *soap, struct __ns1__getOrderList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOrderList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteProductTypeByName(struct soap *soap, struct __ns1__deleteProductTypeByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__deleteProductTypeByName_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteProductTypeByName(struct soap *soap, const struct __ns1__deleteProductTypeByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__deleteProductTypeByName(soap, &a->ns2__deleteProductTypeByName_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteProductTypeByName(struct soap *soap, const char *tag, int id, const struct __ns1__deleteProductTypeByName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__deleteProductTypeByName(soap, "ns2:deleteProductTypeByName", -1, &a->ns2__deleteProductTypeByName_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteProductTypeByName * SOAP_FMAC4 soap_in___ns1__deleteProductTypeByName(struct soap *soap, const char *tag, struct __ns1__deleteProductTypeByName *a, const char *type)
{
	size_t soap_flag_ns2__deleteProductTypeByName_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteProductTypeByName*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteProductTypeByName, sizeof(struct __ns1__deleteProductTypeByName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteProductTypeByName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__deleteProductTypeByName_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__deleteProductTypeByName(soap, "ns2:deleteProductTypeByName", &a->ns2__deleteProductTypeByName_, "ns2:deleteProductTypeByName"))
				{	soap_flag_ns2__deleteProductTypeByName_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteProductTypeByName * SOAP_FMAC2 soap_instantiate___ns1__deleteProductTypeByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteProductTypeByName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteProductTypeByName *p;
	size_t k = sizeof(struct __ns1__deleteProductTypeByName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__deleteProductTypeByName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__deleteProductTypeByName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__deleteProductTypeByName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteProductTypeByName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteProductTypeByName(struct soap *soap, const struct __ns1__deleteProductTypeByName *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteProductTypeByName(soap, tag ? tag : "-ns1:deleteProductTypeByName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteProductTypeByName * SOAP_FMAC4 soap_get___ns1__deleteProductTypeByName(struct soap *soap, struct __ns1__deleteProductTypeByName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteProductTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addProduct(struct soap *soap, struct __ns1__addProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__addProduct_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addProduct(struct soap *soap, const struct __ns1__addProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__addProduct(soap, &a->ns2__addProduct_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addProduct(struct soap *soap, const char *tag, int id, const struct __ns1__addProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__addProduct(soap, "ns2:addProduct", -1, &a->ns2__addProduct_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addProduct * SOAP_FMAC4 soap_in___ns1__addProduct(struct soap *soap, const char *tag, struct __ns1__addProduct *a, const char *type)
{
	size_t soap_flag_ns2__addProduct_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__addProduct*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addProduct, sizeof(struct __ns1__addProduct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addProduct(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__addProduct_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__addProduct(soap, "ns2:addProduct", &a->ns2__addProduct_, "ns2:addProduct"))
				{	soap_flag_ns2__addProduct_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__addProduct * SOAP_FMAC2 soap_instantiate___ns1__addProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addProduct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__addProduct *p;
	size_t k = sizeof(struct __ns1__addProduct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__addProduct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__addProduct);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__addProduct, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__addProduct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addProduct(struct soap *soap, const struct __ns1__addProduct *a, const char *tag, const char *type)
{
	if (soap_out___ns1__addProduct(soap, tag ? tag : "-ns1:addProduct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addProduct * SOAP_FMAC4 soap_get___ns1__addProduct(struct soap *soap, struct __ns1__addProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__selectProductForUpdate(struct soap *soap, struct __ns1__selectProductForUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__selectProductForUpdate_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__selectProductForUpdate(struct soap *soap, const struct __ns1__selectProductForUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__selectProductForUpdate(soap, &a->ns2__selectProductForUpdate_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__selectProductForUpdate(struct soap *soap, const char *tag, int id, const struct __ns1__selectProductForUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__selectProductForUpdate(soap, "ns2:selectProductForUpdate", -1, &a->ns2__selectProductForUpdate_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__selectProductForUpdate * SOAP_FMAC4 soap_in___ns1__selectProductForUpdate(struct soap *soap, const char *tag, struct __ns1__selectProductForUpdate *a, const char *type)
{
	size_t soap_flag_ns2__selectProductForUpdate_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__selectProductForUpdate*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__selectProductForUpdate, sizeof(struct __ns1__selectProductForUpdate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__selectProductForUpdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__selectProductForUpdate_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__selectProductForUpdate(soap, "ns2:selectProductForUpdate", &a->ns2__selectProductForUpdate_, "ns2:selectProductForUpdate"))
				{	soap_flag_ns2__selectProductForUpdate_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__selectProductForUpdate * SOAP_FMAC2 soap_instantiate___ns1__selectProductForUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__selectProductForUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__selectProductForUpdate *p;
	size_t k = sizeof(struct __ns1__selectProductForUpdate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__selectProductForUpdate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__selectProductForUpdate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__selectProductForUpdate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__selectProductForUpdate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__selectProductForUpdate(struct soap *soap, const struct __ns1__selectProductForUpdate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__selectProductForUpdate(soap, tag ? tag : "-ns1:selectProductForUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__selectProductForUpdate * SOAP_FMAC4 soap_get___ns1__selectProductForUpdate(struct soap *soap, struct __ns1__selectProductForUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__selectProductForUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__InsertClient(struct soap *soap, ns2__InsertClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__InsertClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__InsertClient(struct soap *soap, const char *tag, int id, ns2__InsertClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__InsertClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__InsertClient ? type : NULL);
}

SOAP_FMAC3 ns2__InsertClient ** SOAP_FMAC4 soap_in_PointerTons2__InsertClient(struct soap *soap, const char *tag, ns2__InsertClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__InsertClient **)soap_malloc(soap, sizeof(ns2__InsertClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__InsertClient *)soap_instantiate_ns2__InsertClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__InsertClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__InsertClient, sizeof(ns2__InsertClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__InsertClient(struct soap *soap, ns2__InsertClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__InsertClient(soap, tag ? tag : "ns2:InsertClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__InsertClient ** SOAP_FMAC4 soap_get_PointerTons2__InsertClient(struct soap *soap, ns2__InsertClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__InsertClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteShoppingCart(struct soap *soap, ns2__deleteShoppingCart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteShoppingCart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteShoppingCart(struct soap *soap, const char *tag, int id, ns2__deleteShoppingCart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteShoppingCart, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteShoppingCart ? type : NULL);
}

SOAP_FMAC3 ns2__deleteShoppingCart ** SOAP_FMAC4 soap_in_PointerTons2__deleteShoppingCart(struct soap *soap, const char *tag, ns2__deleteShoppingCart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteShoppingCart **)soap_malloc(soap, sizeof(ns2__deleteShoppingCart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteShoppingCart *)soap_instantiate_ns2__deleteShoppingCart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteShoppingCart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteShoppingCart, sizeof(ns2__deleteShoppingCart), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteShoppingCart(struct soap *soap, ns2__deleteShoppingCart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteShoppingCart(soap, tag ? tag : "ns2:deleteShoppingCart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteShoppingCart ** SOAP_FMAC4 soap_get_PointerTons2__deleteShoppingCart(struct soap *soap, ns2__deleteShoppingCart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteShoppingCart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClientByNameAndPwd(struct soap *soap, ns2__getClientByNameAndPwd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClientByNameAndPwd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClientByNameAndPwd(struct soap *soap, const char *tag, int id, ns2__getClientByNameAndPwd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClientByNameAndPwd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getClientByNameAndPwd ? type : NULL);
}

SOAP_FMAC3 ns2__getClientByNameAndPwd ** SOAP_FMAC4 soap_in_PointerTons2__getClientByNameAndPwd(struct soap *soap, const char *tag, ns2__getClientByNameAndPwd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClientByNameAndPwd **)soap_malloc(soap, sizeof(ns2__getClientByNameAndPwd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClientByNameAndPwd *)soap_instantiate_ns2__getClientByNameAndPwd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getClientByNameAndPwd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClientByNameAndPwd, sizeof(ns2__getClientByNameAndPwd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClientByNameAndPwd(struct soap *soap, ns2__getClientByNameAndPwd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getClientByNameAndPwd(soap, tag ? tag : "ns2:getClientByNameAndPwd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClientByNameAndPwd ** SOAP_FMAC4 soap_get_PointerTons2__getClientByNameAndPwd(struct soap *soap, ns2__getClientByNameAndPwd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getProductLikeList(struct soap *soap, ns2__getProductLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getProductLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getProductLikeList(struct soap *soap, const char *tag, int id, ns2__getProductLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getProductLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getProductLikeList ? type : NULL);
}

SOAP_FMAC3 ns2__getProductLikeList ** SOAP_FMAC4 soap_in_PointerTons2__getProductLikeList(struct soap *soap, const char *tag, ns2__getProductLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getProductLikeList **)soap_malloc(soap, sizeof(ns2__getProductLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getProductLikeList *)soap_instantiate_ns2__getProductLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getProductLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getProductLikeList, sizeof(ns2__getProductLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getProductLikeList(struct soap *soap, ns2__getProductLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getProductLikeList(soap, tag ? tag : "ns2:getProductLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getProductLikeList ** SOAP_FMAC4 soap_get_PointerTons2__getProductLikeList(struct soap *soap, ns2__getProductLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getProductLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteMessageFromClient(struct soap *soap, ns2__deleteMessageFromClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteMessageFromClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteMessageFromClient(struct soap *soap, const char *tag, int id, ns2__deleteMessageFromClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteMessageFromClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteMessageFromClient ? type : NULL);
}

SOAP_FMAC3 ns2__deleteMessageFromClient ** SOAP_FMAC4 soap_in_PointerTons2__deleteMessageFromClient(struct soap *soap, const char *tag, ns2__deleteMessageFromClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteMessageFromClient **)soap_malloc(soap, sizeof(ns2__deleteMessageFromClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteMessageFromClient *)soap_instantiate_ns2__deleteMessageFromClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteMessageFromClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteMessageFromClient, sizeof(ns2__deleteMessageFromClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteMessageFromClient(struct soap *soap, ns2__deleteMessageFromClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteMessageFromClient(soap, tag ? tag : "ns2:deleteMessageFromClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteMessageFromClient ** SOAP_FMAC4 soap_get_PointerTons2__deleteMessageFromClient(struct soap *soap, ns2__deleteMessageFromClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__addProductType(struct soap *soap, ns2__addProductType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__addProductType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__addProductType(struct soap *soap, const char *tag, int id, ns2__addProductType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__addProductType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__addProductType ? type : NULL);
}

SOAP_FMAC3 ns2__addProductType ** SOAP_FMAC4 soap_in_PointerTons2__addProductType(struct soap *soap, const char *tag, ns2__addProductType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__addProductType **)soap_malloc(soap, sizeof(ns2__addProductType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__addProductType *)soap_instantiate_ns2__addProductType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__addProductType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__addProductType, sizeof(ns2__addProductType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__addProductType(struct soap *soap, ns2__addProductType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__addProductType(soap, tag ? tag : "ns2:addProductType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__addProductType ** SOAP_FMAC4 soap_get_PointerTons2__addProductType(struct soap *soap, ns2__addProductType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__addProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getOrderListByInfo(struct soap *soap, ns2__getOrderListByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getOrderListByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getOrderListByInfo(struct soap *soap, const char *tag, int id, ns2__getOrderListByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getOrderListByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getOrderListByInfo ? type : NULL);
}

SOAP_FMAC3 ns2__getOrderListByInfo ** SOAP_FMAC4 soap_in_PointerTons2__getOrderListByInfo(struct soap *soap, const char *tag, ns2__getOrderListByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getOrderListByInfo **)soap_malloc(soap, sizeof(ns2__getOrderListByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getOrderListByInfo *)soap_instantiate_ns2__getOrderListByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getOrderListByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getOrderListByInfo, sizeof(ns2__getOrderListByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getOrderListByInfo(struct soap *soap, ns2__getOrderListByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getOrderListByInfo(soap, tag ? tag : "ns2:getOrderListByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getOrderListByInfo ** SOAP_FMAC4 soap_get_PointerTons2__getOrderListByInfo(struct soap *soap, ns2__getOrderListByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getOrderListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getShopList(struct soap *soap, ns2__getShopList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getShopList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getShopList(struct soap *soap, const char *tag, int id, ns2__getShopList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getShopList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getShopList ? type : NULL);
}

SOAP_FMAC3 ns2__getShopList ** SOAP_FMAC4 soap_in_PointerTons2__getShopList(struct soap *soap, const char *tag, ns2__getShopList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getShopList **)soap_malloc(soap, sizeof(ns2__getShopList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getShopList *)soap_instantiate_ns2__getShopList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getShopList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getShopList, sizeof(ns2__getShopList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getShopList(struct soap *soap, ns2__getShopList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getShopList(soap, tag ? tag : "ns2:getShopList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getShopList ** SOAP_FMAC4 soap_get_PointerTons2__getShopList(struct soap *soap, ns2__getShopList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getShopList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClientLikeList(struct soap *soap, ns2__getClientLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClientLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClientLikeList(struct soap *soap, const char *tag, int id, ns2__getClientLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClientLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getClientLikeList ? type : NULL);
}

SOAP_FMAC3 ns2__getClientLikeList ** SOAP_FMAC4 soap_in_PointerTons2__getClientLikeList(struct soap *soap, const char *tag, ns2__getClientLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClientLikeList **)soap_malloc(soap, sizeof(ns2__getClientLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClientLikeList *)soap_instantiate_ns2__getClientLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getClientLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClientLikeList, sizeof(ns2__getClientLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClientLikeList(struct soap *soap, ns2__getClientLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getClientLikeList(soap, tag ? tag : "ns2:getClientLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClientLikeList ** SOAP_FMAC4 soap_get_PointerTons2__getClientLikeList(struct soap *soap, ns2__getClientLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClientLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getUnreadMessageFromShop(struct soap *soap, ns2__getUnreadMessageFromShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getUnreadMessageFromShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getUnreadMessageFromShop(struct soap *soap, const char *tag, int id, ns2__getUnreadMessageFromShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getUnreadMessageFromShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getUnreadMessageFromShop ? type : NULL);
}

SOAP_FMAC3 ns2__getUnreadMessageFromShop ** SOAP_FMAC4 soap_in_PointerTons2__getUnreadMessageFromShop(struct soap *soap, const char *tag, ns2__getUnreadMessageFromShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getUnreadMessageFromShop **)soap_malloc(soap, sizeof(ns2__getUnreadMessageFromShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getUnreadMessageFromShop *)soap_instantiate_ns2__getUnreadMessageFromShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getUnreadMessageFromShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getUnreadMessageFromShop, sizeof(ns2__getUnreadMessageFromShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getUnreadMessageFromShop(struct soap *soap, ns2__getUnreadMessageFromShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getUnreadMessageFromShop(soap, tag ? tag : "ns2:getUnreadMessageFromShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getUnreadMessageFromShop ** SOAP_FMAC4 soap_get_PointerTons2__getUnreadMessageFromShop(struct soap *soap, ns2__getUnreadMessageFromShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getUnreadMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getOrderLikeList(struct soap *soap, ns2__getOrderLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getOrderLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getOrderLikeList(struct soap *soap, const char *tag, int id, ns2__getOrderLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getOrderLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getOrderLikeList ? type : NULL);
}

SOAP_FMAC3 ns2__getOrderLikeList ** SOAP_FMAC4 soap_in_PointerTons2__getOrderLikeList(struct soap *soap, const char *tag, ns2__getOrderLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getOrderLikeList **)soap_malloc(soap, sizeof(ns2__getOrderLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getOrderLikeList *)soap_instantiate_ns2__getOrderLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getOrderLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getOrderLikeList, sizeof(ns2__getOrderLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getOrderLikeList(struct soap *soap, ns2__getOrderLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getOrderLikeList(soap, tag ? tag : "ns2:getOrderLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getOrderLikeList ** SOAP_FMAC4 soap_get_PointerTons2__getOrderLikeList(struct soap *soap, ns2__getOrderLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getOrderLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteMessageFromShop(struct soap *soap, ns2__deleteMessageFromShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteMessageFromShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteMessageFromShop(struct soap *soap, const char *tag, int id, ns2__deleteMessageFromShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteMessageFromShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteMessageFromShop ? type : NULL);
}

SOAP_FMAC3 ns2__deleteMessageFromShop ** SOAP_FMAC4 soap_in_PointerTons2__deleteMessageFromShop(struct soap *soap, const char *tag, ns2__deleteMessageFromShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteMessageFromShop **)soap_malloc(soap, sizeof(ns2__deleteMessageFromShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteMessageFromShop *)soap_instantiate_ns2__deleteMessageFromShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteMessageFromShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteMessageFromShop, sizeof(ns2__deleteMessageFromShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteMessageFromShop(struct soap *soap, ns2__deleteMessageFromShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteMessageFromShop(soap, tag ? tag : "ns2:deleteMessageFromShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteMessageFromShop ** SOAP_FMAC4 soap_get_PointerTons2__deleteMessageFromShop(struct soap *soap, ns2__deleteMessageFromShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMessageFromShop(struct soap *soap, ns2__getMessageFromShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMessageFromShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMessageFromShop(struct soap *soap, const char *tag, int id, ns2__getMessageFromShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMessageFromShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getMessageFromShop ? type : NULL);
}

SOAP_FMAC3 ns2__getMessageFromShop ** SOAP_FMAC4 soap_in_PointerTons2__getMessageFromShop(struct soap *soap, const char *tag, ns2__getMessageFromShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMessageFromShop **)soap_malloc(soap, sizeof(ns2__getMessageFromShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMessageFromShop *)soap_instantiate_ns2__getMessageFromShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getMessageFromShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMessageFromShop, sizeof(ns2__getMessageFromShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMessageFromShop(struct soap *soap, ns2__getMessageFromShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getMessageFromShop(soap, tag ? tag : "ns2:getMessageFromShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMessageFromShop ** SOAP_FMAC4 soap_get_PointerTons2__getMessageFromShop(struct soap *soap, ns2__getMessageFromShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getShopLikeList(struct soap *soap, ns2__getShopLikeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getShopLikeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getShopLikeList(struct soap *soap, const char *tag, int id, ns2__getShopLikeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getShopLikeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getShopLikeList ? type : NULL);
}

SOAP_FMAC3 ns2__getShopLikeList ** SOAP_FMAC4 soap_in_PointerTons2__getShopLikeList(struct soap *soap, const char *tag, ns2__getShopLikeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getShopLikeList **)soap_malloc(soap, sizeof(ns2__getShopLikeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getShopLikeList *)soap_instantiate_ns2__getShopLikeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getShopLikeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getShopLikeList, sizeof(ns2__getShopLikeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getShopLikeList(struct soap *soap, ns2__getShopLikeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getShopLikeList(soap, tag ? tag : "ns2:getShopLikeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getShopLikeList ** SOAP_FMAC4 soap_get_PointerTons2__getShopLikeList(struct soap *soap, ns2__getShopLikeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getShopLikeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__InsertMessage(struct soap *soap, ns2__InsertMessage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__InsertMessage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__InsertMessage(struct soap *soap, const char *tag, int id, ns2__InsertMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__InsertMessage, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__InsertMessage ? type : NULL);
}

SOAP_FMAC3 ns2__InsertMessage ** SOAP_FMAC4 soap_in_PointerTons2__InsertMessage(struct soap *soap, const char *tag, ns2__InsertMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__InsertMessage **)soap_malloc(soap, sizeof(ns2__InsertMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__InsertMessage *)soap_instantiate_ns2__InsertMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__InsertMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__InsertMessage, sizeof(ns2__InsertMessage), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__InsertMessage(struct soap *soap, ns2__InsertMessage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__InsertMessage(soap, tag ? tag : "ns2:InsertMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__InsertMessage ** SOAP_FMAC4 soap_get_PointerTons2__InsertMessage(struct soap *soap, ns2__InsertMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__InsertMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__updateHistory(struct soap *soap, ns2__updateHistory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__updateHistory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__updateHistory(struct soap *soap, const char *tag, int id, ns2__updateHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__updateHistory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__updateHistory ? type : NULL);
}

SOAP_FMAC3 ns2__updateHistory ** SOAP_FMAC4 soap_in_PointerTons2__updateHistory(struct soap *soap, const char *tag, ns2__updateHistory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__updateHistory **)soap_malloc(soap, sizeof(ns2__updateHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__updateHistory *)soap_instantiate_ns2__updateHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__updateHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__updateHistory, sizeof(ns2__updateHistory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__updateHistory(struct soap *soap, ns2__updateHistory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__updateHistory(soap, tag ? tag : "ns2:updateHistory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__updateHistory ** SOAP_FMAC4 soap_get_PointerTons2__updateHistory(struct soap *soap, ns2__updateHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__updateHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getReadMessageFromClient(struct soap *soap, ns2__getReadMessageFromClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getReadMessageFromClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getReadMessageFromClient(struct soap *soap, const char *tag, int id, ns2__getReadMessageFromClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getReadMessageFromClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getReadMessageFromClient ? type : NULL);
}

SOAP_FMAC3 ns2__getReadMessageFromClient ** SOAP_FMAC4 soap_in_PointerTons2__getReadMessageFromClient(struct soap *soap, const char *tag, ns2__getReadMessageFromClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getReadMessageFromClient **)soap_malloc(soap, sizeof(ns2__getReadMessageFromClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getReadMessageFromClient *)soap_instantiate_ns2__getReadMessageFromClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getReadMessageFromClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getReadMessageFromClient, sizeof(ns2__getReadMessageFromClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getReadMessageFromClient(struct soap *soap, ns2__getReadMessageFromClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getReadMessageFromClient(soap, tag ? tag : "ns2:getReadMessageFromClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getReadMessageFromClient ** SOAP_FMAC4 soap_get_PointerTons2__getReadMessageFromClient(struct soap *soap, ns2__getReadMessageFromClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getReadMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getOrderListHistory(struct soap *soap, ns2__getOrderListHistory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getOrderListHistory))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getOrderListHistory(struct soap *soap, const char *tag, int id, ns2__getOrderListHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getOrderListHistory, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getOrderListHistory ? type : NULL);
}

SOAP_FMAC3 ns2__getOrderListHistory ** SOAP_FMAC4 soap_in_PointerTons2__getOrderListHistory(struct soap *soap, const char *tag, ns2__getOrderListHistory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getOrderListHistory **)soap_malloc(soap, sizeof(ns2__getOrderListHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getOrderListHistory *)soap_instantiate_ns2__getOrderListHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getOrderListHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getOrderListHistory, sizeof(ns2__getOrderListHistory), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getOrderListHistory(struct soap *soap, ns2__getOrderListHistory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getOrderListHistory(soap, tag ? tag : "ns2:getOrderListHistory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getOrderListHistory ** SOAP_FMAC4 soap_get_PointerTons2__getOrderListHistory(struct soap *soap, ns2__getOrderListHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getOrderListHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getProductList(struct soap *soap, ns2__getProductList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getProductList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getProductList(struct soap *soap, const char *tag, int id, ns2__getProductList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getProductList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getProductList ? type : NULL);
}

SOAP_FMAC3 ns2__getProductList ** SOAP_FMAC4 soap_in_PointerTons2__getProductList(struct soap *soap, const char *tag, ns2__getProductList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getProductList **)soap_malloc(soap, sizeof(ns2__getProductList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getProductList *)soap_instantiate_ns2__getProductList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getProductList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getProductList, sizeof(ns2__getProductList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getProductList(struct soap *soap, ns2__getProductList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getProductList(soap, tag ? tag : "ns2:getProductList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getProductList ** SOAP_FMAC4 soap_get_PointerTons2__getProductList(struct soap *soap, ns2__getProductList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getProductList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteShopByNameAndPwd(struct soap *soap, ns2__deleteShopByNameAndPwd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteShopByNameAndPwd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteShopByNameAndPwd(struct soap *soap, const char *tag, int id, ns2__deleteShopByNameAndPwd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteShopByNameAndPwd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteShopByNameAndPwd ? type : NULL);
}

SOAP_FMAC3 ns2__deleteShopByNameAndPwd ** SOAP_FMAC4 soap_in_PointerTons2__deleteShopByNameAndPwd(struct soap *soap, const char *tag, ns2__deleteShopByNameAndPwd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteShopByNameAndPwd **)soap_malloc(soap, sizeof(ns2__deleteShopByNameAndPwd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteShopByNameAndPwd *)soap_instantiate_ns2__deleteShopByNameAndPwd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteShopByNameAndPwd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteShopByNameAndPwd, sizeof(ns2__deleteShopByNameAndPwd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteShopByNameAndPwd(struct soap *soap, ns2__deleteShopByNameAndPwd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteShopByNameAndPwd(soap, tag ? tag : "ns2:deleteShopByNameAndPwd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteShopByNameAndPwd ** SOAP_FMAC4 soap_get_PointerTons2__deleteShopByNameAndPwd(struct soap *soap, ns2__deleteShopByNameAndPwd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteShopByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__addOrder(struct soap *soap, ns2__addOrder *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__addOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__addOrder(struct soap *soap, const char *tag, int id, ns2__addOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__addOrder, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__addOrder ? type : NULL);
}

SOAP_FMAC3 ns2__addOrder ** SOAP_FMAC4 soap_in_PointerTons2__addOrder(struct soap *soap, const char *tag, ns2__addOrder **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__addOrder **)soap_malloc(soap, sizeof(ns2__addOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__addOrder *)soap_instantiate_ns2__addOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__addOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__addOrder, sizeof(ns2__addOrder), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__addOrder(struct soap *soap, ns2__addOrder *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__addOrder(soap, tag ? tag : "ns2:addOrder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__addOrder ** SOAP_FMAC4 soap_get_PointerTons2__addOrder(struct soap *soap, ns2__addOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__addOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getMessageFromClient(struct soap *soap, ns2__getMessageFromClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getMessageFromClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getMessageFromClient(struct soap *soap, const char *tag, int id, ns2__getMessageFromClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getMessageFromClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getMessageFromClient ? type : NULL);
}

SOAP_FMAC3 ns2__getMessageFromClient ** SOAP_FMAC4 soap_in_PointerTons2__getMessageFromClient(struct soap *soap, const char *tag, ns2__getMessageFromClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getMessageFromClient **)soap_malloc(soap, sizeof(ns2__getMessageFromClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getMessageFromClient *)soap_instantiate_ns2__getMessageFromClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getMessageFromClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getMessageFromClient, sizeof(ns2__getMessageFromClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getMessageFromClient(struct soap *soap, ns2__getMessageFromClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getMessageFromClient(soap, tag ? tag : "ns2:getMessageFromClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getMessageFromClient ** SOAP_FMAC4 soap_get_PointerTons2__getMessageFromClient(struct soap *soap, ns2__getMessageFromClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__updateProductByInfo(struct soap *soap, ns2__updateProductByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__updateProductByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__updateProductByInfo(struct soap *soap, const char *tag, int id, ns2__updateProductByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__updateProductByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__updateProductByInfo ? type : NULL);
}

SOAP_FMAC3 ns2__updateProductByInfo ** SOAP_FMAC4 soap_in_PointerTons2__updateProductByInfo(struct soap *soap, const char *tag, ns2__updateProductByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__updateProductByInfo **)soap_malloc(soap, sizeof(ns2__updateProductByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__updateProductByInfo *)soap_instantiate_ns2__updateProductByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__updateProductByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__updateProductByInfo, sizeof(ns2__updateProductByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__updateProductByInfo(struct soap *soap, ns2__updateProductByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__updateProductByInfo(soap, tag ? tag : "ns2:updateProductByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__updateProductByInfo ** SOAP_FMAC4 soap_get_PointerTons2__updateProductByInfo(struct soap *soap, ns2__updateProductByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__updateProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getUnreadMessageFromClient(struct soap *soap, ns2__getUnreadMessageFromClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getUnreadMessageFromClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getUnreadMessageFromClient(struct soap *soap, const char *tag, int id, ns2__getUnreadMessageFromClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getUnreadMessageFromClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getUnreadMessageFromClient ? type : NULL);
}

SOAP_FMAC3 ns2__getUnreadMessageFromClient ** SOAP_FMAC4 soap_in_PointerTons2__getUnreadMessageFromClient(struct soap *soap, const char *tag, ns2__getUnreadMessageFromClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getUnreadMessageFromClient **)soap_malloc(soap, sizeof(ns2__getUnreadMessageFromClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getUnreadMessageFromClient *)soap_instantiate_ns2__getUnreadMessageFromClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getUnreadMessageFromClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getUnreadMessageFromClient, sizeof(ns2__getUnreadMessageFromClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getUnreadMessageFromClient(struct soap *soap, ns2__getUnreadMessageFromClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getUnreadMessageFromClient(soap, tag ? tag : "ns2:getUnreadMessageFromClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getUnreadMessageFromClient ** SOAP_FMAC4 soap_get_PointerTons2__getUnreadMessageFromClient(struct soap *soap, ns2__getUnreadMessageFromClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getUnreadMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__updateMessageFromClient(struct soap *soap, ns2__updateMessageFromClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__updateMessageFromClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__updateMessageFromClient(struct soap *soap, const char *tag, int id, ns2__updateMessageFromClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__updateMessageFromClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__updateMessageFromClient ? type : NULL);
}

SOAP_FMAC3 ns2__updateMessageFromClient ** SOAP_FMAC4 soap_in_PointerTons2__updateMessageFromClient(struct soap *soap, const char *tag, ns2__updateMessageFromClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__updateMessageFromClient **)soap_malloc(soap, sizeof(ns2__updateMessageFromClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__updateMessageFromClient *)soap_instantiate_ns2__updateMessageFromClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__updateMessageFromClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__updateMessageFromClient, sizeof(ns2__updateMessageFromClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__updateMessageFromClient(struct soap *soap, ns2__updateMessageFromClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__updateMessageFromClient(soap, tag ? tag : "ns2:updateMessageFromClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__updateMessageFromClient ** SOAP_FMAC4 soap_get_PointerTons2__updateMessageFromClient(struct soap *soap, ns2__updateMessageFromClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__updateMessageFromClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__purchaseProduct(struct soap *soap, ns2__purchaseProduct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__purchaseProduct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__purchaseProduct(struct soap *soap, const char *tag, int id, ns2__purchaseProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__purchaseProduct, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__purchaseProduct ? type : NULL);
}

SOAP_FMAC3 ns2__purchaseProduct ** SOAP_FMAC4 soap_in_PointerTons2__purchaseProduct(struct soap *soap, const char *tag, ns2__purchaseProduct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__purchaseProduct **)soap_malloc(soap, sizeof(ns2__purchaseProduct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__purchaseProduct *)soap_instantiate_ns2__purchaseProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__purchaseProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__purchaseProduct, sizeof(ns2__purchaseProduct), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__purchaseProduct(struct soap *soap, ns2__purchaseProduct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__purchaseProduct(soap, tag ? tag : "ns2:purchaseProduct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__purchaseProduct ** SOAP_FMAC4 soap_get_PointerTons2__purchaseProduct(struct soap *soap, ns2__purchaseProduct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__purchaseProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getClientList(struct soap *soap, ns2__getClientList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getClientList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getClientList(struct soap *soap, const char *tag, int id, ns2__getClientList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getClientList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getClientList ? type : NULL);
}

SOAP_FMAC3 ns2__getClientList ** SOAP_FMAC4 soap_in_PointerTons2__getClientList(struct soap *soap, const char *tag, ns2__getClientList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getClientList **)soap_malloc(soap, sizeof(ns2__getClientList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getClientList *)soap_instantiate_ns2__getClientList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getClientList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getClientList, sizeof(ns2__getClientList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getClientList(struct soap *soap, ns2__getClientList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getClientList(soap, tag ? tag : "ns2:getClientList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getClientList ** SOAP_FMAC4 soap_get_PointerTons2__getClientList(struct soap *soap, ns2__getClientList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getClientList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getProductTypeByProName(struct soap *soap, ns2__getProductTypeByProName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getProductTypeByProName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getProductTypeByProName(struct soap *soap, const char *tag, int id, ns2__getProductTypeByProName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getProductTypeByProName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getProductTypeByProName ? type : NULL);
}

SOAP_FMAC3 ns2__getProductTypeByProName ** SOAP_FMAC4 soap_in_PointerTons2__getProductTypeByProName(struct soap *soap, const char *tag, ns2__getProductTypeByProName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getProductTypeByProName **)soap_malloc(soap, sizeof(ns2__getProductTypeByProName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getProductTypeByProName *)soap_instantiate_ns2__getProductTypeByProName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getProductTypeByProName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getProductTypeByProName, sizeof(ns2__getProductTypeByProName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getProductTypeByProName(struct soap *soap, ns2__getProductTypeByProName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getProductTypeByProName(soap, tag ? tag : "ns2:getProductTypeByProName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getProductTypeByProName ** SOAP_FMAC4 soap_get_PointerTons2__getProductTypeByProName(struct soap *soap, ns2__getProductTypeByProName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getProductTypeByProName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__updateMessageFromShop(struct soap *soap, ns2__updateMessageFromShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__updateMessageFromShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__updateMessageFromShop(struct soap *soap, const char *tag, int id, ns2__updateMessageFromShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__updateMessageFromShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__updateMessageFromShop ? type : NULL);
}

SOAP_FMAC3 ns2__updateMessageFromShop ** SOAP_FMAC4 soap_in_PointerTons2__updateMessageFromShop(struct soap *soap, const char *tag, ns2__updateMessageFromShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__updateMessageFromShop **)soap_malloc(soap, sizeof(ns2__updateMessageFromShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__updateMessageFromShop *)soap_instantiate_ns2__updateMessageFromShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__updateMessageFromShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__updateMessageFromShop, sizeof(ns2__updateMessageFromShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__updateMessageFromShop(struct soap *soap, ns2__updateMessageFromShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__updateMessageFromShop(soap, tag ? tag : "ns2:updateMessageFromShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__updateMessageFromShop ** SOAP_FMAC4 soap_get_PointerTons2__updateMessageFromShop(struct soap *soap, ns2__updateMessageFromShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__updateMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__InsertShop(struct soap *soap, ns2__InsertShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__InsertShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__InsertShop(struct soap *soap, const char *tag, int id, ns2__InsertShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__InsertShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__InsertShop ? type : NULL);
}

SOAP_FMAC3 ns2__InsertShop ** SOAP_FMAC4 soap_in_PointerTons2__InsertShop(struct soap *soap, const char *tag, ns2__InsertShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__InsertShop **)soap_malloc(soap, sizeof(ns2__InsertShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__InsertShop *)soap_instantiate_ns2__InsertShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__InsertShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__InsertShop, sizeof(ns2__InsertShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__InsertShop(struct soap *soap, ns2__InsertShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__InsertShop(soap, tag ? tag : "ns2:InsertShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__InsertShop ** SOAP_FMAC4 soap_get_PointerTons2__InsertShop(struct soap *soap, ns2__InsertShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__InsertShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteClientByNameAndPwd(struct soap *soap, ns2__deleteClientByNameAndPwd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteClientByNameAndPwd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, int id, ns2__deleteClientByNameAndPwd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteClientByNameAndPwd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteClientByNameAndPwd ? type : NULL);
}

SOAP_FMAC3 ns2__deleteClientByNameAndPwd ** SOAP_FMAC4 soap_in_PointerTons2__deleteClientByNameAndPwd(struct soap *soap, const char *tag, ns2__deleteClientByNameAndPwd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteClientByNameAndPwd **)soap_malloc(soap, sizeof(ns2__deleteClientByNameAndPwd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteClientByNameAndPwd *)soap_instantiate_ns2__deleteClientByNameAndPwd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteClientByNameAndPwd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteClientByNameAndPwd, sizeof(ns2__deleteClientByNameAndPwd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteClientByNameAndPwd(struct soap *soap, ns2__deleteClientByNameAndPwd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteClientByNameAndPwd(soap, tag ? tag : "ns2:deleteClientByNameAndPwd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteClientByNameAndPwd ** SOAP_FMAC4 soap_get_PointerTons2__deleteClientByNameAndPwd(struct soap *soap, ns2__deleteClientByNameAndPwd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteClientByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteProductByInfo(struct soap *soap, ns2__deleteProductByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteProductByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteProductByInfo(struct soap *soap, const char *tag, int id, ns2__deleteProductByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteProductByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteProductByInfo ? type : NULL);
}

SOAP_FMAC3 ns2__deleteProductByInfo ** SOAP_FMAC4 soap_in_PointerTons2__deleteProductByInfo(struct soap *soap, const char *tag, ns2__deleteProductByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteProductByInfo **)soap_malloc(soap, sizeof(ns2__deleteProductByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteProductByInfo *)soap_instantiate_ns2__deleteProductByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteProductByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteProductByInfo, sizeof(ns2__deleteProductByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteProductByInfo(struct soap *soap, ns2__deleteProductByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteProductByInfo(soap, tag ? tag : "ns2:deleteProductByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteProductByInfo ** SOAP_FMAC4 soap_get_PointerTons2__deleteProductByInfo(struct soap *soap, ns2__deleteProductByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteProductByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__updateClient(struct soap *soap, ns2__updateClient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__updateClient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__updateClient(struct soap *soap, const char *tag, int id, ns2__updateClient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__updateClient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__updateClient ? type : NULL);
}

SOAP_FMAC3 ns2__updateClient ** SOAP_FMAC4 soap_in_PointerTons2__updateClient(struct soap *soap, const char *tag, ns2__updateClient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__updateClient **)soap_malloc(soap, sizeof(ns2__updateClient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__updateClient *)soap_instantiate_ns2__updateClient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__updateClient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__updateClient, sizeof(ns2__updateClient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__updateClient(struct soap *soap, ns2__updateClient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__updateClient(soap, tag ? tag : "ns2:updateClient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__updateClient ** SOAP_FMAC4 soap_get_PointerTons2__updateClient(struct soap *soap, ns2__updateClient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__updateClient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getReadMessageFromShop(struct soap *soap, ns2__getReadMessageFromShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getReadMessageFromShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getReadMessageFromShop(struct soap *soap, const char *tag, int id, ns2__getReadMessageFromShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getReadMessageFromShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getReadMessageFromShop ? type : NULL);
}

SOAP_FMAC3 ns2__getReadMessageFromShop ** SOAP_FMAC4 soap_in_PointerTons2__getReadMessageFromShop(struct soap *soap, const char *tag, ns2__getReadMessageFromShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getReadMessageFromShop **)soap_malloc(soap, sizeof(ns2__getReadMessageFromShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getReadMessageFromShop *)soap_instantiate_ns2__getReadMessageFromShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getReadMessageFromShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getReadMessageFromShop, sizeof(ns2__getReadMessageFromShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getReadMessageFromShop(struct soap *soap, ns2__getReadMessageFromShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getReadMessageFromShop(soap, tag ? tag : "ns2:getReadMessageFromShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getReadMessageFromShop ** SOAP_FMAC4 soap_get_PointerTons2__getReadMessageFromShop(struct soap *soap, ns2__getReadMessageFromShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getReadMessageFromShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getProductListByInfo(struct soap *soap, ns2__getProductListByInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getProductListByInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getProductListByInfo(struct soap *soap, const char *tag, int id, ns2__getProductListByInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getProductListByInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getProductListByInfo ? type : NULL);
}

SOAP_FMAC3 ns2__getProductListByInfo ** SOAP_FMAC4 soap_in_PointerTons2__getProductListByInfo(struct soap *soap, const char *tag, ns2__getProductListByInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getProductListByInfo **)soap_malloc(soap, sizeof(ns2__getProductListByInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getProductListByInfo *)soap_instantiate_ns2__getProductListByInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getProductListByInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getProductListByInfo, sizeof(ns2__getProductListByInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getProductListByInfo(struct soap *soap, ns2__getProductListByInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getProductListByInfo(soap, tag ? tag : "ns2:getProductListByInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getProductListByInfo ** SOAP_FMAC4 soap_get_PointerTons2__getProductListByInfo(struct soap *soap, ns2__getProductListByInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getProductListByInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__updateShop(struct soap *soap, ns2__updateShop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__updateShop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__updateShop(struct soap *soap, const char *tag, int id, ns2__updateShop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__updateShop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__updateShop ? type : NULL);
}

SOAP_FMAC3 ns2__updateShop ** SOAP_FMAC4 soap_in_PointerTons2__updateShop(struct soap *soap, const char *tag, ns2__updateShop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__updateShop **)soap_malloc(soap, sizeof(ns2__updateShop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__updateShop *)soap_instantiate_ns2__updateShop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__updateShop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__updateShop, sizeof(ns2__updateShop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__updateShop(struct soap *soap, ns2__updateShop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__updateShop(soap, tag ? tag : "ns2:updateShop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__updateShop ** SOAP_FMAC4 soap_get_PointerTons2__updateShop(struct soap *soap, ns2__updateShop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__updateShop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getShopByNameAndPwd(struct soap *soap, ns2__getShopByNameAndPwd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getShopByNameAndPwd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getShopByNameAndPwd(struct soap *soap, const char *tag, int id, ns2__getShopByNameAndPwd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getShopByNameAndPwd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getShopByNameAndPwd ? type : NULL);
}

SOAP_FMAC3 ns2__getShopByNameAndPwd ** SOAP_FMAC4 soap_in_PointerTons2__getShopByNameAndPwd(struct soap *soap, const char *tag, ns2__getShopByNameAndPwd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getShopByNameAndPwd **)soap_malloc(soap, sizeof(ns2__getShopByNameAndPwd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getShopByNameAndPwd *)soap_instantiate_ns2__getShopByNameAndPwd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getShopByNameAndPwd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getShopByNameAndPwd, sizeof(ns2__getShopByNameAndPwd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getShopByNameAndPwd(struct soap *soap, ns2__getShopByNameAndPwd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getShopByNameAndPwd(soap, tag ? tag : "ns2:getShopByNameAndPwd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getShopByNameAndPwd ** SOAP_FMAC4 soap_get_PointerTons2__getShopByNameAndPwd(struct soap *soap, ns2__getShopByNameAndPwd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getShopByNameAndPwd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__getOrderList(struct soap *soap, ns2__getOrderList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__getOrderList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__getOrderList(struct soap *soap, const char *tag, int id, ns2__getOrderList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__getOrderList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__getOrderList ? type : NULL);
}

SOAP_FMAC3 ns2__getOrderList ** SOAP_FMAC4 soap_in_PointerTons2__getOrderList(struct soap *soap, const char *tag, ns2__getOrderList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__getOrderList **)soap_malloc(soap, sizeof(ns2__getOrderList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__getOrderList *)soap_instantiate_ns2__getOrderList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__getOrderList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__getOrderList, sizeof(ns2__getOrderList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__getOrderList(struct soap *soap, ns2__getOrderList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__getOrderList(soap, tag ? tag : "ns2:getOrderList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__getOrderList ** SOAP_FMAC4 soap_get_PointerTons2__getOrderList(struct soap *soap, ns2__getOrderList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__getOrderList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__deleteProductTypeByName(struct soap *soap, ns2__deleteProductTypeByName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__deleteProductTypeByName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__deleteProductTypeByName(struct soap *soap, const char *tag, int id, ns2__deleteProductTypeByName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__deleteProductTypeByName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__deleteProductTypeByName ? type : NULL);
}

SOAP_FMAC3 ns2__deleteProductTypeByName ** SOAP_FMAC4 soap_in_PointerTons2__deleteProductTypeByName(struct soap *soap, const char *tag, ns2__deleteProductTypeByName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__deleteProductTypeByName **)soap_malloc(soap, sizeof(ns2__deleteProductTypeByName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__deleteProductTypeByName *)soap_instantiate_ns2__deleteProductTypeByName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__deleteProductTypeByName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__deleteProductTypeByName, sizeof(ns2__deleteProductTypeByName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__deleteProductTypeByName(struct soap *soap, ns2__deleteProductTypeByName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__deleteProductTypeByName(soap, tag ? tag : "ns2:deleteProductTypeByName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__deleteProductTypeByName ** SOAP_FMAC4 soap_get_PointerTons2__deleteProductTypeByName(struct soap *soap, ns2__deleteProductTypeByName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__deleteProductTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__addProduct(struct soap *soap, ns2__addProduct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__addProduct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__addProduct(struct soap *soap, const char *tag, int id, ns2__addProduct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__addProduct, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__addProduct ? type : NULL);
}

SOAP_FMAC3 ns2__addProduct ** SOAP_FMAC4 soap_in_PointerTons2__addProduct(struct soap *soap, const char *tag, ns2__addProduct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__addProduct **)soap_malloc(soap, sizeof(ns2__addProduct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__addProduct *)soap_instantiate_ns2__addProduct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__addProduct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__addProduct, sizeof(ns2__addProduct), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__addProduct(struct soap *soap, ns2__addProduct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__addProduct(soap, tag ? tag : "ns2:addProduct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__addProduct ** SOAP_FMAC4 soap_get_PointerTons2__addProduct(struct soap *soap, ns2__addProduct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__addProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__selectProductForUpdate(struct soap *soap, ns2__selectProductForUpdate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__selectProductForUpdate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__selectProductForUpdate(struct soap *soap, const char *tag, int id, ns2__selectProductForUpdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__selectProductForUpdate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__selectProductForUpdate ? type : NULL);
}

SOAP_FMAC3 ns2__selectProductForUpdate ** SOAP_FMAC4 soap_in_PointerTons2__selectProductForUpdate(struct soap *soap, const char *tag, ns2__selectProductForUpdate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__selectProductForUpdate **)soap_malloc(soap, sizeof(ns2__selectProductForUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__selectProductForUpdate *)soap_instantiate_ns2__selectProductForUpdate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__selectProductForUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__selectProductForUpdate, sizeof(ns2__selectProductForUpdate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__selectProductForUpdate(struct soap *soap, ns2__selectProductForUpdate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__selectProductForUpdate(soap, tag ? tag : "ns2:selectProductForUpdate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__selectProductForUpdate ** SOAP_FMAC4 soap_get_PointerTons2__selectProductForUpdate(struct soap *soap, ns2__selectProductForUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__selectProductForUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__productType(struct soap *soap, ns2__productType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__productType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__productType(struct soap *soap, const char *tag, int id, ns2__productType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__productType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__productType ? type : NULL);
}

SOAP_FMAC3 ns2__productType ** SOAP_FMAC4 soap_in_PointerTons2__productType(struct soap *soap, const char *tag, ns2__productType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__productType **)soap_malloc(soap, sizeof(ns2__productType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__productType *)soap_instantiate_ns2__productType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__productType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__productType, sizeof(ns2__productType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__productType(struct soap *soap, ns2__productType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__productType(soap, tag ? tag : "ns2:productType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__productType ** SOAP_FMAC4 soap_get_PointerTons2__productType(struct soap *soap, ns2__productType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__productType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__message(struct soap *soap, ns2__message *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__message))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__message(struct soap *soap, const char *tag, int id, ns2__message *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__message, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__message ? type : NULL);
}

SOAP_FMAC3 ns2__message ** SOAP_FMAC4 soap_in_PointerTons2__message(struct soap *soap, const char *tag, ns2__message **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__message **)soap_malloc(soap, sizeof(ns2__message *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__message *)soap_instantiate_ns2__message(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__message **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__message, sizeof(ns2__message), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__message(struct soap *soap, ns2__message *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__message(soap, tag ? tag : "ns2:message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__message ** SOAP_FMAC4 soap_get_PointerTons2__message(struct soap *soap, ns2__message **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__client(struct soap *soap, ns2__client *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__client))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__client(struct soap *soap, const char *tag, int id, ns2__client *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__client, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__client ? type : NULL);
}

SOAP_FMAC3 ns2__client ** SOAP_FMAC4 soap_in_PointerTons2__client(struct soap *soap, const char *tag, ns2__client **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__client **)soap_malloc(soap, sizeof(ns2__client *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__client *)soap_instantiate_ns2__client(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__client **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__client, sizeof(ns2__client), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__client(struct soap *soap, ns2__client *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__client(soap, tag ? tag : "ns2:client", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__client ** SOAP_FMAC4 soap_get_PointerTons2__client(struct soap *soap, ns2__client **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__client(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__shop(struct soap *soap, ns2__shop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__shop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__shop(struct soap *soap, const char *tag, int id, ns2__shop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__shop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__shop ? type : NULL);
}

SOAP_FMAC3 ns2__shop ** SOAP_FMAC4 soap_in_PointerTons2__shop(struct soap *soap, const char *tag, ns2__shop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__shop **)soap_malloc(soap, sizeof(ns2__shop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__shop *)soap_instantiate_ns2__shop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__shop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__shop, sizeof(ns2__shop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__shop(struct soap *soap, ns2__shop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__shop(soap, tag ? tag : "ns2:shop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__shop ** SOAP_FMAC4 soap_get_PointerTons2__shop(struct soap *soap, ns2__shop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__shop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__order(struct soap *soap, ns2__order *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__order))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__order(struct soap *soap, const char *tag, int id, ns2__order *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__order, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__order ? type : NULL);
}

SOAP_FMAC3 ns2__order ** SOAP_FMAC4 soap_in_PointerTons2__order(struct soap *soap, const char *tag, ns2__order **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__order **)soap_malloc(soap, sizeof(ns2__order *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__order *)soap_instantiate_ns2__order(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__order **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__order, sizeof(ns2__order), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__order(struct soap *soap, ns2__order *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__order(soap, tag ? tag : "ns2:order", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__order ** SOAP_FMAC4 soap_get_PointerTons2__order(struct soap *soap, ns2__order **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__order(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__product(struct soap *soap, ns2__product *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__product))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__product(struct soap *soap, const char *tag, int id, ns2__product *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__product, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__product ? type : NULL);
}

SOAP_FMAC3 ns2__product ** SOAP_FMAC4 soap_in_PointerTons2__product(struct soap *soap, const char *tag, ns2__product **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__product **)soap_malloc(soap, sizeof(ns2__product *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__product *)soap_instantiate_ns2__product(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__product **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__product, sizeof(ns2__product), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__product(struct soap *soap, ns2__product *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__product(soap, tag ? tag : "ns2:product", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__product ** SOAP_FMAC4 soap_get_PointerTons2__product(struct soap *soap, ns2__product **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__shop(struct soap *soap, std::vector<ns2__shop *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__shop(struct soap *soap, const std::vector<ns2__shop *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__shop *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__shop(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__shop(struct soap *soap, const char *tag, int id, const std::vector<ns2__shop *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__shop *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__shop(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__shop *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__shop(struct soap *soap, const char *tag, std::vector<ns2__shop *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__shop(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__shop *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__shop, SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop, sizeof(ns2__shop), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__shop(soap, tag, NULL, "ns2:shop"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__shop(soap, tag, &n, "ns2:shop"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__shop *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__shop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__shop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__shop *> *p;
	size_t k = sizeof(std::vector<ns2__shop *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__shop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__shop *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__shop *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__shop *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__client(struct soap *soap, std::vector<ns2__client *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__client(struct soap *soap, const std::vector<ns2__client *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__client *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__client(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__client(struct soap *soap, const char *tag, int id, const std::vector<ns2__client *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__client *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__client(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__client *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__client(struct soap *soap, const char *tag, std::vector<ns2__client *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__client(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__client *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__client, SOAP_TYPE_std__vectorTemplateOfPointerTons2__client, sizeof(ns2__client), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__client(soap, tag, NULL, "ns2:client"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__client(soap, tag, &n, "ns2:client"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__client *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__client(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__client(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__client *> *p;
	size_t k = sizeof(std::vector<ns2__client *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__client, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__client *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__client *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__client *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__productType(struct soap *soap, std::vector<ns2__productType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__productType(struct soap *soap, const std::vector<ns2__productType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__productType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__productType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__productType(struct soap *soap, const char *tag, int id, const std::vector<ns2__productType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__productType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__productType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__productType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__productType(struct soap *soap, const char *tag, std::vector<ns2__productType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__productType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__productType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__productType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType, sizeof(ns2__productType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__productType(soap, tag, NULL, "ns2:productType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__productType(soap, tag, &n, "ns2:productType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__productType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__productType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__productType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__productType *> *p;
	size_t k = sizeof(std::vector<ns2__productType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__productType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__productType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__productType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__productType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__message(struct soap *soap, std::vector<ns2__message *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__message(struct soap *soap, const std::vector<ns2__message *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__message *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__message(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__message(struct soap *soap, const char *tag, int id, const std::vector<ns2__message *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__message *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__message(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__message *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__message(struct soap *soap, const char *tag, std::vector<ns2__message *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__message(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__message *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__message, SOAP_TYPE_std__vectorTemplateOfPointerTons2__message, sizeof(ns2__message), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__message(soap, tag, NULL, "ns2:message"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__message(soap, tag, &n, "ns2:message"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__message *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__message *> *p;
	size_t k = sizeof(std::vector<ns2__message *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__message, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__message *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__message *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__message *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__product(struct soap *soap, std::vector<ns2__product *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__product(struct soap *soap, const std::vector<ns2__product *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__product *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__product(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__product(struct soap *soap, const char *tag, int id, const std::vector<ns2__product *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__product *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__product(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__product *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__product(struct soap *soap, const char *tag, std::vector<ns2__product *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__product(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__product *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__product, SOAP_TYPE_std__vectorTemplateOfPointerTons2__product, sizeof(ns2__product), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__product(soap, tag, NULL, "ns2:product"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__product(soap, tag, &n, "ns2:product"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__product *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__product(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__product(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__product *> *p;
	size_t k = sizeof(std::vector<ns2__product *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__product, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__product *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__product *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__product *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__order(struct soap *soap, std::vector<ns2__order *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__order(struct soap *soap, const std::vector<ns2__order *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__order *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__order(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__order(struct soap *soap, const char *tag, int id, const std::vector<ns2__order *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__order *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__order(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__order *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__order(struct soap *soap, const char *tag, std::vector<ns2__order *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__order(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__order *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__order, SOAP_TYPE_std__vectorTemplateOfPointerTons2__order, sizeof(ns2__order), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__order(soap, tag, NULL, "ns2:order"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__order(soap, tag, &n, "ns2:order"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__order *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__order(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__order(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__order *> *p;
	size_t k = sizeof(std::vector<ns2__order *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons2__order, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns2__order *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns2__order *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__order *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
